# Module 2: React Deep Dive — Question Bank

**Covers Weeks 5–8:** React rendering model and React Compiler, state management, hooks in depth, component patterns and architecture.

**Scoring:** Wrong answers on T/F and MC are subtracted from right answers. Do not guess.

---

## Part A: True / False (64 Questions)

---

### Rendering Model and React Compiler (Weeks 5)

**TF-1.** React's rendering pipeline has three phases: trigger, render, and commit.

**TF-2.** During the render phase, React calls your component functions and computes a virtual DOM diff.

**TF-3.** The commit phase is when React updates the actual DOM based on the diff computed during rendering.

**TF-4.** A component re-renders only when its own state changes; parent re-renders never cause child re-renders.

**TF-5.** When a parent component re-renders, all of its children re-render by default, even if their props haven't changed.

**TF-6.** React guarantees that the DOM is updated synchronously before the browser paints after a commit.

**TF-7.** "Preserving state" means React keeps a component's state intact between re-renders as long as the component is rendered at the same position in the tree.

**TF-8.** Changing a component's `key` prop forces React to destroy and remount it with fresh state.

**TF-9.** The React Compiler (v1.0, stable October 2025) automatically memoizes components and hooks, making manual `React.memo`, `useMemo`, and `useCallback` the primary optimization strategy.

**TF-10.** With the React Compiler enabled, manual memoization (`React.memo`, `useMemo`, `useCallback`) is an escape hatch, not a default practice.

**TF-11.** The Rules of React include: components must be pure functions (same inputs produce same output), and hooks must be called at the top level (not inside conditions or loops).

**TF-12.** The React Compiler relies on the Rules of React to safely apply automatic memoization. Violating these rules may cause incorrect behavior.

**TF-13.** `React.lazy` enables code splitting by allowing you to dynamically import a component, deferring its loading until it is first rendered.

**TF-14.** A `Suspense` boundary displays a fallback UI while its lazy-loaded children are being fetched.

**TF-15.** You should use the React DevTools Profiler to confirm a performance bottleneck before adding manual memoization.

**TF-16.** `React.memo` prevents a component from re-rendering when its props are shallowly equal to the previous render's props.

---

### State Management (Week 6)

**TF-17.** `useReducer` is an alternative to `useState` that is especially useful when state transitions are complex or when multiple state values are related.

**TF-18.** A reducer function must be pure: given the same state and action, it must return the same new state without side effects.

**TF-19.** The `dispatch` function returned by `useReducer` is stable across re-renders — its identity does not change.

**TF-20.** Context API is designed as a general-purpose state management system and should be used for all shared state in an application.

**TF-21.** When a Context value changes, every component that consumes that Context re-renders, even if it only uses a portion of the value.

**TF-22.** Splitting Context into multiple smaller Contexts can help avoid unnecessary re-renders.

**TF-23.** "Lifting state up" means moving shared state to the closest common ancestor of the components that need it.

**TF-24.** Client state, server state, and URL state are conceptually different categories that are best managed with different tools.

**TF-25.** URL search parameters should be used for UI state that should be shareable via a link (e.g., filters, pagination, sort order).

**TF-26.** Most applications need an external state management library (like Redux or Zustand) for client state.

**TF-27.** External state libraries are warranted when you have complex shared mutable state that multiple unrelated components need to read and write frequently.

**TF-28.** When structuring state, you should avoid redundant state — don't store values that can be computed from other state.

---

### Hooks in Depth (Week 7)

**TF-29.** `useRef` returns a mutable object with a `.current` property that persists across re-renders without causing a re-render when it changes.

**TF-30.** `useRef` can only be used for DOM element references, not for storing arbitrary mutable values.

**TF-31.** Changing `ref.current` triggers a re-render, similar to calling a state setter.

**TF-32.** `useImperativeHandle` is used frequently and is the recommended way to expose component methods to parents.

**TF-33.** `useImperativeHandle` customizes the instance value exposed to parent components when using `forwardRef`, and should be used sparingly.

**TF-34.** `useLayoutEffect` fires synchronously after DOM mutations but before the browser paints, making it suitable for layout measurement.

**TF-35.** `useEffect` and `useLayoutEffect` have identical timing — both fire after the browser paints.

**TF-36.** A stale closure occurs when a function captures a variable from a previous render and uses the outdated value instead of the current one.

**TF-37.** Adding all reactive values used inside an effect to its dependency array is the correct way to prevent stale closure bugs.

**TF-38.** An effect with an empty dependency array (`[]`) runs after every render.

**TF-39.** The cleanup function of a `useEffect` runs before the effect re-executes and when the component unmounts.

**TF-40.** "You Might Not Need an Effect" argues that many uses of `useEffect` should be replaced with event handlers, computed values during render, or other patterns.

**TF-41.** A custom hook must begin with the prefix `use` for React to enforce the Rules of Hooks.

**TF-42.** Custom hooks can call other hooks, but regular functions that don't start with `use` cannot.

**TF-43.** A race condition in effects can occur when an async operation completes after the component has unmounted or after a newer effect has started.

**TF-44.** An effect cleanup function can set an `ignore` flag to discard results from stale async operations, preventing race conditions.

---

### Component Patterns and Architecture (Week 8)

**TF-45.** A compound component is a set of related components that work together and share implicit state, usually via Context.

**TF-46.** The compound component pattern allows the parent to control the composition of children without passing props through every level.

**TF-47.** Render props is a pattern where a component receives a function as a prop (or as `children`) and calls it to determine what to render.

**TF-48.** Higher-order components (HOCs) are the recommended way to share logic between components in 2026.

**TF-49.** HOCs are a historical pattern largely replaced by custom hooks for logic reuse.

**TF-50.** A controlled component is one where React state drives the component's value, and changes are handled via event handlers that update that state.

**TF-51.** An uncontrolled component manages its own internal state, and you read values using refs rather than state.

**TF-52.** For form inputs, the controlled pattern (state + onChange) is generally preferred because it gives React full control over the value.

**TF-53.** React Server Components (RSC) run on the server and send rendered HTML to the client, reducing the JavaScript bundle size.

**TF-54.** React Server Components can use hooks like `useState` and `useEffect` because they are regular React components.

**TF-55.** RSC and client components can be composed together — a server component can render client components as children.

**TF-56.** "Thinking in React" recommends starting by building a static version of the UI without any interactivity, then adding state.

**TF-57.** Good component decomposition means each component should have a single responsibility and be as small as possible.

**TF-58.** A common folder structure convention is to co-locate component files, styles, and tests in the same directory.

**TF-59.** Prop drilling (passing props through many layers) is always a bug that must be fixed with Context.

**TF-60.** Composition (passing components as children or props) is often a better solution to prop drilling than Context.

**TF-61.** The `children` prop is React's built-in composition mechanism, allowing parent components to nest arbitrary content.

**TF-62.** `forwardRef` allows a parent component to pass a ref to a child component's DOM element.

**TF-63.** When refactoring, extracting a custom hook is preferred over creating an HOC for sharing stateful logic.

**TF-64.** A component that derives all its values from props and computes the rest during render needs no effects and no state beyond what is truly independent.

---

## Part B: Short Answer (16 Questions)

---

**SA-1.** Describe the three phases of React's rendering pipeline (trigger, render, commit). What happens in each phase?

---

**SA-2.** Explain what "preserving state" means in React. What causes React to preserve a component's state, and what causes it to reset? Give an example using the `key` prop.

---

**SA-3.** What is the React Compiler, and how does it change the role of `React.memo`, `useMemo`, and `useCallback`? When would you still use manual memoization?

---

**SA-4.** Write a reducer and action type for a todo list. The state should be `{ todos: Todo[]; filter: "all" | "active" | "completed" }`. Actions: `add` (with payload `string`), `toggle` (with payload `number` for the id), and `setFilter`. Show the reducer function.

---

**SA-5.** Explain the performance limitation of Context. When a Context value changes, what re-renders? Describe two strategies to mitigate unnecessary re-renders from Context.

---

**SA-6.** Distinguish between client state, server state, and URL state. Give one example of each and name what tool or pattern is appropriate for managing it.

---

**SA-7.** Explain the difference between `useRef` for DOM references and `useRef` for mutable values. Write one example of each use case.

---

**SA-8.** What is a stale closure? Write a minimal example showing how a stale closure bug can occur in a `useEffect`, and explain how to fix it.

---

**SA-9.** Explain the difference between `useEffect` and `useLayoutEffect`. When should you use `useLayoutEffect`?

---

**SA-10.** The React docs page "You Might Not Need an Effect" identifies common anti-patterns. Describe two situations where developers reach for `useEffect` but shouldn't, and what the correct alternative is.

---

**SA-11.** Write a custom hook `useLocalStorage<T>(key: string, initialValue: T)` that syncs state with `localStorage`. Return a `[T, (value: T) => void]` tuple.

---

**SA-12.** Explain the compound component pattern. Write a minimal example of a `<Tabs>` compound component that uses Context to share the active tab state between `<Tabs>`, `<TabList>`, `<Tab>`, and `<TabPanel>` (pseudocode-level structure is fine, but show the Context usage).

---

**SA-13.** What is the difference between controlled and uncontrolled components? When would you choose one over the other?

---

**SA-14.** Explain what React Server Components are at a conceptual level. What can they do that client components cannot, and what can they NOT do?

---

**SA-15.** Describe a race condition that can occur with async operations inside `useEffect`. Write the cleanup pattern that prevents it.

---

**SA-16.** A junior developer writes this and reports that the count is "always one behind." Explain the bug and the fix.

```tsx
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(count + 1);
    }, 1000);
    return () => clearInterval(id);
  }, []);

  return <p>{count}</p>;
}
```

---

## Part C: Multiple Choice (32 Questions)

---

### Rendering Model and React Compiler

**MC-1.** What are the three phases of React's rendering pipeline, in order?

(a) Mount, Update, Unmount
(b) Trigger, Render, Commit
(c) Parse, Compile, Execute
(d) Create, Diff, Patch

---

**MC-2.** When does a component re-render by default?

(a) Only when its own state changes
(b) Only when its props change
(c) When its own state changes, when its parent re-renders, or when a Context it consumes changes
(d) Only when explicitly called with `forceUpdate()`

---

**MC-3.** What does changing a component's `key` prop do?

(a) Nothing; `key` is only for lists
(b) Forces React to destroy and remount the component with fresh state
(c) Triggers a re-render but preserves state
(d) Optimizes rendering performance

---

**MC-4.** With the React Compiler enabled, what is the primary role of `React.memo`?

(a) It is the default performance optimization every component should use
(b) It is an escape hatch for specific cases where the Compiler's automatic memoization is insufficient
(c) It replaces the React Compiler for components that need manual control
(d) It has no effect when the Compiler is active

---

**MC-5.** What does `React.lazy` enable?

(a) Lazy evaluation of state updates
(b) Code splitting by dynamically importing a component so it is only loaded when rendered
(c) Lazy initialization of Context values
(d) Deferred rendering of all children

---

**MC-6.** Before adding `useMemo` or `React.memo` to optimize a component, what should you do first?

(a) Add them to all components as a precaution
(b) Use the React DevTools Profiler to confirm there is actually a performance bottleneck
(c) Rewrite the component as a class component
(d) Move the component to a Server Component

---

**MC-7.** Which of the following is NOT a Rule of React?

(a) Components must be pure functions
(b) Hooks must be called at the top level, not inside conditions or loops
(c) Components must use `React.memo` for performance
(d) Side effects must happen outside of rendering (in effects or event handlers)

---

**MC-8.** What does a `Suspense` boundary do when a lazy-loaded child is not yet available?

(a) Throws an error
(b) Renders nothing
(c) Displays the `fallback` UI until the child finishes loading
(d) Retries the render three times before failing

---

---

### State Management

**MC-9.** When is `useReducer` preferred over `useState`?

(a) Always; `useReducer` is strictly better
(b) When state transitions are complex, involve multiple sub-values, or when the next state depends on the previous state in non-trivial ways
(c) Only when building Redux-like architectures
(d) When you need to avoid re-renders

---

**MC-10.** What is a key limitation of React Context for state management?

(a) Context values cannot be objects
(b) When the Context value changes, every consumer re-renders, even if they only use a portion of the value
(c) Context cannot be used with TypeScript
(d) Context values are not reactive

---

**MC-11.** Which of the following is the BEST use for URL search parameters?

(a) Storing authentication tokens
(b) UI state that should be shareable via a link, such as filter selections or pagination
(c) Large data objects
(d) Animation state

---

**MC-12.** According to the syllabus, when are external state management libraries warranted?

(a) In every production application
(b) When you have complex shared mutable state that many unrelated components need to read and write
(c) Whenever you use more than three `useState` calls
(d) Never; React's built-in tools are always sufficient

---

**MC-13.** What does "lifting state up" mean?

(a) Moving state from a child component to the nearest common ancestor that needs it
(b) Moving state from the server to the client
(c) Converting `useState` to `useReducer`
(d) Moving state into a global store

---

**MC-14.** Which principle from "Choosing the State Structure" warns against storing values you can compute from other state?

(a) Single source of truth
(b) Avoid redundant state
(c) Keep state flat
(d) Avoid mirroring props in state

---

---

### Hooks in Depth

**MC-15.** What are the two primary uses of `useRef`?

(a) DOM element references and global variable storage
(b) DOM element references and mutable values that persist across renders without causing re-renders
(c) State management and side effect cleanup
(d) Animation timing and CSS transitions

---

**MC-16.** What happens when you mutate `ref.current`?

(a) The component re-renders
(b) Nothing observable — the value changes but no re-render is triggered
(c) React throws an error
(d) The DOM is updated immediately

---

**MC-17.** When should you use `useLayoutEffect` instead of `useEffect`?

(a) For all side effects
(b) When you need to measure or mutate the DOM synchronously before the browser paints (e.g., measuring element dimensions)
(c) When fetching data from an API
(d) When setting up event listeners

---

**MC-18.** What is a stale closure in the context of React hooks?

(a) A closure that has been garbage collected
(b) A function that captures a variable from a previous render and uses the outdated value
(c) A closure that prevents the component from unmounting
(d) A memory leak caused by uncleaned effects

---

**MC-19.** What does the following effect do, and what is the bug?

```tsx
useEffect(() => {
  document.title = `Count: ${count}`;
}, []);
```

(a) Updates the title on every render — no bug
(b) Updates the title once with the initial `count` value and never again, because the dependency array is empty — `count` is missing from dependencies
(c) Causes an infinite loop
(d) Throws a runtime error

---

**MC-20.** What is the purpose of the cleanup function returned from `useEffect`?

(a) To cancel the effect before it runs
(b) To run code when the component unmounts and before the effect re-executes on subsequent renders
(c) To return a value from the effect
(d) To optimize performance

---

**MC-21.** Which of the following is an anti-pattern described in "You Might Not Need an Effect"?

(a) Using `useEffect` to subscribe to an external store
(b) Using `useEffect` to derive computed values that could be calculated during render
(c) Using `useEffect` to set up a WebSocket connection
(d) Using `useEffect` to synchronize with a browser API

---

**MC-22.** A custom hook `useWindowSize` tracks the window dimensions. Where should the event listener be set up?

(a) In the component body, outside of hooks
(b) In a `useEffect` that adds a `resize` listener and returns a cleanup function that removes it
(c) In a `useLayoutEffect` with no cleanup
(d) In a `useMemo` call

---

---

### Component Patterns and Architecture

**MC-23.** What is the compound component pattern?

(a) A single monolithic component that handles all functionality internally
(b) A set of related components that share implicit state (usually via Context) and are composed together by the consumer
(c) A component that renders other components based on a configuration object
(d) Two components that render each other recursively

---

**MC-24.** What is the render props pattern?

(a) Passing JSX as regular props (not `children`)
(b) A component that receives a function as a prop (or as `children`) and calls it to determine what to render, passing data to the function
(c) A higher-order component that wraps another component
(d) A hook that returns a renderable element

---

**MC-25.** Why are HOCs (higher-order components) considered a historical pattern?

(a) They were never part of React
(b) Custom hooks provide a simpler, more composable way to share stateful logic without the wrapper nesting and prop collision issues of HOCs
(c) React removed support for HOCs in version 19
(d) HOCs are slower than class components

---

**MC-26.** What is the difference between a controlled and an uncontrolled form input?

(a) Controlled inputs use `defaultValue`; uncontrolled inputs use `value`
(b) A controlled input's value is driven by React state via `value` and `onChange`; an uncontrolled input manages its own DOM state and is read via refs
(c) Controlled inputs do not trigger re-renders; uncontrolled inputs do
(d) There is no practical difference

---

**MC-27.** What is composition in React?

(a) Combining multiple reducers into one
(b) Passing components as children or props to other components, allowing flexible nesting without prop drilling
(c) Inheriting from a base component class
(d) Using multiple `useEffect` calls in one component

---

**MC-28.** When is composition a better solution than Context for avoiding prop drilling?

(a) Never; always use Context
(b) When the intermediate components don't need the data — you can pass the component that needs the data as `children` or a render prop, skipping the intermediate layers
(c) When you have more than 10 components in the tree
(d) When using TypeScript

---

**MC-29.** What can React Server Components do that client components cannot?

(a) Use `useState` and `useEffect`
(b) Run on the server, directly access databases/file systems, and avoid adding to the client JavaScript bundle
(c) Handle user interactions like clicks and form submissions
(d) Use browser APIs like `window` and `document`

---

**MC-30.** What can client components do that React Server Components cannot?

(a) Render HTML
(b) Accept props
(c) Use hooks (`useState`, `useEffect`, etc.) and handle user interactions
(d) Import other components

---

**MC-31.** What does "Thinking in React" recommend as the first step when building a new UI?

(a) Add all the state and interactivity first
(b) Build a static version with no state or interactivity, then add state
(c) Write all the tests first
(d) Set up the state management library

---

**MC-32.** A developer passes `onClick` through five layers of components to reach a button. What is the best first approach to simplify this?

(a) Use Context immediately
(b) Use composition — pass the `<Button onClick={...} />` as `children` through the intermediate layers
(c) Create a global event bus
(d) Use `forwardRef`

---

---

## Answer Key

### Part A: True / False

| # | Answer | Explanation |
|---|---|---|
| TF-1 | **T** | Trigger (state change or initial render), Render (call components, compute diff), Commit (apply changes to DOM). |
| TF-2 | **T** | The render phase is pure computation — React calls component functions and builds the virtual DOM tree. |
| TF-3 | **T** | The commit phase applies the computed changes to the actual DOM. |
| TF-4 | **F** | Children re-render when their parent re-renders by default, regardless of whether their props changed. |
| TF-5 | **T** | This is default React behavior. The React Compiler mitigates this with automatic memoization. |
| TF-6 | **T** | React synchronously updates the DOM during commit, before the browser paints. |
| TF-7 | **T** | React preserves state when a component stays at the same position in the tree with the same type. |
| TF-8 | **T** | A different `key` tells React this is a new component instance, so it destroys the old one and creates fresh state. |
| TF-9 | **F** | The React Compiler makes manual memoization an escape hatch, not the primary strategy. The statement reverses the relationship. |
| TF-10 | **T** | This is the syllabus's explicit position. The Compiler handles memoization; manual versions are for edge cases. |
| TF-11 | **T** | Purity and top-level hook calls are two of the core Rules of React. |
| TF-12 | **T** | The Compiler assumes your code follows the Rules. Violations can lead to incorrect memoization. |
| TF-13 | **T** | `React.lazy(() => import("./Component"))` defers loading until the component is needed. |
| TF-14 | **T** | `Suspense` renders its `fallback` prop while lazy children are loading. |
| TF-15 | **T** | Always profile first. Don't optimize without evidence of a problem. |
| TF-16 | **T** | `React.memo` performs a shallow prop comparison and skips re-rendering if props are equal. |
| TF-17 | **T** | `useReducer` centralizes complex state transitions and makes them predictable. |
| TF-18 | **T** | Reducers must be pure — no side effects, no mutations, deterministic output. |
| TF-19 | **T** | `dispatch` has a stable identity. It can be safely passed to child components or used in dependency arrays. |
| TF-20 | **F** | Context is for passing data deeply, not general state management. It has performance limitations when values change frequently. |
| TF-21 | **T** | Any component calling `useContext(MyContext)` re-renders when the Context value changes, even if it doesn't use the changed portion. |
| TF-22 | **T** | Splitting into `ThemeContext` and `UserContext` avoids re-rendering theme consumers when user data changes. |
| TF-23 | **T** | This is the standard React pattern for sharing state between sibling components. |
| TF-24 | **T** | Client state (UI toggles), server state (fetched data), and URL state (search params) have different lifecycles and tools. |
| TF-25 | **T** | URL params make filter/sort/pagination states bookmarkable and shareable. |
| TF-26 | **F** | The syllabus explicitly states most apps do not need external state libraries. `useState`, `useReducer`, and Context cover most cases. |
| TF-27 | **T** | Complex shared mutable state accessed by many unrelated components is the legitimate use case for external libraries. |
| TF-28 | **T** | The "Choosing the State Structure" page calls this avoiding redundant state. Compute what you can from existing state. |
| TF-29 | **T** | `useRef` returns `{ current: T }` that persists across renders. Changing `.current` does not trigger a re-render. |
| TF-30 | **F** | `useRef` is also for storing mutable values like interval IDs, previous values, or any value that should persist without causing re-renders. |
| TF-31 | **F** | Mutating `ref.current` does NOT trigger a re-render. This is the key difference from state. |
| TF-32 | **F** | `useImperativeHandle` is rarely needed. The React docs say to use it sparingly. |
| TF-33 | **T** | It customizes what is exposed via `forwardRef` and should be used only when a parent genuinely needs to call child methods. |
| TF-34 | **T** | `useLayoutEffect` fires synchronously after DOM mutations, before the browser paints. Useful for measuring layout. |
| TF-35 | **F** | `useEffect` fires after the browser paints. `useLayoutEffect` fires before the paint. This is the key difference. |
| TF-36 | **T** | Stale closures are one of the most common sources of bugs in React hooks code. |
| TF-37 | **T** | The dependency array must include all reactive values the effect reads. This is enforced by the exhaustive-deps lint rule. |
| TF-38 | **F** | An empty dependency array means the effect runs once (on mount) and cleanup runs on unmount. |
| TF-39 | **T** | Cleanup runs before each re-execution of the effect and when the component unmounts. |
| TF-40 | **T** | Many effects should be replaced with event handlers, memo calculations, or initializers. |
| TF-41 | **T** | The `use` prefix is required for React to enforce the Rules of Hooks. |
| TF-42 | **T** | Only functions starting with `use` (custom hooks) or React components may call hooks. |
| TF-43 | **T** | If two fetches are fired and the first completes after the second, you get stale data unless you handle the race condition. |
| TF-44 | **T** | The cleanup sets `ignore = true` so the stale response is discarded: `let ignore = false; ... return () => { ignore = true; }`. |
| TF-45 | **T** | Compound components share state implicitly (usually via Context) and are composed together. |
| TF-46 | **T** | The consumer controls composition via children; the compound component provides shared state via Context. |
| TF-47 | **T** | Render props pass data from a component to a function that determines the rendering. |
| TF-48 | **F** | HOCs are a historical pattern. Custom hooks are the recommended approach in 2026. |
| TF-49 | **T** | Custom hooks avoid the wrapper nesting, prop name collisions, and indirection issues of HOCs. |
| TF-50 | **T** | Controlled components have their value driven by state and updated via event handlers. |
| TF-51 | **T** | Uncontrolled components use `defaultValue` and are read via refs. The DOM is the source of truth. |
| TF-52 | **T** | Controlled inputs give you full programmatic control over the value, validation, and formatting. |
| TF-53 | **T** | RSC run on the server, produce HTML, and their JavaScript is not sent to the client. |
| TF-54 | **F** | RSC cannot use hooks (`useState`, `useEffect`, etc.) because they don't run on the client. |
| TF-55 | **T** | Server and client components compose freely — a server component can render client component children. |
| TF-56 | **T** | "Thinking in React" recommends building a static version first, then identifying and adding state. |
| TF-57 | **T** | Single responsibility per component leads to maintainable, testable code. |
| TF-58 | **T** | Co-location keeps related files together: `Button/Button.tsx`, `Button/Button.test.tsx`, `Button/Button.module.css`. |
| TF-59 | **F** | Prop drilling is not always a bug. Sometimes passing props explicitly is clearer than Context. Composition is often a better fix than Context. |
| TF-60 | **T** | Passing components as children skips intermediate layers entirely — the data goes directly to where it's needed. |
| TF-61 | **T** | `children` is React's primary composition primitive. |
| TF-62 | **T** | `forwardRef` allows refs to pass through to a child's DOM node. |
| TF-63 | **T** | Custom hooks are simpler, more composable, and avoid the nesting issues of HOCs. |
| TF-64 | **T** | If you can derive it during render, you don't need an effect or additional state. |

### Part B: Short Answer

**SA-1.**
**Trigger:** Something causes React to schedule a render — an initial mount, a state change (`setState`), or a Context change. **Render:** React calls component functions to produce the new virtual DOM tree and diffs it against the previous tree to determine what changed. **Commit:** React applies the minimal set of DOM changes computed during the render phase to the actual DOM. After commit, the browser paints the updated UI.

---

**SA-2.**
React preserves a component's state as long as the component appears at the same position in the tree with the same component type. If the component type or position changes, state is destroyed and recreated. The `key` prop overrides this: giving a component a different `key` forces React to treat it as a new instance, destroying old state.

```tsx
// Changing key resets the form's state entirely
<ProfileForm key={userId} userId={userId} />
```

---

**SA-3.**
The React Compiler (stable v1.0, October 2025) automatically memoizes component renders and hook computations by analyzing your code at build time. This makes `React.memo`, `useMemo`, and `useCallback` unnecessary as a default practice — the Compiler handles it. You would still use manual memoization as an escape hatch when the Compiler cannot optimize a specific case (e.g., a component that the Profiler shows is still a bottleneck), or in codebases that haven't adopted the Compiler yet.

---

**SA-4.**

```ts
type Todo = { id: number; text: string; completed: boolean };

type State = {
  todos: Todo[];
  filter: "all" | "active" | "completed";
};

type Action =
  | { type: "add"; payload: string }
  | { type: "toggle"; payload: number }
  | { type: "setFilter"; payload: "all" | "active" | "completed" };

function todoReducer(state: State, action: Action): State {
  switch (action.type) {
    case "add":
      return {
        ...state,
        todos: [...state.todos, { id: Date.now(), text: action.payload, completed: false }],
      };
    case "toggle":
      return {
        ...state,
        todos: state.todos.map(t =>
          t.id === action.payload ? { ...t, completed: !t.completed } : t
        ),
      };
    case "setFilter":
      return { ...state, filter: action.payload };
  }
}
```

---

**SA-5.**
When a Context value changes, every component that calls `useContext(ThatContext)` re-renders, even if it only uses a small portion of the value. Two mitigation strategies: (1) Split a large Context into multiple smaller Contexts so consumers only subscribe to the data they need. (2) Memoize the Context value object with `useMemo` so its reference only changes when the actual data changes (though with the React Compiler, this may be handled automatically).

---

**SA-6.**
**Client state:** UI-only data like whether a modal is open. Managed with `useState` or `useReducer`. **Server state:** Data fetched from an API, like a list of users. Managed with TanStack Query (covered in Week 14). **URL state:** State that should survive page refresh and be shareable via a link, like search filters or pagination. Managed with URL search parameters (`useSearchParams` in a router or manual `URLSearchParams`).

---

**SA-7.**
DOM reference: `const inputRef = useRef<HTMLInputElement>(null)` — used to call `.focus()` or measure dimensions. Mutable value: `const intervalRef = useRef<number | null>(null)` — stores an interval ID that persists across renders without causing re-renders when changed.

```ts
// DOM ref
const inputRef = useRef<HTMLInputElement>(null);
// later: inputRef.current?.focus();

// Mutable value
const countRef = useRef(0);
// later: countRef.current += 1; // no re-render
```

---

**SA-8.**
A stale closure captures a variable from a previous render's scope.

```tsx
const [count, setCount] = useState(0);
useEffect(() => {
  const id = setInterval(() => {
    console.log(count); // always logs 0 — stale closure
  }, 1000);
  return () => clearInterval(id);
}, []); // count not in dependency array
```

Fix: either add `count` to the dependency array (effect restarts on each change), or use the functional updater: `setCount(c => c + 1)` which doesn't need the current `count` in the closure.

---

**SA-9.**
`useEffect` fires asynchronously after the browser paints. `useLayoutEffect` fires synchronously after DOM mutations but before the browser paints. Use `useLayoutEffect` when you need to measure or mutate the DOM before the user sees the result — for example, measuring an element's dimensions to position a tooltip, or preventing a visual flash by adjusting layout before paint.

---

**SA-10.**
(1) **Deriving computed values:** Using `useEffect` to compute a filtered list from state and store it in another state variable. Correct alternative: compute it during render (`const filtered = todos.filter(...)`). (2) **Responding to user events:** Using `useEffect` to react to a state change that was triggered by a button click. Correct alternative: put the logic in the event handler directly.

---

**SA-11.**

```ts
function useLocalStorage<T>(key: string, initialValue: T): [T, (value: T) => void] {
  const [stored, setStored] = useState<T>(() => {
    const item = localStorage.getItem(key);
    return item ? JSON.parse(item) : initialValue;
  });

  const setValue = (value: T) => {
    setStored(value);
    localStorage.setItem(key, JSON.stringify(value));
  };

  return [stored, setValue];
}
```

---

**SA-12.**
The compound component pattern uses Context to share implicit state among related components that are composed together by the consumer.

```tsx
const TabsContext = createContext<{ activeIndex: number; setActiveIndex: (i: number) => void }>(/* ... */);

function Tabs({ children }: { children: React.ReactNode }) {
  const [activeIndex, setActiveIndex] = useState(0);
  return (
    <TabsContext.Provider value={{ activeIndex, setActiveIndex }}>
      {children}
    </TabsContext.Provider>
  );
}

function Tab({ index, children }: { index: number; children: React.ReactNode }) {
  const { activeIndex, setActiveIndex } = useContext(TabsContext);
  return <button onClick={() => setActiveIndex(index)} data-active={activeIndex === index}>{children}</button>;
}

function TabPanel({ index, children }: { index: number; children: React.ReactNode }) {
  const { activeIndex } = useContext(TabsContext);
  return activeIndex === index ? <div>{children}</div> : null;
}

// Usage:
// <Tabs>
//   <Tab index={0}>First</Tab>
//   <Tab index={1}>Second</Tab>
//   <TabPanel index={0}>Content 1</TabPanel>
//   <TabPanel index={1}>Content 2</TabPanel>
// </Tabs>
```

---

**SA-13.**
A **controlled** component's value is driven by React state: `<input value={name} onChange={e => setName(e.target.value)} />`. React is the source of truth. An **uncontrolled** component manages its own DOM state: `<input defaultValue="hello" ref={inputRef} />`. The DOM is the source of truth; you read the value via `inputRef.current.value`. Use controlled for most cases (validation, formatting, conditional logic). Use uncontrolled for simple forms where you only need the value on submit, or when integrating with non-React code.

---

**SA-14.**
React Server Components run on the server and send rendered HTML to the client. They can directly access server resources (databases, file systems, environment variables) and their JavaScript code is NOT included in the client bundle. They CANNOT use hooks (`useState`, `useEffect`), handle user interactions, or use browser APIs. Client components handle interactivity. RSC and client components compose together — a server component can render client components as children.

---

**SA-15.**
If two fetches are triggered (e.g., user types quickly, triggering a search effect twice), the first fetch may complete after the second, replacing the correct result with stale data.

```ts
useEffect(() => {
  let ignore = false;

  async function fetchData() {
    const result = await fetch(`/api/search?q=${query}`);
    const data = await result.json();
    if (!ignore) {
      setResults(data);
    }
  }

  fetchData();
  return () => { ignore = true; };
}, [query]);
```

The cleanup sets `ignore = true` before the next effect runs, so stale responses are discarded.

---

**SA-16.**
The effect captures the initial `count` value (0) in a closure and never sees updates because `count` is not in the dependency array. Every tick calls `setCount(0 + 1)`, so the count stays at 1. Fix: use the functional updater form, which receives the current state as an argument:

```ts
setCount(c => c + 1);
```

This way the callback doesn't depend on the closed-over `count` variable. Alternatively, add `count` to the dependency array, but that recreates the interval on every tick, which is less efficient.

---

### Part C: Multiple Choice

| # | Answer | Explanation |
|---|---|---|
| MC-1 | **(b)** | Trigger, Render, Commit — the three phases described in the React docs. |
| MC-2 | **(c)** | Components re-render on their own state changes, parent re-renders, and consumed Context changes. |
| MC-3 | **(b)** | Changing `key` tells React to treat the component as a new instance, destroying old state. |
| MC-4 | **(b)** | With the Compiler, `React.memo` is an escape hatch for cases the Compiler can't optimize automatically. |
| MC-5 | **(b)** | `React.lazy` dynamically imports components, enabling code splitting. |
| MC-6 | **(b)** | Profile first, optimize only where needed. |
| MC-7 | **(c)** | Using `React.memo` is not a Rule of React. The rules are about purity, top-level hook calls, and side effects. |
| MC-8 | **(c)** | `Suspense` renders its `fallback` until lazy children are ready. |
| MC-9 | **(b)** | `useReducer` is preferred for complex state logic with multiple related values and non-trivial transitions. |
| MC-10 | **(b)** | All consumers re-render when the value changes, even if they use only a portion. |
| MC-11 | **(b)** | URL params make UI state shareable and bookmarkable. |
| MC-12 | **(b)** | External libraries are warranted for complex shared mutable state across unrelated components. |
| MC-13 | **(a)** | Lifting state means moving it to the nearest common ancestor of components that need it. |
| MC-14 | **(b)** | Don't store what you can compute from other state values. |
| MC-15 | **(b)** | `useRef` serves two purposes: DOM references and mutable values that persist without causing re-renders. |
| MC-16 | **(b)** | Mutating `ref.current` changes the value silently — no re-render occurs. |
| MC-17 | **(b)** | `useLayoutEffect` is for synchronous DOM measurement/mutation before the browser paints. |
| MC-18 | **(b)** | A stale closure captures an old render's variable value. |
| MC-19 | **(b)** | The empty dependency array means the effect captures the initial `count` and never re-runs. `count` is missing from deps. |
| MC-20 | **(b)** | Cleanup runs before re-execution and on unmount — for teardown of subscriptions, timers, etc. |
| MC-21 | **(b)** | Computing derived values in an effect is an anti-pattern. Compute them during render instead. |
| MC-22 | **(b)** | Event listeners belong in `useEffect` with a cleanup function that removes them. |
| MC-23 | **(b)** | Compound components share implicit state via Context and are composed by the consumer. |
| MC-24 | **(b)** | Render props pass data to a function that returns JSX. |
| MC-25 | **(b)** | Custom hooks provide the same logic-sharing benefit without wrapper nesting or prop collisions. |
| MC-26 | **(b)** | Controlled: `value` + `onChange`. Uncontrolled: `defaultValue` + ref. |
| MC-27 | **(b)** | Composition means passing components as children or props to avoid prop drilling. |
| MC-28 | **(b)** | When intermediaries don't need the data, pass the consuming component directly via children. |
| MC-29 | **(b)** | RSC run on the server, can access server resources, and don't add to the client JS bundle. |
| MC-30 | **(c)** | Client components can use hooks and handle user interactions; RSC cannot. |
| MC-31 | **(b)** | Build the static version first, then identify and add state. |
| MC-32 | **(b)** | Composition (passing the button as children) is the simplest fix before reaching for Context. |
