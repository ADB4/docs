# Week 15 Quiz: Mocking, Async Testing, and Hook Testing

**Scope:** `vi.fn()`, `vi.spyOn()`, `vi.mock()`, mock lifecycle (`mockClear`/`mockReset`/`mockRestore`), mocking modules and API calls, fake timers (`vi.useFakeTimers`), testing async behavior (`findBy`, `waitFor`, `waitForElementToBeRemoved`), testing custom hooks with `renderHook`, mocking Context providers, mocking `fetch` or API layers.

**Assigned Readings:**
- Vitest: "Mocking" guide
- Vitest: "Mock Functions" API reference
- Vitest: "Vi" API reference (`vi.fn`, `vi.spyOn`, `vi.mock`, `vi.mocked`, `vi.hoisted`, `vi.useFakeTimers`)
- Vitest: "Mocking Modules" guide (hoisting, factory pattern, automocking, `importOriginal`)
- RTL: "renderHook" API reference
- TL: "Async Utilities" (`waitFor`, `waitForElementToBeRemoved`, `findBy`)
- Vitest: "Fake Timers" guide
- KCD: "How to Test Custom React Hooks"

**Scoring:** Wrong answers on T/F and MC are subtracted from right answers. Do not guess. Short answer questions are graded on correctness and conciseness — do not write more than is asked for.

---

## Part A: True / False (72 Questions)

---

**TF-1.** `vi.fn()` creates a standalone mock function that tracks calls, arguments, and return values without wrapping any existing function.

**TF-2.** A mock function created with `vi.fn()` has no implementation by default — calling it returns `undefined`.

**TF-3.** `vi.fn(() => 42)` creates a mock function with a default implementation that returns `42`.

**TF-4.** `vi.spyOn(object, 'method')` replaces the original method's implementation with an empty mock by default.

**TF-5.** `vi.spyOn(object, 'method')` wraps the original method to track calls while preserving the original implementation by default.

**TF-6.** After calling `vi.spyOn(obj, 'method')`, calling `obj.method()` still executes the original implementation unless you explicitly override it.

**TF-7.** `vi.mock('./module')` replaces the real module with a mocked version when tests import it.

**TF-8.** `vi.mock()` calls are executed in the order they appear in the file, just like regular JavaScript statements.

**TF-9.** `vi.mock()` calls are hoisted to the top of the file before imports, regardless of where you write them in the code.

**TF-10.** Because `vi.mock()` is hoisted, you cannot reference variables declared with `const` or `let` inside the `vi.mock()` factory function.

**TF-11.** `vi.hoisted()` allows you to declare variables that are accessible inside `vi.mock()` factory functions by placing the declaration before the hoisted mock.

**TF-12.** When `vi.mock('./module')` is called without a factory function, Vitest automatically replaces all exported functions with `vi.fn()` (automocking).

**TF-13.** The factory function passed to `vi.mock('./module', () => ({ ... }))` must return an object whose shape matches the module's exports.

**TF-14.** `vi.mocked(fn)` changes the runtime behavior of `fn`. It makes the function a mock at runtime.

**TF-15.** `vi.mocked(fn)` is a type helper that tells TypeScript to treat `fn` as a mock, giving you access to mock properties like `.mockReturnValue` without type errors.

**TF-16.** `mockFn.mockReturnValue(42)` makes the mock return `42` for all subsequent calls.

**TF-17.** `mockFn.mockReturnValueOnce(42)` makes the mock return `42` only for the next call. After that, it reverts to its default return value (or `undefined`).

**TF-18.** `mockFn.mockResolvedValue(data)` is shorthand for `mockFn.mockReturnValue(Promise.resolve(data))`.

**TF-19.** `mockFn.mockResolvedValueOnce(data)` makes the mock return a resolved Promise with `data` for the next call only.

**TF-20.** `mockFn.mockRejectedValue(error)` makes the mock return a rejected Promise with the given error.

**TF-21.** `mockFn.mockImplementation(fn)` replaces the mock's implementation with the provided function.

**TF-22.** `mockFn.mock.calls` is an array of arrays, where each inner array contains the arguments from one call to the mock.

**TF-23.** `mockFn.mock.results` contains the return value of each call to the mock.

**TF-24.** `expect(mockFn).toHaveBeenCalledWith(arg1, arg2)` asserts that the mock was called at least once with exactly those arguments.

**TF-25.** `expect(mockFn).toHaveBeenCalledTimes(3)` asserts the mock was called exactly 3 times.

**TF-26.** `mockClear()` resets the mock's call history (`mock.calls` and `mock.results`) but preserves its implementation.

**TF-27.** `mockReset()` resets the mock's call history AND removes any custom implementation, reverting it to a function that returns `undefined`.

**TF-28.** `mockRestore()` is only meaningful for spies created with `vi.spyOn()`. It restores the original method implementation.

**TF-29.** `mockRestore()` on a `vi.fn()` mock has the same effect as `mockReset()` because there is no original implementation to restore.

**TF-30.** `vi.restoreAllMocks()` calls `mockRestore()` on every mock and spy created in the test.

**TF-31.** It is good practice to call `vi.restoreAllMocks()` in `afterEach` to ensure mocks do not leak between tests.

**TF-32.** When mocking a module that exports a default function, the factory must return an object with a `default` property.

**TF-33.** `importOriginal` inside a `vi.mock` factory lets you import the real module and selectively override only certain exports while preserving the rest.

**TF-34.** `vi.useFakeTimers()` replaces `setTimeout`, `setInterval`, `Date`, and other time-related APIs with Vitest-controlled implementations.

**TF-35.** After calling `vi.useFakeTimers()`, `setTimeout` callbacks will never execute unless you manually advance time.

**TF-36.** `vi.advanceTimersByTime(1000)` advances the fake clock by 1000 milliseconds and executes any timers that were scheduled to fire during that period.

**TF-37.** `vi.runAllTimers()` executes all pending timers immediately, regardless of their scheduled time.

**TF-38.** `vi.useRealTimers()` restores the original timer implementations after a test that used fake timers.

**TF-39.** You should always call `vi.useRealTimers()` in `afterEach` when using fake timers to prevent timer state from leaking into subsequent tests.

**TF-40.** `vi.setSystemTime(new Date('2025-01-01'))` sets the current date returned by `new Date()` and `Date.now()` when fake timers are active.

**TF-41.** Fake timers are appropriate for testing `setTimeout` and `setInterval` logic, such as debounce functions.

**TF-42.** Fake timers should be used for testing data fetching loading states because `fetch` relies on timers.

**TF-43.** For testing async data fetching (e.g., components that show loading → data), `findBy` queries or `waitFor` are preferred over fake timers.

**TF-44.** `renderHook` from RTL renders a custom hook in isolation by wrapping it in a minimal test component.

**TF-45.** `renderHook` returns an object with a `result` property. The current return value of the hook is at `result.current`.

**TF-46.** You can test a custom hook by directly calling it outside of a React component.

**TF-47.** The KCD guidance on testing hooks is: prefer testing hooks through the components that use them. Use `renderHook` only when the hook is shared by many components or has complex logic worth isolating.

**TF-48.** `renderHook` accepts a `wrapper` option for providing Context providers, just like `render`.

**TF-49.** To test a hook that reads from Context, you must provide the Context via the `wrapper` option in `renderHook`.

**TF-50.** When testing a hook that triggers state updates, you must wrap the state update call in `act()`.

**TF-51.** `waitFor` repeatedly invokes the callback function until it stops throwing or the timeout is reached.

**TF-52.** The default timeout for `waitFor` is 1000 milliseconds.

**TF-53.** `waitFor` should be used for all assertions in a test, even those that do not involve async behavior.

**TF-54.** `waitForElementToBeRemoved` throws if the element is not present in the DOM when first called.

**TF-55.** `waitForElementToBeRemoved` is useful for waiting for a loading spinner to disappear.

**TF-56.** To mock the global `fetch` function, you can assign a mock to `globalThis.fetch = vi.fn()`.

**TF-57.** When mocking `fetch`, you should mock the entire request/response cycle, including `response.json()` returning a Promise.

**TF-58.** A better practice than mocking `fetch` directly is to create an API layer module and mock that module, keeping the transport layer out of the test.

**TF-59.** `vi.mock('./api')` with no factory auto-mocks all functions exported from `./api`, replacing them with `vi.fn()`.

**TF-60.** When a component under test calls `fetch('/api/users')`, and `fetch` is mocked with `vi.fn().mockResolvedValue({ json: () => Promise.resolve([]) })`, the component will receive an empty array when it calls `response.json()`.

**TF-61.** Mocking a module in one test file affects that module in all other test files.

**TF-62.** Each test file in Vitest runs in its own isolated context, so `vi.mock()` in one file does not affect other files.

**TF-63.** You can use `mockReturnValueOnce` chained multiple times to return different values on successive calls.

**TF-64.** `vi.fn().mockReturnValueOnce(1).mockReturnValueOnce(2).mockReturnValue(0)` returns `1` on the first call, `2` on the second, and `0` for all subsequent calls.

**TF-65.** `vi.spyOn(console, 'error').mockImplementation(() => {})` suppresses console.error output during the test while tracking calls.

**TF-66.** If you spy on `console.error` and do not restore it, the suppression leaks into subsequent tests.

**TF-67.** `vi.runOnlyPendingTimers()` executes only the timers currently scheduled, without executing new timers that may be created by those callbacks.

**TF-68.** `vi.advanceTimersByTime(500)` with a `setInterval` of 200ms will trigger the interval callback twice (at 200ms and 400ms).

**TF-69.** `renderHook` can only test hooks that use `useState`. It does not support hooks that use `useEffect`.

**TF-70.** After calling `result.current.increment()` from a `renderHook` test, you should re-read `result.current` to get the updated value — `result` is a ref-like object.

**TF-71.** `vi.mock` with `importOriginal` inside the factory allows you to mock only specific exports while keeping the rest of the real module intact.

**TF-72.** When testing a component that fetches data on mount, you should mock the API call to return test data and use `findBy` to wait for the rendered data to appear.

---

## Part B: Short Answer (16 Questions)

---

**SA-1.** Explain the difference between `vi.fn()`, `vi.spyOn()`, and `vi.mock()`. Give a one-sentence use case for each.

---

**SA-2.** Explain the difference between `mockClear()`, `mockReset()`, and `mockRestore()`. Under what circumstances would you use each one?

---

**SA-3.** Why is `vi.mock()` hoisted to the top of the file? What problem does this solve, and what limitation does it create?

---

**SA-4.** What is `vi.hoisted()` and when do you need it? Write a short example showing a variable declared with `vi.hoisted()` used inside a `vi.mock()` factory.

---

**SA-5.** Write a test for a component that displays "Loading..." initially, then shows a list of users fetched from an API. Mock the API call and test both the loading state and the final rendered state.

---

**SA-6.** Explain `mockResolvedValue` and `mockResolvedValueOnce`. Write a mock that returns `"first"` on the first call, `"second"` on the second, and `"default"` for all subsequent calls.

---

**SA-7.** Write a test for a debounce function using fake timers. The function should only call the callback once after 500ms of inactivity.

---

**SA-8.** Explain the difference between `vi.advanceTimersByTime()`, `vi.runAllTimers()`, and `vi.runOnlyPendingTimers()`.

---

**SA-9.** What does `vi.mocked()` do? Why is it necessary when using TypeScript with Vitest mocks?

---

**SA-10.** Write a `renderHook` test for a custom `useCounter` hook that has `count`, `increment`, and `decrement` in its return value. Test that `increment` increases the count.

---

**SA-11.** KCD says to prefer testing hooks through components rather than with `renderHook`. In 2–3 sentences, explain why. When is `renderHook` the better choice?

---

**SA-12.** Write a test that mocks a module using `vi.mock()` with `importOriginal` to override only one function while keeping the rest of the real module intact.

---

**SA-13.** A test mocks `fetch` but forgets to restore it in `afterEach`. What problem does this cause, and how do you fix it?

---

**SA-14.** Explain the pattern for mocking a Context provider in a `renderHook` or `render` test. Write a snippet showing how to provide a mocked value for a `UserContext`.

---

**SA-15.** What is the difference between using fake timers and using `findBy`/`waitFor` for testing async behavior? When should you choose each approach?

---

**SA-16.** A developer writes this mock but it does not work. Explain the problem and provide the fix.

```ts
const mockFetch = vi.fn();
vi.mock('./api', () => ({
  fetchUsers: mockFetch,
}));
```

---

## Part C: Multiple Choice (48 Questions)

Choose the single best answer.

---

**MC-1.** `vi.fn()` creates:

(a) A spy that wraps an existing function
(b) A standalone mock function that tracks calls and can be configured with return values
(c) A module-level mock
(d) A fake timer

---

**MC-2.** What does `vi.spyOn(obj, 'method')` do by default?

(a) Replaces `obj.method` with an empty function
(b) Wraps `obj.method` to track calls while preserving the original implementation
(c) Deletes `obj.method`
(d) Creates a new object with a mocked `method`

---

**MC-3.** `vi.mock('./module')` without a factory function:

(a) Does nothing
(b) Throws an error
(c) Auto-mocks all exported functions from the module with `vi.fn()`
(d) Imports the module normally

---

**MC-4.** `vi.mock()` calls are hoisted because:

(a) They need to run before imports so the mock is in place when the module is first loaded
(b) Vitest alphabetizes all function calls
(c) JavaScript requires mocks to be at the top of the file
(d) It is a TypeScript requirement

---

**MC-5.** What problem does hoisting create for `vi.mock()` factory functions?

(a) Factory functions cannot return objects
(b) Variables declared with `const`/`let` after the mock are not yet initialized when the factory runs
(c) Factory functions cannot use `import`
(d) The factory runs after the module loads

---

**MC-6.** `vi.hoisted()` is used to:

(a) Move a test to the top of the file
(b) Declare variables that are accessible inside `vi.mock()` factories despite hoisting
(c) Hoist `describe` blocks
(d) Prioritize certain tests

---

**MC-7.** `mockFn.mockReturnValue(42)` causes the mock to return `42`:

(a) Only on the next call
(b) On all subsequent calls
(c) Only when called with specific arguments
(d) Only in the current test

---

**MC-8.** `mockFn.mockReturnValueOnce(42)` causes the mock to return `42`:

(a) On all subsequent calls
(b) Only on the next call, then reverts to default
(c) Only when called with `42` as an argument
(d) On the last call only

---

**MC-9.** `mockFn.mockResolvedValue(data)` is equivalent to:

(a) `mockFn.mockReturnValue(data)`
(b) `mockFn.mockReturnValue(Promise.resolve(data))`
(c) `mockFn.mockImplementation(async () => data)`
(d) Both (b) and (c)

---

**MC-10.** What does `mockClear()` reset?

(a) Call history only (calls and results)
(b) Call history and implementation
(c) Call history, implementation, and original function
(d) Nothing

---

**MC-11.** What does `mockReset()` reset?

(a) Call history only
(b) Call history and implementation (reverts to returning `undefined`)
(c) Call history, implementation, and original function
(d) Only the return value

---

**MC-12.** What does `mockRestore()` do that `mockReset()` does not?

(a) It clears call history
(b) It removes the mock implementation
(c) It restores the original method implementation (meaningful only for `vi.spyOn`)
(d) It deletes the mock entirely

---

**MC-13.** `vi.restoreAllMocks()` is best placed in:

(a) `beforeAll`
(b) `beforeEach`
(c) `afterEach`
(d) `afterAll`

---

**MC-14.** When mocking a module's default export, the factory should return:

(a) The mock function directly
(b) `{ default: mockFn }`
(c) `{ __esModule: true, default: mockFn }`
(d) Either (b) or (c) depending on module system

---

**MC-15.** `importOriginal` inside `vi.mock` allows you to:

(a) Import a different module
(b) Import the real module and selectively override specific exports
(c) Import the test file itself
(d) Import from node_modules only

---

**MC-16.** `vi.useFakeTimers()` replaces:

(a) Only `setTimeout`
(b) `setTimeout`, `setInterval`, `Date`, and other time APIs
(c) Only `Date`
(d) The test runner's internal timer

---

**MC-17.** After `vi.useFakeTimers()`, a `setTimeout(fn, 1000)` callback will execute:

(a) After 1 real second
(b) Immediately
(c) Only when you manually advance time with `vi.advanceTimersByTime(1000)` or similar
(d) Never

---

**MC-18.** `vi.advanceTimersByTime(500)` does what?

(a) Pauses the test for 500ms
(b) Advances the fake clock by 500ms and fires all timers scheduled within that window
(c) Sets the clock to exactly 500ms
(d) Skips 500ms of real time

---

**MC-19.** `vi.runAllTimers()` is useful when:

(a) You want to advance time by a specific amount
(b) You want to execute all pending and recursively created timers immediately
(c) You want to restore real timers
(d) You want to pause timer execution

---

**MC-20.** `vi.runOnlyPendingTimers()` differs from `vi.runAllTimers()` in that:

(a) It runs no timers
(b) It only executes currently scheduled timers, not new ones created by those callbacks
(c) It runs timers in reverse order
(d) It only runs `setInterval` timers

---

**MC-21.** When should you use fake timers instead of `findBy`/`waitFor`?

(a) When testing data fetching
(b) When testing timer-based logic like debounce, throttle, or auto-save intervals
(c) When testing form submission
(d) When testing CSS animations

---

**MC-22.** When should you use `findBy`/`waitFor` instead of fake timers?

(a) When testing debounce functions
(b) When testing `setInterval` logic
(c) When testing async data fetching, state transitions, or any behavior driven by Promises
(d) When testing `setTimeout`

---

**MC-23.** `vi.setSystemTime(new Date('2025-06-15'))` is used for:

(a) Delaying the test by a duration
(b) Setting the fake system clock to a specific date/time
(c) Scheduling a timer
(d) Restoring real time

---

**MC-24.** `renderHook` is imported from:

(a) `vitest`
(b) `@testing-library/react`
(c) `@testing-library/react-hooks` (deprecated)
(d) `react`

---

**MC-25.** `renderHook(() => useCounter())` returns:

(a) The counter value directly
(b) An object with a `result` property where `result.current` holds the hook's return value
(c) A React component
(d) A Promise

---

**MC-26.** To trigger a state update from `renderHook`, you should:

(a) Call the update function directly: `result.current.increment()`
(b) Wrap the call in `act()`: `act(() => { result.current.increment(); })`
(c) Re-render the hook
(d) Create a new `renderHook` call

---

**MC-27.** KCD recommends using `renderHook` primarily when:

(a) The hook uses `useState`
(b) The hook is shared across many components or has complex logic worth testing in isolation
(c) The hook uses `useEffect`
(d) Always — all hooks should be tested with `renderHook`

---

**MC-28.** The `wrapper` option in `renderHook` is used for:

(a) Wrapping the hook return value
(b) Providing Context providers that the hook depends on
(c) Adding error boundaries
(d) Wrapping the test in `act()`

---

**MC-29.** To mock `fetch` for a component test, which approach is recommended?

(a) Mock the global `fetch` directly
(b) Create an API layer module and mock that module
(c) Use a real network connection to a test server
(d) Skip testing network behavior

---

**MC-30.** A minimal mock for `fetch` that returns JSON data looks like:

(a) `vi.fn().mockReturnValue(data)`
(b) `vi.fn().mockResolvedValue({ json: () => Promise.resolve(data), ok: true })`
(c) `vi.fn().mockResolvedValue(data)`
(d) `vi.fn(() => data)`

---

**MC-31.** To test that a component shows "Error" when the API call fails, you would:

(a) Mock the API to throw a synchronous error
(b) Mock the API to return a rejected Promise, then use `findBy` or `waitFor` to find the error message
(c) Not mock anything and let the real API fail
(d) Use fake timers

---

**MC-32.** `expect(mockFn).toHaveBeenCalledWith('arg1', 'arg2')` checks:

(a) The mock was called with only those arguments and nothing else
(b) The mock was called at least once with those exact arguments
(c) The mock's return value matches those arguments
(d) The mock was called exactly once

---

**MC-33.** `expect(mockFn).toHaveBeenCalledTimes(0)` is equivalent to:

(a) `expect(mockFn).toHaveBeenCalled()`
(b) `expect(mockFn).not.toHaveBeenCalled()`
(c) `expect(mockFn).toHaveReturned()`
(d) `expect(mockFn).toBeUndefined()`

---

**MC-34.** `mockFn.mock.calls[0][1]` accesses:

(a) The first argument of the first call
(b) The second argument of the first call
(c) The first argument of the second call
(d) The return value of the first call

---

**MC-35.** `mockFn.mock.results[0].value` accesses:

(a) The first argument of the first call
(b) The return value of the first call
(c) The type of the first call result
(d) Whether the first call threw

---

**MC-36.** When testing a component with a `useEffect` that calls `fetch` on mount, the correct pattern is:

(a) Mock `fetch`, render the component, assert on the loading state, then use `findBy` to assert on the loaded state
(b) Mock `fetch`, wait 1 second with `setTimeout`, then assert
(c) Do not test `useEffect` behavior
(d) Call `useEffect` directly outside the component

---

**MC-37.** `vi.mock('./api', async (importOriginal) => { const actual = await importOriginal(); return { ...actual, fetchUsers: vi.fn() }; })` does what?

(a) Replaces the entire `./api` module with a mock
(b) Keeps all real exports from `./api` but replaces `fetchUsers` with a mock
(c) Throws an error because `importOriginal` is invalid
(d) Mocks only the default export

---

**MC-38.** `vi.mocked(fetchUsers)` returns:

(a) A new mock function
(b) The same `fetchUsers` reference but typed as a mock, enabling mock methods in TypeScript
(c) The original un-mocked function
(d) `undefined`

---

**MC-39.** A test uses `vi.useFakeTimers()` but forgets `vi.useRealTimers()` in cleanup. What happens?

(a) Nothing — fake timers reset automatically
(b) Subsequent tests may fail because `setTimeout`, `Date`, etc. are still faked
(c) The test runner crashes
(d) Only `Date` is affected

---

**MC-40.** To test a `setInterval` that fires every 200ms, and you want to verify it has fired 3 times:

(a) `vi.advanceTimersByTime(600)` and check the callback was called 3 times
(b) `vi.runAllTimers()` and check the callback was called 3 times
(c) Wait 600 real milliseconds
(d) `vi.advanceTimersByTime(200)` once

---

**MC-41.** `renderHook` is necessary because:

(a) Hooks cannot be imported in test files
(b) Hooks can only be called inside React components — `renderHook` provides a wrapper component
(c) Vitest does not support testing functions
(d) TypeScript requires hooks to be wrapped

---

**MC-42.** After `act(() => { result.current.increment(); })`, you read the updated count from:

(a) The `act` return value
(b) `result.current.count`
(c) `result.previous.count`
(d) A new `renderHook` call

---

**MC-43.** To test a hook that depends on `UserContext`, you provide it via:

(a) `renderHook(() => useUser(), { wrapper: ({ children }) => <UserContext.Provider value={mockUser}>{children}</UserContext.Provider> })`
(b) `vi.mock('UserContext')`
(c) Setting a global variable
(d) Passing it as a hook argument

---

**MC-44.** `vi.fn().mockReturnValueOnce('a').mockReturnValueOnce('b')` — what does the third call return?

(a) `'a'`
(b) `'b'`
(c) `undefined`
(d) Throws an error

---

**MC-45.** To verify a spy was called AND restore it after the test, you should:

(a) Call `mockClear()` in `afterEach`
(b) Call `mockReset()` in `afterEach`
(c) Call `mockRestore()` in `afterEach` or use `vi.restoreAllMocks()`
(d) Do nothing — spies auto-restore

---

**MC-46.** A component renders "No results" when the API returns an empty array. The test should:

(a) Mock the API to return `[]`, render the component, and use `findByText('No results')` or `waitFor` to assert
(b) Never mock the API
(c) Use fake timers to trigger the empty state
(d) Test only with real API data

---

**MC-47.** `vi.spyOn(console, 'warn').mockImplementation(() => {})` is commonly used to:

(a) Spy on user interactions
(b) Suppress expected console warnings during a test while verifying they were called
(c) Mock the DOM
(d) Replace `console.log` with `console.warn`

---

**MC-48.** The correct order for testing a component that fetches data is:

(a) Assert data → render → mock API
(b) Mock API → render → assert loading → await data → assert data
(c) Render → mock API → assert data
(d) Assert loading → render → mock API → assert data

---

---

## Answer Key

---

### Part A: True / False

| # | Answer | Explanation |
|---|---|---|
| TF-1 | **T** | `vi.fn()` creates an independent mock function. It records calls, arguments, and return values. |
| TF-2 | **T** | Without an implementation, `vi.fn()` returns `undefined` when called. |
| TF-3 | **T** | Passing a function to `vi.fn()` sets it as the default implementation. |
| TF-4 | **F** | `vi.spyOn` preserves the original implementation by default. It only tracks calls — it does not replace the method with an empty function. |
| TF-5 | **T** | `vi.spyOn` wraps the method: the original runs normally, but calls are tracked. You can override the implementation with `.mockImplementation()` if needed. |
| TF-6 | **T** | By default, `vi.spyOn` calls through to the original. The spy adds tracking without changing behavior. |
| TF-7 | **T** | `vi.mock('./module')` intercepts imports of that module and replaces them with mock implementations. |
| TF-8 | **F** | `vi.mock()` calls are hoisted to the top of the file, before imports. They do not execute in their written order. |
| TF-9 | **T** | Hoisting ensures the mock is in place when the module is first imported by any `import` statement. |
| TF-10 | **T** | Because hoisting moves the `vi.mock()` call above `const`/`let` declarations, those variables are in the temporal dead zone. This is the main limitation of hoisting. |
| TF-11 | **T** | `vi.hoisted()` declares variables that are placed above the hoisted `vi.mock()`, making them accessible inside factory functions. |
| TF-12 | **T** | Without a factory, `vi.mock()` auto-mocks: each exported function becomes `vi.fn()`, other values are preserved. |
| TF-13 | **T** | The factory function returns an object whose properties replace the module's exports. The shape should match what consumers expect. |
| TF-14 | **F** | `vi.mocked()` is purely a TypeScript type helper. It does not change runtime behavior. |
| TF-15 | **T** | `vi.mocked(fn)` casts `fn` to a mock type, enabling TypeScript to see `.mockReturnValue`, `.mock.calls`, etc. |
| TF-16 | **T** | `mockReturnValue` sets the persistent return value for all subsequent calls. |
| TF-17 | **T** | `mockReturnValueOnce` applies to only the next call. After that call, the mock reverts to its default. |
| TF-18 | **T** | `mockResolvedValue(data)` is syntactic sugar for `mockReturnValue(Promise.resolve(data))`. |
| TF-19 | **T** | `mockResolvedValueOnce` returns a resolved Promise for one call only. |
| TF-20 | **T** | `mockRejectedValue(error)` is sugar for `mockReturnValue(Promise.reject(error))`. |
| TF-21 | **T** | `mockImplementation` replaces the mock's body with the given function, allowing complex behavior. |
| TF-22 | **T** | `mock.calls` is a nested array: `mock.calls[0]` is the arguments array from the first call. |
| TF-23 | **T** | `mock.results` tracks each call's outcome: `{ type: 'return', value: ... }` or `{ type: 'throw', value: ... }`. |
| TF-24 | **T** | `toHaveBeenCalledWith` checks that at least one call matched the given arguments. |
| TF-25 | **T** | `toHaveBeenCalledTimes(3)` asserts the mock was called exactly 3 times. |
| TF-26 | **T** | `mockClear` clears `mock.calls` and `mock.results` but leaves `mockImplementation` and `mockReturnValue` intact. |
| TF-27 | **T** | `mockReset` clears history AND removes custom implementation. The mock returns `undefined` again. |
| TF-28 | **T** | `mockRestore` is designed for spies: it restores the original unwrapped method. On `vi.fn()` mocks, it behaves like `mockReset`. |
| TF-29 | **T** | `vi.fn()` has no original implementation to restore, so `mockRestore` effectively equals `mockReset`. |
| TF-30 | **T** | `vi.restoreAllMocks()` restores every mock and spy, making it a comprehensive cleanup tool. |
| TF-31 | **T** | Calling `vi.restoreAllMocks()` in `afterEach` ensures no mock state leaks between tests. |
| TF-32 | **T** | ES module default exports are the `default` property. The factory must return `{ default: mockFn }`. |
| TF-33 | **T** | `importOriginal` gives you the real module so you can spread it and override only what you need. |
| TF-34 | **T** | `vi.useFakeTimers()` takes control of `setTimeout`, `setInterval`, `Date`, `performance.now`, and related APIs. |
| TF-35 | **T** | With fake timers, timer callbacks only execute when you explicitly advance time. |
| TF-36 | **T** | `advanceTimersByTime(1000)` moves the clock forward 1000ms and executes all timers scheduled within that window. |
| TF-37 | **T** | `runAllTimers()` executes all pending timers and any new timers they create, recursively. |
| TF-38 | **T** | `vi.useRealTimers()` undoes `vi.useFakeTimers()`, restoring real `setTimeout`, `setInterval`, `Date`, etc. |
| TF-39 | **T** | Always clean up fake timers to prevent leaking timer state into other tests. |
| TF-40 | **T** | `vi.setSystemTime` controls what `Date.now()` and `new Date()` return when fake timers are active. |
| TF-41 | **T** | Timer-based logic (debounce, throttle, intervals, auto-save) is the primary use case for fake timers. |
| TF-42 | **F** | Data fetching is Promise-based, not timer-based. Fake timers do not help with `fetch`. Use `findBy`/`waitFor` instead. |
| TF-43 | **T** | For Promise-based async behavior, `findBy` and `waitFor` are the correct tools. Fake timers are for timer-based behavior. |
| TF-44 | **T** | `renderHook` creates a minimal wrapper component that calls the hook, allowing you to test it in isolation. |
| TF-45 | **T** | `result.current` holds the current return value of the hook. It updates after state changes. |
| TF-46 | **F** | Hooks cannot be called outside React components. Doing so violates the Rules of Hooks. `renderHook` provides the component wrapper. |
| TF-47 | **T** | Testing through components is more realistic. `renderHook` is for shared or complex hooks that justify isolated testing. |
| TF-48 | **T** | The `wrapper` option in `renderHook` works the same as in `render` — it wraps the test component in providers. |
| TF-49 | **T** | If a hook reads from Context, you must provide that Context via the `wrapper` option. |
| TF-50 | **T** | State updates from hook methods must be wrapped in `act()` to ensure React processes the update before assertions. |
| TF-51 | **T** | `waitFor` polls the callback repeatedly until it passes or the timeout expires. |
| TF-52 | **T** | The default `waitFor` timeout is 1000ms. You can customize it via the `timeout` option. |
| TF-53 | **F** | `waitFor` should only be used for assertions that depend on async behavior. Using it everywhere is wasteful and masks synchronous failures. |
| TF-54 | **T** | `waitForElementToBeRemoved` expects the element to be present initially. If it is already gone, it throws immediately. |
| TF-55 | **T** | This is the canonical use case: render component → loading spinner appears → `waitForElementToBeRemoved` → assert final content. |
| TF-56 | **T** | `globalThis.fetch = vi.fn(...)` replaces the global `fetch` with a mock for the test. |
| TF-57 | **T** | A real `fetch` response requires calling `.json()` which returns a Promise. Your mock must replicate this: `{ json: () => Promise.resolve(data), ok: true }`. |
| TF-58 | **T** | An API layer (e.g., `api.ts` with `fetchUsers()`) provides a seam for mocking. You mock the API module, not the transport. |
| TF-59 | **T** | Without a factory, `vi.mock()` auto-mocks all exported functions with `vi.fn()`. |
| TF-60 | **T** | The mock provides `response.json()` as a function returning `Promise.resolve([])`, so the component receives `[]`. |
| TF-61 | **F** | Each test file runs in isolation. `vi.mock()` in one file does not affect others. |
| TF-62 | **T** | Vitest isolates test files via worker threads. Module mocks are scoped to their file. |
| TF-63 | **T** | `mockReturnValueOnce` can be chained: each call adds another value to the queue. |
| TF-64 | **T** | The once-values are consumed in order. After they are exhausted, the persistent `mockReturnValue(0)` kicks in. |
| TF-65 | **T** | This pattern suppresses the output (empty implementation) while still tracking calls via the spy. |
| TF-66 | **T** | Without restoration, the spy persists. Use `vi.restoreAllMocks()` in `afterEach` to prevent leaks. |
| TF-67 | **T** | `runOnlyPendingTimers` executes currently queued timers but does not recursively run timers those callbacks create. |
| TF-68 | **T** | A 200ms interval fires at 200ms and 400ms within a 500ms window (not at 600ms, since the window is 500ms). Wait — the question says 600ms. At 200ms, 400ms, and 600ms the interval fires, but `advanceTimersByTime(500)` only covers up to 500ms, so it fires at 200ms and 400ms = twice. |
| TF-69 | **F** | `renderHook` supports hooks that use any React hook, including `useEffect`, `useReducer`, `useContext`, etc. |
| TF-70 | **T** | `result` is a ref-like container. After a state update, `result.current` reflects the new value. |
| TF-71 | **T** | `importOriginal` gives you the real module exports. Spread them and override only what you need. |
| TF-72 | **T** | Mock the API → render the component → use `findBy` to wait for the data to render. This is the standard async component test pattern. |

---

### Part B: Short Answer

**SA-1.**
`vi.fn()` creates a standalone mock function that starts with no implementation. Use it when you need a callback or handler to pass into a component: `const onClick = vi.fn()`.

`vi.spyOn(obj, 'method')` wraps an existing method on an object, tracking calls while preserving the original behavior. Use it when you want to verify a method was called without replacing it: `vi.spyOn(console, 'error')`.

`vi.mock('./module')` replaces an entire module's exports with mocks. Use it when a component imports a dependency you want to control: `vi.mock('./api')` to replace the real API layer with mock functions.

---

**SA-2.**
`mockClear()` resets call tracking (`.mock.calls`, `.mock.results`) but preserves any custom implementation or return value. Use it between tests when you want to reset the call count but keep the mock's behavior.

`mockReset()` resets call tracking AND removes the custom implementation. The mock reverts to returning `undefined`. Use it when you want a completely blank mock for the next test.

`mockRestore()` does everything `mockReset` does AND also restores the original function for spies created with `vi.spyOn`. Use it when you want to undo the spy entirely. For `vi.fn()` mocks (which have no original), it behaves like `mockReset`.

---

**SA-3.**
`vi.mock()` is hoisted so the mock is in place before any `import` statement at the top of the file runs. Without hoisting, the real module would be imported first, and the mock would have no effect since modules are cached after first import.

The limitation: because the factory function runs before any `const`/`let` declarations in the file, you cannot reference local variables inside the factory. They are in the temporal dead zone at the time the factory executes. To work around this, use `vi.hoisted()` to declare variables that are placed above the hoisted mock.

---

**SA-4.**
`vi.hoisted()` lets you declare values that exist before hoisted `vi.mock()` calls, making them accessible inside factory functions:

```ts
const { mockFetchUsers } = vi.hoisted(() => ({
  mockFetchUsers: vi.fn(),
}));

vi.mock('./api', () => ({
  fetchUsers: mockFetchUsers,
}));

// Now in your tests:
mockFetchUsers.mockResolvedValue([{ id: 1, name: 'Alice' }]);
```

Without `vi.hoisted`, referencing `mockFetchUsers` inside `vi.mock`'s factory would fail because the `const` declaration has not executed yet when the hoisted factory runs.

---

**SA-5.**
```tsx
import { render, screen } from '@testing-library/react';
import UserList from './UserList';
import { fetchUsers } from './api';

vi.mock('./api');

it('shows loading then users', async () => {
  vi.mocked(fetchUsers).mockResolvedValue([
    { id: 1, name: 'Alice' },
    { id: 2, name: 'Bob' },
  ]);

  render(<UserList />);

  // Loading state
  expect(screen.getByText(/loading/i)).toBeInTheDocument();

  // Wait for data to render
  expect(await screen.findByText('Alice')).toBeInTheDocument();
  expect(screen.getByText('Bob')).toBeInTheDocument();

  // Loading should be gone
  expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();
});
```

---

**SA-6.**
`mockResolvedValue(val)` makes the mock always return `Promise.resolve(val)`. `mockResolvedValueOnce(val)` makes it return `Promise.resolve(val)` for the next call only.

```ts
const mockFetch = vi.fn()
  .mockResolvedValueOnce('first')
  .mockResolvedValueOnce('second')
  .mockResolvedValue('default');

await mockFetch(); // 'first'
await mockFetch(); // 'second'
await mockFetch(); // 'default'
await mockFetch(); // 'default'
```

---

**SA-7.**
```ts
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { debounce } from './debounce';

describe('debounce', () => {
  beforeEach(() => {
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it('calls the callback once after 500ms of inactivity', () => {
    const callback = vi.fn();
    const debounced = debounce(callback, 500);

    debounced();
    debounced();
    debounced();

    // Not called yet — timer keeps resetting
    expect(callback).not.toHaveBeenCalled();

    // Advance past the 500ms window
    vi.advanceTimersByTime(500);

    expect(callback).toHaveBeenCalledTimes(1);
  });
});
```

---

**SA-8.**
`vi.advanceTimersByTime(n)` moves the fake clock forward by exactly `n` milliseconds and fires all timers that were scheduled to fire within that window. Use it when you need precise control over time progression.

`vi.runAllTimers()` immediately executes all pending timers, and recursively executes any new timers those callbacks create, until there are no timers left. Use it when you want to flush all timer-based behavior at once. Be careful with infinite intervals — this can loop forever.

`vi.runOnlyPendingTimers()` executes only the timers that are currently in the queue. If a timer callback schedules a new timer, that new timer is not executed in the same call. Use it when you want to advance one "tick" of a recursive timer chain without running everything.

---

**SA-9.**
`vi.mocked(fn)` is a TypeScript type helper. It takes a function and returns the same reference, but typed as a Vitest mock function (`Mock<...>`). This gives you access to mock properties and methods like `.mockReturnValue()`, `.mockResolvedValue()`, `.mock.calls`, etc. without TypeScript errors.

It is necessary because when you `vi.mock('./api')`, the imported `fetchUsers` is typed as the original function signature. TypeScript does not know it has been replaced with a mock at runtime. `vi.mocked(fetchUsers)` tells TypeScript to treat it as a mock, enabling you to call `vi.mocked(fetchUsers).mockResolvedValue(data)` without type errors.

---

**SA-10.**
```tsx
import { renderHook, act } from '@testing-library/react';
import { useCounter } from './useCounter';

describe('useCounter', () => {
  it('increments the count', () => {
    const { result } = renderHook(() => useCounter());

    expect(result.current.count).toBe(0);

    act(() => {
      result.current.increment();
    });

    expect(result.current.count).toBe(1);
  });

  it('decrements the count', () => {
    const { result } = renderHook(() => useCounter());

    act(() => {
      result.current.increment();
      result.current.increment();
      result.current.decrement();
    });

    expect(result.current.count).toBe(1);
  });
});
```

---

**SA-11.**
Testing hooks through the components that use them is more realistic — it tests the hook in the context where it actually runs, with real DOM interactions and rendering. This approach also naturally avoids testing implementation details: you test what the user sees, not the hook's internal return value. Use `renderHook` when the hook is used by many components (so testing it once in isolation is more efficient than testing through every consumer) or when the hook has complex internal logic (like state machines or effect chains) that is difficult to exercise fully through a single component.

---

**SA-12.**
```ts
vi.mock('./utils', async (importOriginal) => {
  const actual = await importOriginal<typeof import('./utils')>();
  return {
    ...actual,
    formatDate: vi.fn(() => '2025-01-01'),
  };
});
```

This keeps all real exports from `./utils` intact (e.g., `parseDate`, `capitalize`) but replaces `formatDate` with a mock that always returns `'2025-01-01'`. Tests using other `./utils` functions get the real implementations.

---

**SA-13.**
If `fetch` is not restored, subsequent tests in the same file (or even other files, depending on isolation settings) will use the mocked `fetch` instead of the real one. This can cause unrelated tests to fail or silently receive mock data, producing false positives.

Fix: Either use `vi.spyOn(globalThis, 'fetch')` and restore with `vi.restoreAllMocks()` in `afterEach`, or if you assign `globalThis.fetch = vi.fn()`, save the original and restore it:

```ts
afterEach(() => {
  vi.restoreAllMocks();
});
```

Or better yet, mock the API layer module instead of `fetch` directly, which is naturally scoped to the test file.

---

**SA-14.**
To provide a mocked Context value, use the `wrapper` option in `render` or `renderHook`:

```tsx
import { UserContext } from './UserContext';

const mockUser = { id: 1, name: 'Alice', role: 'admin' };

it('uses the context value', () => {
  const { result } = renderHook(() => useUser(), {
    wrapper: ({ children }) => (
      <UserContext.Provider value={mockUser}>
        {children}
      </UserContext.Provider>
    ),
  });

  expect(result.current.name).toBe('Alice');
});
```

You are not mocking the Context module itself — you are providing a real Context.Provider with a controlled value. This is cleaner and more realistic than mocking the module.

---

**SA-15.**
Fake timers control `setTimeout`, `setInterval`, and `Date`. Use them when the behavior you are testing depends on timers — debounce, throttle, auto-save, countdown timers, `setInterval`-based polling.

`findBy`/`waitFor` are for Promise-based async behavior — data fetching, state updates that trigger re-renders, or any behavior that resolves via microtasks and Promises. They poll the DOM at intervals until the condition is met.

The key distinction: fake timers give you precise control over the passage of time. `findBy`/`waitFor` give you patience to wait for async work to complete. Data fetching is Promise-based, not timer-based, so use `findBy`/`waitFor`. Debounce is timer-based, so use fake timers.

---

**SA-16.**
The problem is `vi.mock()` hoisting. The `vi.mock('./api', () => ({ ... }))` factory is hoisted to the top of the file, before the `const mockFetch = vi.fn()` declaration executes. When the factory runs, `mockFetch` is in the temporal dead zone and the reference will fail.

Fix: Use `vi.hoisted()`:

```ts
const { mockFetch } = vi.hoisted(() => ({
  mockFetch: vi.fn(),
}));

vi.mock('./api', () => ({
  fetchUsers: mockFetch,
}));
```

Now `mockFetch` is declared and initialized before the hoisted `vi.mock()` factory runs.

---

### Part C: Multiple Choice

| # | Answer | Explanation |
|---|---|---|
| MC-1 | **(b)** | `vi.fn()` creates a standalone mock function. It does not wrap anything — it starts empty and tracks calls. |
| MC-2 | **(b)** | `vi.spyOn` wraps the method, tracking calls while preserving the original behavior. |
| MC-3 | **(c)** | Without a factory, `vi.mock` auto-mocks: all exported functions become `vi.fn()`. |
| MC-4 | **(a)** | Hoisting ensures the mock is registered before any `import` statement runs, so the mocked version is loaded. |
| MC-5 | **(b)** | Variables declared after `vi.mock()` in source code are not yet initialized when the hoisted factory runs (temporal dead zone). |
| MC-6 | **(b)** | `vi.hoisted()` declares variables that exist before hoisted mocks, solving the temporal dead zone problem. |
| MC-7 | **(b)** | `mockReturnValue` sets a persistent return value for all calls. |
| MC-8 | **(b)** | `mockReturnValueOnce` applies to only the next call. |
| MC-9 | **(d)** | Both (b) and (c) are equivalent: `mockResolvedValue(data)` is sugar for returning `Promise.resolve(data)`. |
| MC-10 | **(a)** | `mockClear` clears call history (`calls` and `results`) but preserves the implementation. |
| MC-11 | **(b)** | `mockReset` clears history and removes the custom implementation. |
| MC-12 | **(c)** | `mockRestore` additionally restores the original unwrapped method, which only matters for `vi.spyOn` mocks. |
| MC-13 | **(c)** | `afterEach` is the right place for cleanup. Restoring after each test prevents mock leaks. |
| MC-14 | **(b)** | ES modules expose the default export as a `default` property. The factory must return `{ default: mockFn }`. |
| MC-15 | **(b)** | `importOriginal` imports the real module so you can spread it and override only selected exports. |
| MC-16 | **(b)** | `vi.useFakeTimers()` replaces `setTimeout`, `setInterval`, `Date`, `performance.now`, and related APIs. |
| MC-17 | **(c)** | With fake timers, callbacks only fire when you manually advance time. |
| MC-18 | **(b)** | `advanceTimersByTime` moves the clock forward and fires all timers within that window. |
| MC-19 | **(b)** | `runAllTimers` flushes all pending timers and recursively runs newly created ones. |
| MC-20 | **(b)** | `runOnlyPendingTimers` runs only currently queued timers, not recursively created ones. |
| MC-21 | **(b)** | Timer-based logic (debounce, throttle, intervals) is the use case for fake timers. |
| MC-22 | **(c)** | Promise-based async (data fetching, state transitions) is handled with `findBy`/`waitFor`. |
| MC-23 | **(b)** | `vi.setSystemTime` sets the fake clock to a specific date/time when fake timers are active. |
| MC-24 | **(b)** | `renderHook` is imported from `@testing-library/react` (the hooks testing was merged into RTL). |
| MC-25 | **(b)** | `renderHook` returns `{ result }` where `result.current` holds the hook's return value. |
| MC-26 | **(b)** | State updates from hooks must be wrapped in `act()` to ensure React processes them before assertions. |
| MC-27 | **(b)** | KCD says use `renderHook` for shared or complex hooks. Prefer testing through components otherwise. |
| MC-28 | **(b)** | The `wrapper` option provides Context providers that the hook needs to function. |
| MC-29 | **(b)** | An API layer module is a cleaner mock boundary than the global `fetch` function. |
| MC-30 | **(b)** | A `fetch` mock must return a response-like object with `json()` returning a Promise and an `ok` property. |
| MC-31 | **(b)** | Mock the API to reject, render the component, then use `findBy`/`waitFor` to find the error message. |
| MC-32 | **(b)** | `toHaveBeenCalledWith` checks that at least one call matched those arguments. |
| MC-33 | **(b)** | `toHaveBeenCalledTimes(0)` and `.not.toHaveBeenCalled()` are logically equivalent. |
| MC-34 | **(b)** | `mock.calls[0]` is the first call's arguments array. Index `[1]` is the second argument. |
| MC-35 | **(b)** | `mock.results[0].value` is the return value (or thrown value) of the first call. |
| MC-36 | **(a)** | Mock → render → assert loading → `findBy` for loaded data. This is the standard async component test flow. |
| MC-37 | **(b)** | `importOriginal` gives the real module. Spreading it and overriding `fetchUsers` keeps everything else real. |
| MC-38 | **(b)** | `vi.mocked()` is a type cast, not a runtime operation. It tells TypeScript to treat the value as a mock. |
| MC-39 | **(b)** | Fake timers persist across tests if not cleaned up. Subsequent tests get faked `setTimeout`, `Date`, etc. |
| MC-40 | **(a)** | `advanceTimersByTime(600)` fires the 200ms interval at 200ms, 400ms, and 600ms = 3 times. |
| MC-41 | **(b)** | React hooks can only be called inside components. `renderHook` provides the wrapper component. |
| MC-42 | **(b)** | `result.current` is updated after `act()` completes. Read the new value from `result.current.count`. |
| MC-43 | **(a)** | Provide the Context via the `wrapper` option in `renderHook`. |
| MC-44 | **(c)** | Both `mockReturnValueOnce` values are consumed. No persistent `mockReturnValue` was set, so the default is `undefined`. |
| MC-45 | **(c)** | `mockRestore()` restores the original method (for spies). `vi.restoreAllMocks()` in `afterEach` handles all of them. |
| MC-46 | **(a)** | Mock the API to return `[]`, render, then `findByText`/`waitFor` for the "No results" message. |
| MC-47 | **(b)** | This pattern suppresses expected console noise while letting you verify the warning was triggered. |
| MC-48 | **(b)** | The correct flow: set up mocks first → render component → assert initial (loading) state → await data → assert final state. |