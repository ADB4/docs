# Week 8 Quiz: Component Patterns and Architecture

**Scope:** Compound components, render props, HOCs (historical context), controlled vs. uncontrolled components, folder structure conventions, React Server Components (conceptual overview), composition, "Thinking in React."

**Scoring:** Wrong answers on T/F and MC are subtracted from right answers. Do not guess.

---

## Part A: True / False (32 Questions)

---

**TF-1.** A compound component is a set of related components that share implicit state and are composed together by the consumer.

**TF-2.** Compound components typically share state using Context, so child components can access shared values without explicit prop passing.

**TF-3.** The compound component pattern forces the consumer to use a specific fixed layout for children.

**TF-4.** The compound component pattern gives the consumer flexibility to compose children in any order while maintaining shared behavior.

**TF-5.** Render props is a pattern where a component receives a function as a prop (or as `children`) and calls it to determine what to render.

**TF-6.** The render props pattern allows a component to share data with the rendered content by passing values to the render function.

**TF-7.** Render props have been completely replaced by hooks and should never be used.

**TF-8.** While custom hooks are generally preferred for logic reuse, render props are still valid when you need to share data that influences what JSX is rendered.

**TF-9.** Higher-order components (HOCs) are the recommended way to share logic between components in 2026.

**TF-10.** HOCs are a historical pattern that wraps a component to inject additional props. Custom hooks now serve the same purpose more simply.

**TF-11.** HOCs can cause "wrapper hell" (deeply nested wrappers) and prop name collisions.

**TF-12.** A controlled component has its value driven by React state, with changes handled via event handlers that update that state.

**TF-13.** An uncontrolled component manages its own internal DOM state, and you read values using refs.

**TF-14.** For a controlled input, you use the `value` prop and an `onChange` handler.

**TF-15.** For an uncontrolled input, you use the `defaultValue` prop and read the value via a ref.

**TF-16.** Controlled components provide more programmatic control (validation, conditional formatting, disabling submit) than uncontrolled components.

**TF-17.** A component should never switch between controlled and uncontrolled behavior during its lifetime.

**TF-18.** React Server Components run on the server, produce HTML, and their JavaScript code is included in the client bundle.

**TF-19.** React Server Components run on the server and their JavaScript is NOT sent to the client, reducing bundle size.

**TF-20.** React Server Components can use `useState`, `useEffect`, and other client-side hooks.

**TF-21.** React Server Components can directly access server-side resources like databases, file systems, and environment variables.

**TF-22.** Client components and Server Components can be composed together — a Server Component can render client components as children.

**TF-23.** "Thinking in React" recommends building a static version of the UI first, with no state or interactivity.

**TF-24.** After building the static version, "Thinking in React" says to identify the minimal set of state needed and determine where it should live.

**TF-25.** Every piece of data in an application should be stored as state.

**TF-26.** Props that are passed unchanged, values computed from state/props, and values that remain constant over time should NOT be state.

**TF-27.** Composition (passing components as `children` or props) can solve prop drilling without Context.

**TF-28.** Prop drilling is always a bug that must be fixed with Context.

**TF-29.** Co-locating component files, styles, and tests in the same directory is a common and recommended folder structure convention.

**TF-30.** Organizing components by technical layer (all components in `/components`, all hooks in `/hooks`, all styles in `/styles`) is always preferred over co-location.

**TF-31.** `forwardRef` allows a parent to pass a ref to a child component's underlying DOM element.

**TF-32.** Extracting a custom hook is the preferred way to share stateful logic between components, over HOCs or render props.

---

## Part B: Short Answer (16 Questions)

---

**SA-1.** Explain the compound component pattern. What problem does it solve, and how does it typically use Context?

---

**SA-2.** Write a minimal compound component `<Accordion>` with `<AccordionItem>` and `<AccordionPanel>` sub-components. Show the Context that shares the open item state. (Pseudocode-level structure is fine, but show the Context usage.)

---

**SA-3.** Explain the render props pattern with a concrete example. When is it still useful compared to custom hooks?

---

**SA-4.** Why are higher-order components considered a historical pattern? What problems do they have that custom hooks solve?

---

**SA-5.** Explain the difference between controlled and uncontrolled components. Give an example of each for an `<input>` element.

---

**SA-6.** When would you choose an uncontrolled component over a controlled one?

---

**SA-7.** What are React Server Components? What can they do that client components cannot, and what can they NOT do?

---

**SA-8.** Explain the "Thinking in React" process. List the five steps in order.

---

**SA-9.** What is "composition" in React, and how does it solve prop drilling? Give an example.

---

**SA-10.** A component passes `theme`, `user`, and `locale` through six levels of components. Only the leaf component needs them. Propose two different solutions and explain the tradeoffs of each.

---

**SA-11.** Explain the difference between organizing by feature (co-location) and organizing by technical layer. When is each appropriate?

---

**SA-12.** What does `forwardRef` do? When do you need it?

---

**SA-13.** A developer creates an HOC `withAuth` that wraps a component and injects an `isAuthenticated` prop. Rewrite this as a custom hook `useAuth` that returns `{ isAuthenticated: boolean }`.

---

**SA-14.** Explain what it means for a component to have "a single responsibility." Give an example of a component that violates this principle and how you would decompose it.

---

**SA-15.** A team debates whether to use Context or composition to avoid passing an `onClick` handler through three layers. Argue for composition as the first approach.

---

**SA-16.** You are refactoring Project 2 (the Task Manager) during Week 8. The `TaskList` component handles rendering, filtering, sorting, and keyboard shortcuts. How would you decompose it, and what patterns from this week would you apply?

---

## Part C: Multiple Choice (16 Questions)

---

**MC-1.** What is a compound component?

(a) A monolithic component that handles all functionality internally
(b) A set of related components that share implicit state via Context and are composed by the consumer
(c) A component that renders other components from a config object
(d) Two components that render each other recursively

---

**MC-2.** What does the render props pattern allow?

(a) Passing CSS class names as props
(b) A component to share data with rendered content by calling a function prop that returns JSX
(c) Rendering components on the server
(d) Replacing `useState` with a render function

---

**MC-3.** Why are custom hooks preferred over HOCs for sharing logic?

(a) HOCs are faster at runtime
(b) Custom hooks avoid wrapper nesting, prop collisions, and are simpler to compose
(c) HOCs don't work with TypeScript
(d) Custom hooks run on the server

---

**MC-4.** What makes a form input "controlled"?

(a) It uses `defaultValue` and a ref
(b) Its `value` is driven by React state and changes are handled by an `onChange` handler
(c) It cannot be modified by the user
(d) It has a `disabled` attribute

---

**MC-5.** What makes a form input "uncontrolled"?

(a) Its value is managed by React state
(b) It uses `defaultValue` for the initial value and the DOM manages its state; values are read via refs
(c) It cannot accept user input
(d) It uses `onChange` to update state

---

**MC-6.** When is a controlled component preferred?

(a) When you don't need validation
(b) When you need programmatic control over the value: validation, conditional formatting, computed values, or disabling submit until the form is valid
(c) When performance is the top priority
(d) When using Server Components

---

**MC-7.** What can React Server Components do that client components cannot?

(a) Use hooks like `useState` and `useEffect`
(b) Run on the server, access server resources directly, and avoid adding JavaScript to the client bundle
(c) Handle user interactions like clicks
(d) Use browser APIs

---

**MC-8.** What can client components do that Server Components cannot?

(a) Render HTML
(b) Use hooks (`useState`, `useEffect`) and handle user interactions
(c) Accept props
(d) Be imported by other components

---

**MC-9.** What is the first step in "Thinking in React"?

(a) Add state and interactivity
(b) Break the UI into a component hierarchy
(c) Write tests
(d) Choose a state management library

---

**MC-10.** What is "composition" in React?

(a) Inheriting from a base component
(b) Passing components as `children` or props to other components for flexible nesting
(c) Combining reducers
(d) Merging multiple Contexts

---

**MC-11.** When is composition a better solution than Context for prop drilling?

(a) Never
(b) When intermediate components don't need the data — pass the consuming component directly as `children`
(c) When there are more than 10 props
(d) Only in class components

---

**MC-12.** A component passes `user` through `App > Layout > Sidebar > UserMenu`. Only `UserMenu` needs `user`. What is the simplest fix?

(a) Use Context
(b) Pass `<UserMenu user={user} />` as `children` through `Layout` and `Sidebar`, so intermediaries don't need the `user` prop
(c) Use Redux
(d) Use `forwardRef`

---

**MC-13.** What does `forwardRef` enable?

(a) Forwarding state to child components
(b) Passing a ref from a parent through a component to its underlying DOM element
(c) Forwarding Context values
(d) Forwarding event handlers

---

**MC-14.** Which folder structure approach co-locates related files?

(a) All components in `/components`, all hooks in `/hooks`, all styles in `/styles`
(b) Each feature in its own directory with its component, hook, styles, and tests together
(c) All files in the root directory
(d) Separate repositories for each component

---

**MC-15.** A component handles data fetching, rendering a list, managing pagination, and sorting. What principle does it violate?

(a) Controlled components
(b) Single responsibility — it should be decomposed into focused components and hooks
(c) Render props
(d) Server Components

---

**MC-16.** A developer wants to share `isAuthenticated` logic between `NavBar` and `SettingsPage`. What is the recommended approach?

(a) Create an HOC `withAuth`
(b) Create a custom hook `useAuth` that both components call
(c) Duplicate the logic in both components
(d) Use `forwardRef`

---

---

## Answer Key

### Part A: True / False

| # | Answer | Explanation |
|---|---|---|
| TF-1 | **T** | Compound components are composed together and share implicit state. |
| TF-2 | **T** | Context is the standard mechanism for sharing state among compound component parts. |
| TF-3 | **F** | Compound components give the consumer flexibility in how children are composed. |
| TF-4 | **T** | The consumer controls composition; the compound component provides shared state. |
| TF-5 | **T** | A function prop that returns JSX is the core of render props. |
| TF-6 | **T** | The component passes data to the render function: `render={(data) => <div>{data}</div>}`. |
| TF-7 | **F** | Render props are still valid in some cases, though hooks are generally preferred for logic reuse. |
| TF-8 | **T** | Render props remain useful when the shared data directly determines what gets rendered. |
| TF-9 | **F** | HOCs are historical. Custom hooks are preferred in 2026. |
| TF-10 | **T** | HOCs wrap components and inject props; custom hooks are simpler and more composable. |
| TF-11 | **T** | These are the two main practical problems with HOCs. |
| TF-12 | **T** | `value` + `onChange` = controlled. |
| TF-13 | **T** | `defaultValue` + ref = uncontrolled. |
| TF-14 | **T** | `value` and `onChange` are the controlled input props. |
| TF-15 | **T** | `defaultValue` sets the initial value; the ref reads the current value. |
| TF-16 | **T** | Controlled gives React full control over the value for validation, formatting, etc. |
| TF-17 | **T** | Switching between controlled/uncontrolled causes React warnings and unpredictable behavior. |
| TF-18 | **F** | RSC JavaScript is NOT sent to the client. |
| TF-19 | **T** | RSC produce HTML server-side; their JS stays on the server. |
| TF-20 | **F** | RSC cannot use client-side hooks. They have no client-side lifecycle. |
| TF-21 | **T** | RSC run on the server and can directly access databases, file systems, etc. |
| TF-22 | **T** | RSC and client components compose freely. |
| TF-23 | **T** | Build static version first, then add state. |
| TF-24 | **T** | Identify minimal state, then determine where it lives. |
| TF-25 | **F** | Derived values, props, and constants should NOT be state. |
| TF-26 | **T** | Only independent, changing data that can't be derived should be state. |
| TF-27 | **T** | Composition passes consuming components directly, skipping intermediaries. |
| TF-28 | **F** | Prop drilling is not always a bug. Composition and direct props are often clearer than Context. |
| TF-29 | **T** | Co-location keeps related files together for maintainability. |
| TF-30 | **F** | Layer-based organization can scatter related files across directories. Co-location is often preferred for feature-oriented projects. |
| TF-31 | **T** | `forwardRef` passes a ref through to a child's DOM element. |
| TF-32 | **T** | Custom hooks are the preferred mechanism for sharing stateful logic. |

### Part B: Short Answer

**SA-1.** The compound component pattern creates a family of related components (like `<Select>`, `<Option>`) that share implicit state via Context. It solves the problem of related components needing to coordinate without the consumer manually passing state between them. The parent component provides a Context Provider; child components consume the Context to access shared state and dispatch actions.

**SA-2.**
```tsx
const AccordionContext = createContext<{ openIndex: number; setOpenIndex: (i: number) => void }>(...);

function Accordion({ children }: { children: React.ReactNode }) {
  const [openIndex, setOpenIndex] = useState(0);
  return <AccordionContext.Provider value={{ openIndex, setOpenIndex }}>{children}</AccordionContext.Provider>;
}

function AccordionItem({ index, label, children }: { index: number; label: string; children: React.ReactNode }) {
  const { openIndex, setOpenIndex } = useContext(AccordionContext);
  return (
    <div>
      <button onClick={() => setOpenIndex(index)}>{label}</button>
      {openIndex === index && <div>{children}</div>}
    </div>
  );
}
// Usage: <Accordion><AccordionItem index={0} label="Section 1">Content</AccordionItem>...</Accordion>
```

**SA-3.** Render props pass data from a component to a function that decides what to render:
```tsx
<MouseTracker render={({ x, y }) => <p>Mouse: {x}, {y}</p>} />
```
Still useful when the shared data directly controls what JSX is produced and you want the consumer to decide the rendering. For pure logic reuse (no rendering decisions), hooks are simpler.

**SA-4.** HOCs wrap components in factory functions like `const Enhanced = withAuth(MyComponent)`. Problems: wrapper nesting ("wrapper hell"), prop name collisions between multiple HOCs, difficulty tracing data flow, poor TypeScript ergonomics. Custom hooks provide the same logic sharing without wrapping: `const { isAuthenticated } = useAuth()`.

**SA-5.** **Controlled:** `<input value={name} onChange={e => setName(e.target.value)} />` — React state is the source of truth. **Uncontrolled:** `<input defaultValue="hello" ref={inputRef} />` — the DOM is the source of truth; read with `inputRef.current.value`.

**SA-6.** Use uncontrolled when you only need the value on submit (not on every keystroke), when integrating with non-React code, or for file inputs (`<input type="file" />` which is always uncontrolled in React).

**SA-7.** RSC run on the server. They CAN: access server resources (DB, filesystem, env vars), produce HTML without adding JS to the client bundle, compose with client components. They CANNOT: use hooks (`useState`, `useEffect`), handle user interactions, use browser APIs.

**SA-8.** (1) Break the UI into a component hierarchy. (2) Build a static version with no state. (3) Find the minimal but complete set of state. (4) Identify where state should live. (5) Add inverse data flow (callbacks from children to parents).

**SA-9.** Composition means passing components as `children` or props to avoid threading data through intermediate layers. Example: instead of passing `user` through `Layout > Sidebar > UserMenu`, pass `<UserMenu user={user} />` as children of `Sidebar`. `Sidebar` renders `{children}` without knowing about `user`.

**SA-10.** (1) **Composition:** Pass the leaf component as `children` through the intermediate layers. Tradeoff: simple, explicit, but requires restructuring the component tree. (2) **Context:** Create a `ThemeContext`, `UserContext`, `LocaleContext`. Tradeoff: more flexible, works at any depth, but adds re-render overhead when values change and can be overused.

**SA-11.** **Co-location (by feature):** Each feature directory contains its component, hook, test, and styles. Good for feature-oriented work; related files are together. **By layer:** All components in one folder, all hooks in another. Simpler for small projects but scatters related code as the project grows. Co-location is generally preferred for medium-to-large projects.

**SA-12.** `forwardRef` wraps a component so that a `ref` prop from the parent is forwarded to a specific DOM element inside the child. You need it when a parent needs direct DOM access to a child's element (e.g., focusing an input inside a custom component).

**SA-13.**
```ts
// HOC (old pattern)
function withAuth(Component) { return (props) => { const isAuthenticated = checkAuth(); return <Component {...props} isAuthenticated={isAuthenticated} />; }; }

// Custom hook (preferred)
function useAuth(): { isAuthenticated: boolean } {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  useEffect(() => { /* check auth status */ }, []);
  return { isAuthenticated };
}
// Usage: const { isAuthenticated } = useAuth();
```

**SA-14.** Single responsibility means each component does one thing well. Violation: a `Dashboard` component that fetches data, renders charts, manages filters, and handles CSV export. Decompose into: `DashboardPage` (layout), `useDashboardData` (hook for fetching), `ChartPanel` (rendering), `FilterBar` (filter UI), `ExportButton` (export action).

**SA-15.** Composition avoids adding Context overhead for a simple data-passing problem. Pass `<Button onClick={handleClick} />` as `children` through the intermediate layers: `<Layout>{content}</Layout>`. The intermediate `Layout` component renders `{children}` without knowing about `onClick`. No Context Provider/Consumer needed, no re-render overhead, and the data flow is explicit.

**SA-16.** Decompose `TaskList` into: `TaskList` (renders the list), `useTaskFilter` (custom hook for filtering logic), `useTaskSort` (custom hook for sorting), `useKeyboardShortcuts` (custom hook for keyboard handling). Apply compound components if `TaskList` has sub-components like `TaskItem` that need shared state. Use composition to keep the layout flexible. Each piece has a single responsibility and is independently testable.

### Part C: Multiple Choice

| # | Answer | Explanation |
|---|---|---|
| MC-1 | **(b)** | Compound components share implicit state via Context. |
| MC-2 | **(b)** | Render props pass data to a function that returns JSX. |
| MC-3 | **(b)** | Hooks avoid wrapper nesting and prop collisions. |
| MC-4 | **(b)** | `value` + `onChange` = controlled. |
| MC-5 | **(b)** | `defaultValue` + ref = uncontrolled. |
| MC-6 | **(b)** | Controlled gives full programmatic control. |
| MC-7 | **(b)** | RSC run on server, access server resources, reduce client JS. |
| MC-8 | **(b)** | Client components use hooks and handle interactions. |
| MC-9 | **(b)** | First step: break UI into components. |
| MC-10 | **(b)** | Composition passes components as children or props. |
| MC-11 | **(b)** | When intermediaries don't need the data, pass consuming components directly. |
| MC-12 | **(b)** | Composition is simplest — pass `UserMenu` as children. |
| MC-13 | **(b)** | `forwardRef` passes a ref through to a child's DOM element. |
| MC-14 | **(b)** | Co-location keeps component + hook + test + styles together. |
| MC-15 | **(b)** | Single responsibility — decompose into focused units. |
| MC-16 | **(b)** | A custom hook `useAuth` is the recommended approach. |
