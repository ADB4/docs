# Week 6 Quiz: State Management

**Scope:** useReducer patterns, Context API (proper use and limitations), client vs. server vs. URL state, when external state libraries are warranted, lifting state, choosing state structure.

**Scoring:** Wrong answers on T/F and MC are subtracted from right answers. Do not guess.

---

## Part A: True / False (32 Questions)

---

**TF-1.** `useReducer` is an alternative to `useState` that centralizes state transition logic in a pure reducer function.

**TF-2.** A reducer function takes `(state, action)` and returns the new state. It must be pure — no side effects, no mutations.

**TF-3.** The `dispatch` function returned by `useReducer` is recreated on every render.

**TF-4.** The `dispatch` function has a stable identity across re-renders, making it safe to pass to child components without `useCallback`.

**TF-5.** `useReducer` is preferred over `useState` when state transitions are complex, involve multiple sub-values, or when the next state depends on the previous state in non-trivial ways.

**TF-6.** Actions dispatched to a reducer must always have a `type` property.

**TF-7.** Using a discriminated union for the action type provides compile-time exhaustiveness checking in the reducer's `switch` statement.

**TF-8.** You should mutate the existing state object in a reducer for performance.

**TF-9.** Reducers must return a new state object (or the same reference if unchanged); they must never mutate the existing state.

**TF-10.** Context API is designed to be a general-purpose state management replacement for libraries like Redux.

**TF-11.** Context is best suited for values that change infrequently and need to be accessible by many components at different nesting levels.

**TF-12.** When a Context value changes, only the components that actually read the changed portion of the value re-render.

**TF-13.** When a Context value changes, every component that calls `useContext` for that Context re-renders, even if it only uses a portion of the value.

**TF-14.** Splitting one large Context into multiple smaller Contexts can reduce unnecessary re-renders.

**TF-15.** Combining `useReducer` with Context is a common pattern for managing state that many components need to access.

**TF-16.** When using `useReducer` + Context, passing `dispatch` through Context is preferable to passing individual setter functions because `dispatch` has a stable identity.

**TF-17.** "Lifting state up" means moving shared state to the closest common ancestor of the components that need it.

**TF-18.** Lifting state up always requires Context.

**TF-19.** Client state, server state, and URL state are different categories that benefit from different management approaches.

**TF-20.** Client state includes UI-only data like whether a modal is open or which tab is selected.

**TF-21.** Server state refers to data fetched from an API that represents the server's truth — it is cached, can become stale, and needs synchronization.

**TF-22.** URL search parameters should be used for UI state that should survive page refresh and be shareable via a link.

**TF-23.** Most applications need an external state management library for client state.

**TF-24.** `useState`, `useReducer`, and Context cover the majority of client state needs without external libraries.

**TF-25.** External state libraries are warranted when you have complex shared mutable state that many unrelated components need to read and write frequently.

**TF-26.** When structuring state, you should avoid redundant state — don't store values that can be derived from other state.

**TF-27.** Mirroring a prop into state is a good practice because it makes the component more independent.

**TF-28.** Deeply nested state objects are easy to update immutably and should be preferred over flat structures.

**TF-29.** Grouping related state values into a single object or `useReducer` can help keep state transitions consistent.

**TF-30.** If two state variables always change together, they should probably be combined into a single state variable.

**TF-31.** An "impossible state" (e.g., `isLoading: true` and `error: "something"` simultaneously) can be prevented by restructuring state into a discriminated union.

**TF-32.** The "single source of truth" principle means each piece of data should be stored in exactly one place.

---

## Part B: Short Answer (16 Questions)

---

**SA-1.** Explain when you would choose `useReducer` over `useState`. Give a concrete example scenario.

---

**SA-2.** Write a reducer for a form with fields `name`, `email`, and `phone`. Actions: `setField` (with a field name and value) and `reset`. Use a discriminated union for actions.

---

**SA-3.** Explain the Context performance limitation. What happens when a Context value changes? Describe two mitigation strategies.

---

**SA-4.** Write a minimal Context + Provider setup for a theme that has `mode: "light" | "dark"` and a `toggleMode` function.

---

**SA-5.** Explain the pattern of combining `useReducer` with Context. What are the benefits?

---

**SA-6.** Distinguish between client state, server state, and URL state. Give one example and one appropriate tool for each.

---

**SA-7.** When does the syllabus say external state management libraries are warranted? When are they not?

---

**SA-8.** Explain "lifting state up." When a sibling component needs access to another sibling's state, what should you do?

---

**SA-9.** Explain the "avoid redundant state" principle. Give an example of a piece of state that should be derived instead of stored.

---

**SA-10.** What is an "impossible state" and how do you prevent it? Give an example using a fetch status.

---

**SA-11.** A developer stores `filteredTodos` in state and updates it in a `useEffect` whenever `todos` or `filter` changes. What is the problem and the correct approach?

---

**SA-12.** A component receives a `userId` prop and stores it in state with `useState(userId)`. When the prop changes, the state doesn't update. Explain the bug and two possible fixes.

---

**SA-13.** Explain why `dispatch` from `useReducer` is a better Context value than multiple setter functions.

---

**SA-14.** You have a `UserContext` that provides `{ user, preferences, notifications }`. Components that only need `user` re-render when `notifications` changes. How do you fix this?

---

**SA-15.** Explain the principle: "state that always changes together should live together." Give a concrete example.

---

**SA-16.** A todo app has 50 items and uses a single Context for the entire todo list. Every keystroke in the "new todo" input causes all 50 items to re-render. Diagnose the problem and propose a fix.

---

## Part C: Multiple Choice (16 Questions)

---

**MC-1.** When is `useReducer` preferred over `useState`?

(a) Always
(b) When state transitions are complex, involve multiple sub-values, or when next state depends on previous state in non-trivial ways
(c) Only for global state
(d) Only when using Context

---

**MC-2.** What must a reducer function NOT do?

(a) Return a new state object
(b) Use a `switch` statement
(c) Mutate the existing state or perform side effects
(d) Accept an action parameter

---

**MC-3.** What is a key property of the `dispatch` function?

(a) It causes an immediate synchronous state update
(b) It has a stable identity across re-renders
(c) It returns the new state
(d) It can only dispatch one action type

---

**MC-4.** What is the primary limitation of React Context for state management?

(a) Context values cannot be objects
(b) Every consumer re-renders when the value changes, even if it only uses a portion
(c) Context cannot be typed with TypeScript
(d) Context only works in class components

---

**MC-5.** Which strategy reduces unnecessary re-renders from Context?

(a) Using one large Context for all application state
(b) Splitting state into multiple smaller Contexts so consumers only subscribe to what they need
(c) Removing all Context usage
(d) Using `React.memo` on the Context Provider

---

**MC-6.** What is the best use for URL search parameters?

(a) Storing passwords
(b) UI state that should be shareable via a link, like filters or pagination
(c) Large binary data
(d) Authentication tokens

---

**MC-7.** According to the syllabus, when are external state libraries warranted?

(a) In every application
(b) When you have complex shared mutable state that many unrelated components read and write
(c) Whenever Context causes re-renders
(d) When using TypeScript

---

**MC-8.** What does "lifting state up" mean?

(a) Moving state from the component to a global store
(b) Moving shared state to the closest common ancestor of the components that need it
(c) Converting `useState` to `useReducer`
(d) Moving state from the client to the server

---

**MC-9.** A developer stores `fullName` in state alongside `firstName` and `lastName`. What principle does this violate?

(a) Single source of truth
(b) Avoid redundant state — `fullName` can be derived
(c) Lifting state up
(d) Controlled components

---

**MC-10.** What is an "impossible state"?

(a) A state value that is `never`
(b) A combination of state values that should not occur simultaneously, like `{ isLoading: true, error: "fail" }`
(c) State that exceeds memory limits
(d) A circular state dependency

---

**MC-11.** How can you prevent impossible states?

(a) Using `try/catch`
(b) Restructuring state as a discriminated union, like `{ status: "loading" } | { status: "error"; error: string } | { status: "success"; data: T }`
(c) Using `useEffect` to correct invalid state
(d) Storing each value in a separate `useState`

---

**MC-12.** A component mirrors a prop into state: `const [value, setValue] = useState(prop)`. The prop changes but state doesn't update. Why?

(a) `useState` is broken
(b) `useState` only uses the initial value on mount; subsequent prop changes are ignored
(c) Props cannot change in React
(d) The component unmounts and remounts

---

**MC-13.** What is the correct fix for the mirrored prop problem in MC-12?

(a) Use the prop directly instead of copying into state
(b) Add a `useEffect` that calls `setValue(prop)` when `prop` changes
(c) Either (a) for controlled behavior, or (b) as a workaround, or use `key={prop}` to reset the component
(d) Use `useReducer` instead

---

**MC-14.** When combining `useReducer` with Context, what should the Context value contain?

(a) Only state
(b) Both state and `dispatch` (often in separate Contexts for performance)
(c) Only `dispatch`
(d) The entire component tree

---

**MC-15.** A `filteredItems` value is recomputed from `items` and `filter`. Where should this computation happen?

(a) In a `useEffect` that writes to state
(b) In the render body: `const filteredItems = items.filter(...)` — no state or effect needed
(c) In a `useReducer`
(d) In a Context Provider

---

**MC-16.** Two sibling components need to share a counter value. What is the simplest correct approach?

(a) Use a global variable
(b) Lift the counter state to their common parent and pass the value and setter as props
(c) Use Context
(d) Use an external state library

---

---

## Answer Key

### Part A: True / False

| # | Answer | Explanation |
|---|---|---|
| TF-1 | **T** | `useReducer` centralizes transitions in a `(state, action) => newState` function. |
| TF-2 | **T** | Reducers must be pure: no mutations, no side effects, deterministic output. |
| TF-3 | **F** | `dispatch` has a stable identity — it is the same function reference across re-renders. |
| TF-4 | **T** | Stable identity means no `useCallback` wrapper needed. |
| TF-5 | **T** | Complex transitions, multiple sub-values, and state-dependent updates are `useReducer` use cases. |
| TF-6 | **F** | It's a strong convention but not enforced by React. The syllabus uses `type` as a discriminant, which is best practice. |
| TF-7 | **T** | A discriminated union with `never` in the default case provides exhaustiveness checking. |
| TF-8 | **F** | Never mutate state in a reducer. Always return a new object. |
| TF-9 | **T** | Immutability is required for React to detect changes. |
| TF-10 | **F** | Context is for passing data deeply, not general state management. It lacks features like selectors, middleware, and devtools. |
| TF-11 | **T** | Theme, locale, and auth are good Context use cases — infrequent changes, many consumers. |
| TF-12 | **F** | React does not have built-in selectors for Context. All consumers re-render. |
| TF-13 | **T** | Every `useContext` consumer re-renders when the value changes. |
| TF-14 | **T** | Smaller Contexts mean fewer unnecessary re-renders. |
| TF-15 | **T** | `useReducer` + Context is a common pattern for app-wide state without external libraries. |
| TF-16 | **T** | `dispatch` is stable; individual setters may not be. |
| TF-17 | **T** | Move state to the nearest shared ancestor. |
| TF-18 | **F** | Lifting state uses props, not Context. Context is for deeply nested access. |
| TF-19 | **T** | Different categories, different lifecycles, different tools. |
| TF-20 | **T** | UI toggles, selections, and local component state are client state. |
| TF-21 | **T** | Server state is fetched data that can become stale and needs sync. TanStack Query handles this (Week 14). |
| TF-22 | **T** | URL params make state shareable and bookmarkable. |
| TF-23 | **F** | The syllabus says most apps don't need external libraries. |
| TF-24 | **T** | Built-in React tools cover the majority of cases. |
| TF-25 | **T** | This is the legitimate use case for external libraries. |
| TF-26 | **T** | Derive what you can from existing state. |
| TF-27 | **F** | Mirroring props into state is an anti-pattern that leads to sync bugs. |
| TF-28 | **F** | Deeply nested state is hard to update immutably. Flat structures are preferred. |
| TF-29 | **T** | Grouping related state keeps transitions consistent and atomic. |
| TF-30 | **T** | State that changes together should be stored together. |
| TF-31 | **T** | A `status` discriminated union like `"idle" | "loading" | "error" | "success"` prevents impossible combinations. |
| TF-32 | **T** | Each piece of data has one canonical source. |

### Part B: Short Answer

**SA-1.** Use `useReducer` when state transitions are complex (e.g., multiple fields updated together), when next state depends on previous state in non-trivial ways, or when you have many related state values. Example: a multi-step form with validation where advancing/retreating steps requires coordinated updates to step index, form data, and validation errors.

**SA-2.**
```ts
type State = { name: string; email: string; phone: string };
type Action =
  | { type: "setField"; field: keyof State; value: string }
  | { type: "reset" };

const initialState: State = { name: "", email: "", phone: "" };

function formReducer(state: State, action: Action): State {
  switch (action.type) {
    case "setField":
      return { ...state, [action.field]: action.value };
    case "reset":
      return initialState;
  }
}
```

**SA-3.** When a Context value changes (a new object reference), every component calling `useContext` for that Context re-renders, even if it only reads a portion. Mitigations: (1) split into multiple smaller Contexts so consumers subscribe only to what they need; (2) memoize the Context value so it only changes when the underlying data changes (though the Compiler may handle this).

**SA-4.**
```tsx
type ThemeContextType = { mode: "light" | "dark"; toggleMode: () => void };
const ThemeContext = createContext<ThemeContextType>({ mode: "light", toggleMode: () => {} });

function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [mode, setMode] = useState<"light" | "dark">("light");
  const toggleMode = () => setMode(m => m === "light" ? "dark" : "light");
  return <ThemeContext.Provider value={{ mode, toggleMode }}>{children}</ThemeContext.Provider>;
}
```

**SA-5.** Put `useReducer` in the provider component and pass both `state` and `dispatch` through Context. Benefits: centralized state logic, stable `dispatch` identity, and any consumer can dispatch actions without prop drilling. Optionally split state and dispatch into separate Contexts so readers and writers don't unnecessarily trigger each other's re-renders.

**SA-6.** **Client state:** Whether a sidebar is open. Tool: `useState`. **Server state:** A list of products from an API. Tool: TanStack Query (Week 14). **URL state:** Current search filter. Tool: URL search parameters.

**SA-7.** Warranted: complex shared mutable state that many unrelated components read and write frequently. Not warranted: most applications — `useState`, `useReducer`, and Context handle the majority of client state needs.

**SA-8.** Move the shared state to the nearest common ancestor of both siblings. Pass the value and setter down as props. The parent owns the state; siblings receive it as props.

**SA-9.** Don't store values that can be computed from other state. Example: if you have `todos` and `filter` in state, don't also store `filteredTodos` — compute it during render: `const filtered = todos.filter(...)`.

**SA-10.** An impossible state is a combination of values that should never occur, like `{ isLoading: true, error: "fail" }`. Prevent it with a discriminated union: `type Status = { status: "idle" } | { status: "loading" } | { status: "error"; error: string } | { status: "success"; data: T }`. Each variant only contains the fields that make sense for that status.

**SA-11.** Storing `filteredTodos` in state and syncing with `useEffect` is redundant state and an unnecessary effect. Correct approach: compute during render: `const filteredTodos = todos.filter(t => filter === "all" || ...)`. No state, no effect.

**SA-12.** `useState(userId)` only uses the initial value on mount. Subsequent prop changes don't update state. Fixes: (1) don't copy the prop into state — use `userId` directly; (2) add a `useEffect` to sync `setValue(userId)` when the prop changes; (3) use `key={userId}` on the component to force a remount.

**SA-13.** `dispatch` has a stable identity across renders, so passing it through Context doesn't cause unnecessary re-renders. Individual setter functions may be new references on each render (without `useCallback`), which could trigger re-renders in consumers.

**SA-14.** Split into separate Contexts: `UserContext`, `PreferencesContext`, `NotificationsContext`. Components that only need `user` subscribe only to `UserContext` and don't re-render when notifications change.

**SA-15.** If `x` and `y` coordinates always update together, store them as `{ x, y }` instead of two separate `useState` calls. This ensures atomic updates and prevents impossible intermediate states where one is updated but the other isn't.

**SA-16.** The "new todo" input's state changes trigger a Context update, which re-renders all 50 items that consume the same Context. Fix: separate the input state from the todo list state — keep the input's `useState` local to the input component (not in Context), and only dispatch to the list Context on submit.

### Part C: Multiple Choice

| # | Answer | Explanation |
|---|---|---|
| MC-1 | **(b)** | Complex transitions and multiple related sub-values. |
| MC-2 | **(c)** | Reducers must not mutate or have side effects. |
| MC-3 | **(b)** | `dispatch` is stable across renders. |
| MC-4 | **(b)** | All consumers re-render on value change. |
| MC-5 | **(b)** | Smaller Contexts = fewer unnecessary re-renders. |
| MC-6 | **(b)** | URL params make UI state shareable and bookmarkable. |
| MC-7 | **(b)** | Complex shared mutable state across unrelated components. |
| MC-8 | **(b)** | Move state to the closest common ancestor. |
| MC-9 | **(b)** | `fullName` is derivable from `firstName` + `lastName`. |
| MC-10 | **(b)** | Impossible combinations like loading + error simultaneously. |
| MC-11 | **(b)** | A discriminated union makes impossible states unrepresentable. |
| MC-12 | **(b)** | `useState` only reads the initial value on mount. |
| MC-13 | **(c)** | Use the prop directly, sync with effect, or reset via `key`. |
| MC-14 | **(b)** | Both state and dispatch, often in separate Contexts. |
| MC-15 | **(b)** | Compute during render — no state or effect needed. |
| MC-16 | **(b)** | Lift state to the common parent and pass via props. |
