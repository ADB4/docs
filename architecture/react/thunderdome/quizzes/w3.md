# Week 3 Quiz: TypeScript in React

**Scope:** Prop typing without React.FC, hook typing (useState, useEffect, useContext), custom hook return types, compound component type patterns, event typing, generic components, .d.ts files and @types packages.

**Assigned Readings:**
- React: "TypeScript" page (react.dev/learn/typescript)
- React: "Your First Component" and "Passing Props to a Component"
- React: "State: A Component's Memory" and "State as a Snapshot"
- TS-HB: "Type Declarations"
- Article: Matt Pocock on React.FC

**Scoring:** Wrong answers on T/F and MC are subtracted from right answers. Do not guess.

---

## Part A: True / False (32 Questions)

---

**TF-1.** `React.FC` is the preferred way to type functional components in 2026.

**TF-2.** A plain function declaration with destructured, typed props is the recommended component typing pattern in this syllabus.

**TF-3.** One reason `React.FC` is discouraged is that it historically added an implicit `children` prop to all components, even those that should not accept children.

**TF-4.** `React.FC` prevents you from writing generic components.

**TF-5.** When using the preferred pattern, you define a component's prop types as an interface or type alias, then destructure props in the function parameter.

**TF-6.** `useState(0)` infers the state type as `number` without needing an explicit type argument.

**TF-7.** `useState<User | null>(null)` is necessary when the initial value is narrower than the full range of possible states.

**TF-8.** `useState(null)` without a type argument infers the state as `null` only, making it impossible to later set a non-null value.

**TF-9.** `useEffect` returns a cleanup function, and that cleanup function should have the return type `void`.

**TF-10.** The dependency array passed to `useEffect` is optional; omitting it causes the effect to run after every render.

**TF-11.** An empty dependency array `[]` in `useEffect` means the effect runs only once, after the initial render.

**TF-12.** `useContext` returns the context value typed according to the type argument of `createContext`.

**TF-13.** Custom hooks must start with the prefix `use` for the Rules of Hooks linter and the React Compiler to recognize them.

**TF-14.** When a custom hook returns `[value, setValue]`, TypeScript automatically infers a tuple type that preserves the type of each element at its position.

**TF-15.** Adding `as const` to a custom hook's return array (`return [value, toggle] as const`) preserves the tuple type and makes it `readonly`.

**TF-16.** An explicit tuple type annotation (`return [value, toggle] as [boolean, () => void]`) is another valid way to preserve positional types in a custom hook return.

**TF-17.** A generic React component is impossible because React does not support type parameters on components.

**TF-18.** `function List<T>(props: { items: T[] }): JSX.Element` is a valid generic component where `T` is inferred from the `items` prop at each call site.

**TF-19.** `React.ReactNode` is the correct type for a `children` prop that can accept strings, numbers, elements, fragments, null, and undefined.

**TF-20.** `JSX.Element` is a narrower type than `React.ReactNode` and specifically represents a single React element.

**TF-21.** Event handler props should use React's synthetic event types (e.g., `React.MouseEvent<HTMLButtonElement>`) rather than the native DOM `Event` type.

**TF-22.** `React.ChangeEvent<HTMLInputElement>` is the correct type for the `onChange` event of an `<input>` element.

**TF-23.** `useRef<HTMLDivElement>(null)` returns `{ current: HTMLDivElement }` — the `null` is removed from the type.

**TF-24.** When `useRef` is passed `null` as the initial value with a type argument, the returned ref has `current` typed as `T | null`, and you must check for `null` before accessing DOM methods.

**TF-25.** `.d.ts` files contain only type declarations and produce no JavaScript output.

**TF-26.** `.d.ts` files can contain executable code that runs when the module is imported.

**TF-27.** The `@types` scope on npm corresponds to the DefinitelyTyped repository and provides type declarations for libraries that do not bundle their own.

**TF-28.** TypeScript automatically discovers type definitions in `node_modules/@types` without any additional configuration.

**TF-29.** `declare module "some-library"` in a `.d.ts` file provides a quick way to silence type errors by implicitly typing the module's exports as `any`.

**TF-30.** If a library bundles its own type declarations, you still need to install a separate `@types` package.

**TF-31.** When typing the `useReducer` hook, you should use a discriminated union for the action type, with each action having a `type` discriminant.

**TF-32.** The `dispatch` function returned by `useReducer` is automatically typed based on the action type of the reducer.

---

## Part B: Short Answer (16 Questions)

Answer in 1–4 sentences or a short code snippet. Write valid TypeScript/React where code is requested.

---

**SA-1.** Write a React component `Greeting` that takes a required prop `name: string` and an optional prop `loud?: boolean`. Use the preferred typing pattern (no React.FC). If `loud` is true, render the name in uppercase.

---

**SA-2.** Explain in 2–3 sentences why `React.FC` is not recommended. What specific problems does it cause?

---

**SA-3.** Write a `useState` call for a piece of state that will hold either a `User` object or `null`. Define the `User` type as `{ name: string; email: string }`.

---

**SA-4.** What is the difference between `useState("")` and `useState<string>("")`? When is the explicit type argument redundant, and when is it necessary?

---

**SA-5.** Write a `useEffect` call that runs once on mount and logs "mounted" to the console, with a cleanup function that logs "unmounted".

---

**SA-6.** Write a custom hook `useToggle` that takes an `initial: boolean` parameter and returns a `[boolean, () => void]` tuple. Ensure the return type preserves the tuple structure.

---

**SA-7.** Explain the problem with the following custom hook return type. What does TypeScript infer, and why is it a problem for callers?

```ts
function useToggle(initial: boolean) {
  const [value, setValue] = useState(initial);
  const toggle = () => setValue(v => !v);
  return [value, toggle];
}
```

---

**SA-8.** Write a generic component `SelectList<T>` that accepts `items: T[]` and `renderItem: (item: T) => React.ReactNode`, and renders each item in a `<ul>`.

---

**SA-9.** How do you type an `onChange` handler for an `<input>` element? Write the function signature.

---

**SA-10.** How do you type a `useRef` that will hold a reference to an `<input>` DOM element? Write the `useRef` call and show how you would access the `.focus()` method on it.

---

**SA-11.** What is `React.ReactNode` and when should you use it? How does it differ from `JSX.Element`?

---

**SA-12.** Write a `createContext` call with a proper type for a theme context that holds `{ mode: "light" | "dark"; toggleMode: () => void }`. What should the default value be?

---

**SA-13.** What is a `.d.ts` file and what is its purpose? Can it contain runnable code?

---

**SA-14.** You install a library `fancy-dates` from npm and TypeScript reports "Could not find a declaration file for module 'fancy-dates'." List two approaches to resolve this.

---

**SA-15.** Write a type for a `Button` component's props that includes: `label: string`, `variant: "primary" | "secondary"`, `onClick: () => void`, and an optional `disabled?: boolean`.

---

**SA-16.** Write a typed reducer and action type for a simple counter. The action type should be a discriminated union with `{ type: "increment" }` and `{ type: "reset"; payload: number }`. Show the reducer function signature.

---

## Part C: Multiple Choice (16 Questions)

Choose the single best answer.

---

**MC-1.** Which is the preferred way to type a React component in this syllabus?

(a) `const Button: React.FC<Props> = ({ label }) => ...`
(b) `function Button({ label }: Props) { return ... }`
(c) `class Button extends React.Component<Props> { ... }`
(d) `const Button = (props: any) => ...`

---

**MC-2.** What is the type of `count` after this call?

```ts
const [count, setCount] = useState(0);
```

(a) `any`
(b) `number`
(c) `number | undefined`
(d) `0`

---

**MC-3.** What happens if you write `useState(null)` without a type argument for state that will later hold a `User` object?

(a) TypeScript infers the state as `User | null` automatically
(b) TypeScript infers the state as `null` only, and calling `setUser(someUser)` will be a type error
(c) No error; TypeScript uses `any` for null states
(d) The code fails at runtime

---

**MC-4.** What is the return type of the cleanup function in `useEffect`?

```ts
useEffect(() => {
  const id = setInterval(() => console.log("tick"), 1000);
  return () => clearInterval(id);
}, []);
```

(a) `number`
(b) `void`
(c) `undefined`
(d) `() => void`

---

**MC-5.** What does TypeScript infer for the return type of this custom hook?

```ts
function useCounter(initial: number) {
  const [count, setCount] = useState(initial);
  const increment = () => setCount(c => c + 1);
  return [count, increment];
}
```

(a) `[number, () => void]`
(b) `(number | (() => void))[]`
(c) `{ count: number; increment: () => void }`
(d) `any[]`

---

**MC-6.** Which fix preserves the tuple type for the hook in MC-5?

(a) `return [count, increment] as const`
(b) `return [count, increment] as [number, () => void]`
(c) Both (a) and (b) work
(d) You must return an object instead

---

**MC-7.** How do you create a generic React component?

(a) `const List: React.FC<{ items: T[] }> = ...` (with a generic `T` somehow)
(b) `function List<T>(props: { items: T[]; render: (item: T) => React.ReactNode }) { ... }`
(c) Generic components are not possible in React
(d) You must use a class component to have generics

---

**MC-8.** What is the correct type for a `children` prop that accepts any renderable React content?

(a) `children: string`
(b) `children: JSX.Element`
(c) `children: React.ReactNode`
(d) `children: React.FC`

---

**MC-9.** What is the type of `inputRef.current` after this declaration?

```ts
const inputRef = useRef<HTMLInputElement>(null);
```

(a) `HTMLInputElement`
(b) `HTMLInputElement | null`
(c) `null`
(d) `React.RefObject<HTMLInputElement>`

---

**MC-10.** Which event type should you use for the `onChange` handler of an `<input>` element?

(a) `Event`
(b) `React.ChangeEvent<HTMLInputElement>`
(c) `React.MouseEvent<HTMLInputElement>`
(d) `InputEvent`

---

**MC-11.** What does `React.MouseEvent<HTMLButtonElement>` represent?

(a) A native DOM `MouseEvent`
(b) A React synthetic mouse event scoped to `<button>` elements, wrapping the native event
(c) A generic type that applies to all elements
(d) A class that you must instantiate

---

**MC-12.** What is the purpose of `.d.ts` files?

(a) They compile to JavaScript and are used for code splitting
(b) They contain only type declarations, used for type checking without producing JavaScript output
(c) They are configuration files for the TypeScript compiler
(d) They store compiled bytecode for faster execution

---

**MC-13.** If you install `@types/lodash`, where does TypeScript find these type definitions?

(a) In a special TypeScript cache directory
(b) In `node_modules/@types/lodash`, which TypeScript discovers automatically
(c) You must import them explicitly in every file
(d) They are downloaded at runtime

---

**MC-14.** What does `declare module "some-untyped-lib"` in a `.d.ts` file do?

(a) Installs the library
(b) Declares the module with all exports typed as `any`, silencing type errors
(c) Converts the library to TypeScript
(d) Nothing; it is ignored by the compiler

---

**MC-15.** Which type should you use for a reducer action?

```ts
type Action =
  | { type: "add"; payload: string }
  | { type: "remove"; payload: number }
  | { type: "clear" };
```

(a) A single interface with optional fields
(b) A discriminated union where each action has a `type` property with a unique literal value
(c) An enum
(d) A generic type `Action<T>`

---

**MC-16.** What is the type of `dispatch` returned by `useReducer(reducer, initialState)` when the reducer's action parameter is typed as `Action`?

(a) `(action: any) => void`
(b) `React.Dispatch<Action>`
(c) `(action: Action) => State`
(d) `() => void`

---

---

## Answer Key

### Part A: True / False

| # | Answer | Explanation |
|---|---|---|
| TF-1 | **F** | `React.FC` is not recommended. Plain function declarations are preferred. |
| TF-2 | **T** | This is the syllabus's explicit recommendation, aligned with React team guidance. |
| TF-3 | **T** | Older `@types/react` versions included `children` in `React.FC` props. This was removed in React 18 typings but the pattern is still discouraged for other reasons. |
| TF-4 | **T** | `React.FC<Props>` does not support generic type parameters on the component itself. A plain function declaration with `<T>` works naturally. |
| TF-5 | **T** | The standard pattern: `interface Props { name: string }` then `function Greeting({ name }: Props)`. |
| TF-6 | **T** | TypeScript infers the state type from the initial value. `0` infers `number`. |
| TF-7 | **T** | When the initial value is `null` but the state will later hold a `User`, you must write `useState<User | null>(null)`. |
| TF-8 | **T** | Without the type argument, TypeScript infers `null` only. `setUser(someUser)` would be a type error because `User` is not assignable to `null`. |
| TF-9 | **T** | The cleanup function returned from a `useEffect` callback should return `void`. |
| TF-10 | **T** | Without a dependency array, the effect runs after every render. |
| TF-11 | **T** | `[]` means no dependencies, so the effect runs once on mount and cleanup runs on unmount. |
| TF-12 | **T** | `useContext(MyContext)` returns the value typed according to how `MyContext` was created. |
| TF-13 | **T** | The `use` prefix is required by convention, linter rules, and the React Compiler. |
| TF-14 | **F** | TypeScript infers a union array `(TypeA | TypeB)[]`, not a tuple. Positional types are lost. |
| TF-15 | **T** | `as const` produces `readonly [boolean, () => void]`, preserving the tuple structure. |
| TF-16 | **T** | An explicit assertion `as [boolean, () => void]` also preserves the tuple type without making it `readonly`. |
| TF-17 | **F** | Generic components work with plain function declarations. `function List<T>(props: { items: T[] })` is valid. |
| TF-18 | **T** | The type parameter `T` is inferred from the `items` prop at each usage: `<List items={[1,2,3]} />` infers `T` as `number`. |
| TF-19 | **T** | `React.ReactNode` covers strings, numbers, elements, fragments, booleans, null, and undefined. |
| TF-20 | **T** | `JSX.Element` is specifically a React element. `React.ReactNode` is a broader union that includes primitives, null, and arrays. |
| TF-21 | **T** | React's synthetic events provide consistent cross-browser behavior and proper TypeScript types. Native `Event` is too broad. |
| TF-22 | **T** | `React.ChangeEvent<HTMLInputElement>` is the correct synthetic event for input changes. |
| TF-23 | **F** | The initial `null` means `current` is `HTMLDivElement | null`. You must check for `null`. |
| TF-24 | **T** | When you pass `null` initially, the ref type includes `null`. Use `if (ref.current)` before accessing DOM methods. |
| TF-25 | **T** | `.d.ts` files are declaration-only. They produce no `.js` output. |
| TF-26 | **F** | `.d.ts` files cannot contain executable code. They are type declarations only. |
| TF-27 | **T** | `@types/*` packages come from DefinitelyTyped and provide community-maintained type declarations. |
| TF-28 | **T** | TypeScript's default `typeRoots` includes `node_modules/@types`. |
| TF-29 | **T** | A bare `declare module "name"` without a body types all exports as `any`. |
| TF-30 | **F** | If a library bundles its own types (a `.d.ts` file in the package), no separate `@types` package is needed. |
| TF-31 | **T** | A discriminated union with a `type` property is the standard pattern for reducer actions in TypeScript. |
| TF-32 | **T** | `useReducer` infers the `dispatch` type from the reducer's action parameter. |

### Part B: Short Answer

**SA-1.**

```tsx
interface GreetingProps {
  name: string;
  loud?: boolean;
}

function Greeting({ name, loud }: GreetingProps) {
  return <h1>{loud ? name.toUpperCase() : name}</h1>;
}
```

---

**SA-2.**
`React.FC` is discouraged because: (1) older typings implicitly added `children` to props even when a component shouldn't accept children, (2) it wraps the return type redundantly, obscuring what the component actually returns, and (3) it does not support generic type parameters on the component, which are needed for reusable components like lists and selects.

---

**SA-3.**

```ts
type User = { name: string; email: string };
const [user, setUser] = useState<User | null>(null);
```

---

**SA-4.**
Both produce identical types (`string`) for the state variable. The explicit type argument is redundant when the initial value already represents the full type. It is necessary when the initial value is narrower — for example, `useState<User | null>(null)` where `null` alone does not represent the full state range.

---

**SA-5.**

```ts
useEffect(() => {
  console.log("mounted");
  return () => {
    console.log("unmounted");
  };
}, []);
```

The empty dependency array `[]` ensures the effect runs once on mount and the cleanup runs on unmount.

---

**SA-6.**

```ts
function useToggle(initial: boolean): [boolean, () => void] {
  const [value, setValue] = useState(initial);
  const toggle = () => setValue(v => !v);
  return [value, toggle];
}
```

The explicit return type annotation `[boolean, () => void]` preserves the tuple structure. Alternatively, `return [value, toggle] as const` works.

---

**SA-7.**
TypeScript infers the return type as `(boolean | (() => void))[]` — a union array, not a tuple. This means callers cannot safely destructure: `const [val, tog] = useToggle(false)` gives both `val` and `tog` the type `boolean | (() => void)`, so you can't call `tog()` without narrowing and `val` might be a function. The fix is to add an explicit tuple return type or use `as const`.

---

**SA-8.**

```tsx
function SelectList<T>(props: {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
}) {
  return (
    <ul>
      {props.items.map((item, i) => (
        <li key={i}>{props.renderItem(item)}</li>
      ))}
    </ul>
  );
}
```

---

**SA-9.**

```ts
function handleChange(e: React.ChangeEvent<HTMLInputElement>): void {
  console.log(e.target.value);
}
```

---

**SA-10.**

```ts
const inputRef = useRef<HTMLInputElement>(null);

// Later, in an effect or handler:
if (inputRef.current) {
  inputRef.current.focus();
}
```

You must check for `null` because the ref starts as `null` before the element mounts.

---

**SA-11.**
`React.ReactNode` is a union type that covers everything React can render: strings, numbers, booleans, `null`, `undefined`, JSX elements, fragments, and arrays of these. Use it for `children` or any prop that accepts renderable content. `JSX.Element` is narrower — it represents a single React element only (not strings, numbers, null, etc.).

---

**SA-12.**

```ts
type ThemeContext = {
  mode: "light" | "dark";
  toggleMode: () => void;
};

const ThemeContext = createContext<ThemeContext>({
  mode: "light",
  toggleMode: () => {},
});
```

The default value should match the type. A common alternative is `createContext<ThemeContext | null>(null)` and using a custom hook that throws if the context is null.

---

**SA-13.**
A `.d.ts` file is a declaration file that contains only type information — type aliases, interfaces, function signatures, class declarations, etc. It does not contain executable code and produces no JavaScript output. Its purpose is to provide type information for JavaScript code or libraries that don't have TypeScript source.

---

**SA-14.**
Two approaches: (1) Install community types: `npm install --save-dev @types/fancy-dates` (if available on DefinitelyTyped). (2) Create your own declaration file, e.g., `fancy-dates.d.ts` with `declare module "fancy-dates"` — this silences the error by typing exports as `any`, or you can add specific type declarations.

---

**SA-15.**

```ts
interface ButtonProps {
  label: string;
  variant: "primary" | "secondary";
  onClick: () => void;
  disabled?: boolean;
}
```

---

**SA-16.**

```ts
type State = { count: number };

type Action =
  | { type: "increment" }
  | { type: "reset"; payload: number };

function counterReducer(state: State, action: Action): State {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "reset":
      return { count: action.payload };
  }
}
```

The action is a discriminated union with `type` as the discriminant. The reducer returns `State` and narrows the action in each `case`.

---

### Part C: Multiple Choice

| # | Answer | Explanation |
|---|---|---|
| MC-1 | **(b)** | Plain function declarations with typed props are preferred. No `React.FC`, no class components, no `any`. |
| MC-2 | **(b)** | TypeScript infers state type from the initial value `0`, which is `number`. |
| MC-3 | **(b)** | Without a type argument, `useState(null)` infers `null` only. Setting state to a `User` would be a type error. |
| MC-4 | **(b)** | The cleanup function is `() => void`. The `useEffect` callback itself returns either nothing or a cleanup function. |
| MC-5 | **(b)** | Without `as const` or an explicit tuple type, TypeScript infers `(number | (() => void))[]`. |
| MC-6 | **(c)** | Both `as const` (producing `readonly [number, () => void]`) and the explicit assertion work. |
| MC-7 | **(b)** | Generic components use plain function declarations with a type parameter. `React.FC` cannot express this. |
| MC-8 | **(c)** | `React.ReactNode` covers all renderable content. `JSX.Element` is too narrow (excludes strings, null, etc.). |
| MC-9 | **(b)** | The initial `null` means `current` is `HTMLInputElement | null`. |
| MC-10 | **(b)** | `React.ChangeEvent<HTMLInputElement>` is the correct synthetic event type for input `onChange`. |
| MC-11 | **(b)** | React synthetic events wrap native events and are scoped to the element type via the generic parameter. |
| MC-12 | **(b)** | `.d.ts` files are declarations only — types, no JavaScript. |
| MC-13 | **(b)** | TypeScript automatically resolves types in `node_modules/@types`. |
| MC-14 | **(b)** | A bare `declare module` types all exports as `any`, which silences errors. |
| MC-15 | **(b)** | A discriminated union with `type` literals is the standard pattern for typed reducer actions. |
| MC-16 | **(b)** | `useReducer` returns `[State, React.Dispatch<Action>]`. The `dispatch` function is typed to accept only valid `Action` values. |