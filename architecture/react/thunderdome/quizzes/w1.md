# Week 1: TypeScript Fundamentals

**Scope:** The Basics, Everyday Types, Narrowing, More on Functions (through overloads), Object Types.

**Assigned Readings:**
- TS-HB: "The Basics"
- TS-HB: "Everyday Types"
- TS-HB: "Narrowing"
- TS-HB: "More on Functions" (through "Function Overloads")
- TS-HB: "Object Types"

**Scoring:** Wrong answers on T/F and multiple choice are subtracted from right answers. Do not guess. Short answer questions are graded on correctness and conciseness — do not write more than is asked for.

---

## Part A: True / False (32 Questions)

---

**TF-1.** TypeScript is a statically typed superset of JavaScript: all valid JavaScript is valid TypeScript.

**TF-2.** TypeScript types are enforced at runtime by the compiled JavaScript.

**TF-3.** The primary purpose of TypeScript is to catch type errors before your code runs.

**TF-4.** Type annotations are always required in TypeScript; the compiler cannot determine types without them.

**TF-5.** `const x = 10` infers `x` as the literal type `10`, while `let x = 10` infers `x` as `number`.

**TF-6.** `string`, `number`, and `boolean` are the three most commonly used primitive types in TypeScript.

**TF-7.** `String` (uppercase) and `string` (lowercase) are interchangeable in type annotations.

**TF-8.** The type `any` disables type checking for the value it applies to and should be avoided in strict codebases.

**TF-9.** The type `unknown` is the type-safe counterpart of `any`: it accepts any value but requires narrowing before use.

**TF-10.** A function with return type `void` must not contain any `return` statement at all.

**TF-11.** The `never` type represents values that never occur, such as the return type of a function that always throws an exception.

**TF-12.** In TypeScript, `null` and `undefined` are the same type.

**TF-13.** With `strictNullChecks` enabled, `null` is not assignable to `string` unless the type explicitly includes `null` (e.g., `string | null`).

**TF-14.** A union type `string | number` means the value could be either a `string` or a `number` at any given point, and you must narrow before using type-specific operations.

**TF-15.** An intersection type `A & B` for two object types produces a type that has the properties of both `A` and `B`.

**TF-16.** Type aliases (declared with `type`) and interfaces (declared with `interface`) can both describe object shapes.

**TF-17.** Interfaces support declaration merging (declaring the same interface name twice to add properties), while type aliases do not.

**TF-18.** You can extend an interface from another interface using the `extends` keyword, but you cannot extend a type alias.

**TF-19.** Optional properties (e.g., `age?: number`) have the type `number | undefined`.

**TF-20.** The `readonly` modifier on a property prevents reassignment of that property but does not deeply freeze nested objects.

**TF-21.** Index signatures (e.g., `[key: string]: number`) allow an object to accept any number of properties as long as they match the declared key and value types.

**TF-22.** TypeScript uses structural typing: if two types have the same shape, they are compatible regardless of their declared names.

**TF-23.** Excess property checking applies to all object assignments, not just object literals.

**TF-24.** `typeof` in a type position (e.g., `type T = typeof x`) extracts the TypeScript type of a variable, which is different from the JavaScript runtime `typeof` operator.

**TF-25.** Truthiness narrowing can eliminate `null` and `undefined` from a union type inside an `if (value)` block.

**TF-26.** The equality check `if (x === y)` can narrow the types of both `x` and `y` to their overlap.

**TF-27.** The `in` operator (e.g., `if ("swim" in animal)`) can narrow a union type based on whether a property exists.

**TF-28.** `instanceof` is only useful for narrowing class instances, not plain objects or interfaces.

**TF-29.** Function overload signatures in TypeScript create multiple runtime implementations of the same function.

**TF-30.** A function's rest parameter must be the last parameter in the parameter list and is typed as an array.

**TF-31.** Type assertions (`value as Type`) perform a runtime conversion of the value to the target type.

**TF-32.** The non-null assertion operator (`value!`) tells TypeScript to treat the value as non-null and non-undefined, without any runtime check.

---

## Part B: Short Answer (16 Questions)

Answer each question in 1–4 sentences or a short code snippet as appropriate. Conciseness matters — do not write an essay. If the question asks for code, pseudocode is not acceptable; write valid TypeScript.

---

**SA-1.** What is type inference, and why does it mean you don't need to annotate every variable in TypeScript?

---

**SA-2.** Explain the difference in inferred type between these two declarations. What is the type of each?

```ts
const a = "hello";
let b = "hello";
```

---

**SA-3.** What is the difference between `any` and `unknown`? When would you use `unknown` instead of `any`?

---

**SA-4.** Write a type alias `StringOrNumber` that represents a value that can be either a `string` or a `number`.

---

**SA-5.** Given the following union type, write the body of the function so that TypeScript narrows correctly and no type error occurs:

```ts
function describe(value: string | number): string {
  // your code here
}
```

The function should return `"string: <value>"` if value is a string, and `"number: <value>"` if value is a number.

---

**SA-6.** Explain what excess property checking is. Why does TypeScript error on the first assignment below but not the second?

```ts
type Config = { debug: boolean };

const a: Config = { debug: true, verbose: true };  // Error
const temp = { debug: true, verbose: true };
const b: Config = temp;                             // No error
```

---

**SA-7.** Write an interface `User` with the following properties: `name` (required string), `email` (required string), and `age` (optional number).

---

**SA-8.** What is declaration merging? Write a short example showing how it works with interfaces.

---

**SA-9.** Write a function signature (no body needed) called `greet` that takes a required `name: string` parameter and an optional `greeting: string` parameter, and returns `string`.

---

**SA-10.** Explain in 2–3 sentences why `readonly` is considered shallow. What does it prevent, and what does it not prevent?

---

**SA-11.** Write an index signature type `Dictionary` that represents an object with any number of string keys, where each value is a `number`.

---

**SA-12.** What are the four narrowing techniques covered in the "Narrowing" chapter, and what kinds of types does each one narrow? (A one-phrase description for each is sufficient.)

---

**SA-13.** Given this code, what is the type of `pet` inside the `if` block, and why?

```ts
type Fish = { swim: () => void };
type Bird = { fly: () => void };

function move(pet: Fish | Bird) {
  if ("swim" in pet) {
    // what is pet's type here?
  }
}
```

---

**SA-14.** Explain the difference between `void` and `never` as function return types. Give a one-line example of each.

---

**SA-15.** What are function overloads in TypeScript? Write a minimal example of a function with two overload signatures and one implementation signature.

---

**SA-16.** The TypeScript Handbook says "types are not always what they appear to be at the type level" when discussing structural typing. In 2–3 sentences, explain what structural typing means and how it differs from nominal typing.

---

## Part C: Multiple Choice (16 Questions)

Choose the single best answer.

---

**MC-1.** What is the inferred type of `value`?

```ts
let value = [1, 2, 3];
```

(a) `[number, number, number]`
(b) `number[]`
(c) `(1 | 2 | 3)[]`
(d) `any[]`

---

**MC-2.** What error does TypeScript report?

```ts
function double(x: number): number {
  return x * 2;
}
const result = double("five");
```

(a) `"five"` is not assignable to parameter of type `number`
(b) Function `double` cannot return `number`
(c) `result` is implicitly typed as `any`
(d) No error

---

**MC-3.** What is the return type of this function as inferred by TypeScript?

```ts
function parse(input: string) {
  const n = parseInt(input);
  if (isNaN(n)) {
    return null;
  }
  return n;
}
```

(a) `number`
(b) `number | null`
(c) `number | undefined`
(d) `any`

---

**MC-4.** What is the type of `x` inside the `else` block?

```ts
function example(x: string | number | null) {
  if (x === null) {
    // ...
  } else if (typeof x === "string") {
    // ...
  } else {
    // what is x here?
  }
}
```

(a) `string | number | null`
(b) `string`
(c) `number`
(d) `never`

---

**MC-5.** Which of the following is NOT a valid way to narrow a union type in TypeScript?

(a) `typeof x === "string"` in an `if` condition
(b) `"property" in x` in an `if` condition
(c) `x instanceof SomeClass` in an `if` condition
(d) `x is string` used directly as a condition in an `if` statement

---

**MC-6.** What happens when you try to assign to a `readonly` property outside the object's initialization?

```ts
type Point = {
  readonly x: number;
  readonly y: number;
};

const p: Point = { x: 10, y: 20 };
p.x = 30;
```

(a) TypeScript reports a compile-time error
(b) The assignment is silently ignored at runtime
(c) The value changes at runtime but TypeScript warns
(d) No error at compile time or runtime

---

**MC-7.** Which statement about interfaces and type aliases is FALSE?

(a) Both can describe the shape of an object
(b) Both can be extended (interfaces with `extends`, type aliases with intersections)
(c) Both support declaration merging
(d) Both support generic parameters

---

**MC-8.** What does the `?` signify in this property declaration?

```ts
interface Config {
  debug?: boolean;
}
```

(a) The property's value must be `boolean | null`
(b) The property may be absent from the object entirely, and if present its value is `boolean`
(c) The property is readonly
(d) The property must be provided but can be `false`

---

**MC-9.** What is the type of `obj[key]` given this index signature?

```ts
interface NumberMap {
  [key: string]: number;
}

const obj: NumberMap = { a: 1, b: 2 };
const val = obj["c"];
```

(a) `number` (without `noUncheckedIndexedAccess`)
(b) `number | undefined`
(c) `any`
(d) `string`

---

**MC-10.** What does this intersection type produce?

```ts
type A = { name: string };
type B = { age: number };
type C = A & B;
```

(a) A type with either `name` or `age`, but not both
(b) A type with both `name: string` and `age: number`
(c) A union type `string | number`
(d) The type `never`

---

**MC-11.** What is the inferred type of `items`?

```ts
const items = [1, "two", true];
```

(a) `[number, string, boolean]`
(b) `(number | string | boolean)[]`
(c) `any[]`
(d) `object[]`

---

**MC-12.** What does truthiness narrowing eliminate in this code?

```ts
function printLength(value: string | null | undefined) {
  if (value) {
    // what types has narrowing removed here?
    console.log(value.length);
  }
}
```

(a) Only `null`
(b) Only `undefined`
(c) Both `null` and `undefined` (and also empty string, which is falsy)
(d) Nothing; `value` is still `string | null | undefined`

---

**MC-13.** What does a type assertion do?

```ts
const canvas = document.getElementById("main") as HTMLCanvasElement;
```

(a) Converts the DOM element to an `HTMLCanvasElement` at runtime
(b) Tells TypeScript to treat the value as `HTMLCanvasElement` without any runtime effect
(c) Creates a new `HTMLCanvasElement` instance
(d) Throws an error if the element is not a canvas

---

**MC-14.** What is the purpose of the non-null assertion operator `!`?

```ts
function process(value: string | null) {
  console.log(value!.length);
}
```

(a) It converts `null` to an empty string at runtime
(b) It tells TypeScript to remove `null` and `undefined` from the type, with no runtime check
(c) It throws a runtime error if `value` is `null`
(d) It is equivalent to `value ?? ""`

---

**MC-15.** Which of the following correctly describes function overloads in TypeScript?

(a) Each overload signature generates a separate JavaScript function
(b) Overload signatures define the callable shapes; only the implementation signature contains the function body, and the implementation signature is not directly callable
(c) Overload signatures are only for documentation and are ignored by the type checker
(d) You can have multiple implementation signatures for the same function

---

**MC-16.** What is the inferred type of `pair`?

```ts
function makePair(a: number, b: string) {
  return { first: a, second: b };
}
const pair = makePair(1, "hello");
```

(a) `any`
(b) `{ first: number; second: string }`
(c) `[number, string]`
(d) `object`

---

---

## Answer Key

### Part A: True / False

| # | Answer | Explanation |
|---|---|---|
| TF-1 | **T** | TypeScript is a strict superset of JavaScript. Any valid JS file is valid TS (though it may produce type errors under strict settings). |
| TF-2 | **F** | All types are erased at compile time. The JavaScript output has no type information and no runtime type enforcement. |
| TF-3 | **T** | TypeScript is a static type checker. Its purpose is to find errors before execution. |
| TF-4 | **F** | TypeScript has powerful type inference. Many variables, return types, and expressions are inferred without explicit annotations. |
| TF-5 | **T** | `const` prevents reassignment, so TypeScript infers the narrowest literal type. `let` allows reassignment, so it widens to the base type. |
| TF-6 | **T** | These are the three primitive types you'll use most. TypeScript also has `bigint`, `symbol`, `null`, `undefined`, and others. |
| TF-7 | **F** | `String` is the wrapper object type. `string` is the primitive type. The Handbook explicitly says to always use the lowercase versions. |
| TF-8 | **T** | `any` opts out of type checking entirely. It defeats the purpose of TypeScript and should be avoided or explicitly justified. |
| TF-9 | **T** | `unknown` is the top type that accepts any value, but you must narrow it (via `typeof`, `instanceof`, etc.) before performing operations. |
| TF-10 | **F** | A `void` function can have `return` statements (including `return undefined` or bare `return`). `void` means the return value should not be used, not that `return` is prohibited. |
| TF-11 | **T** | `never` is the bottom type. Functions that always throw or have infinite loops return `never`. |
| TF-12 | **F** | `null` and `undefined` are distinct types in TypeScript. With `strictNullChecks`, they are not interchangeable. |
| TF-13 | **T** | Under `strictNullChecks`, `null` must be explicitly included in the type via a union. `string` alone does not accept `null`. |
| TF-14 | **T** | A union type means "one of these." You must narrow (via `typeof`, `in`, etc.) before accessing members specific to one branch. |
| TF-15 | **T** | For object types, intersection combines all properties into a single type with everything from both. |
| TF-16 | **T** | Both `type Foo = { x: number }` and `interface Foo { x: number }` describe the same object shape. |
| TF-17 | **T** | If you declare `interface Window { myProp: string }`, it merges with the existing `Window` interface. Declaring `type Window = ...` twice is a compile error. |
| TF-18 | **F** | Type aliases can be "extended" using intersection types: `type B = A & { extra: string }`. The syntax differs from `extends`, but the effect is similar. |
| TF-19 | **T** | An optional property `age?: number` means the property may be absent, and if present its value is `number`. The type includes `undefined` because absence and `undefined` are treated the same (without `exactOptionalPropertyTypes`). |
| TF-20 | **T** | `readonly` is shallow. It prevents `obj.prop = newValue` but does not prevent `obj.prop.nested = newValue`. |
| TF-21 | **T** | Index signatures allow open-ended objects. `[key: string]: number` means any string-keyed property must have a `number` value. |
| TF-22 | **T** | TypeScript uses structural (duck) typing. If two types have the same properties and types, they are compatible. |
| TF-23 | **F** | Excess property checking applies only when assigning object literals directly to a typed target. Assigning a pre-existing variable with extra properties does not trigger it. |
| TF-24 | **T** | `typeof` in a type position extracts the compile-time type from a value. The runtime `typeof` operator returns a string like `"string"` or `"number"`. |
| TF-25 | **T** | Truthiness checking (`if (value)`) removes `null`, `undefined`, `0`, `""`, `false`, and `NaN`. This is useful but imprecise — it also eliminates empty strings and zero. |
| TF-26 | **T** | Equality narrowing works on both sides. If `x === y` and `x` is `string | number` and `y` is `string | boolean`, both narrow to `string` inside the block. |
| TF-27 | **T** | The `in` operator checks property existence and narrows the union to whichever member(s) have that property. |
| TF-28 | **T** | `instanceof` checks the prototype chain, which only exists for class instances. It cannot narrow plain object types or interfaces. |
| TF-29 | **F** | Overload signatures are a compile-time feature. There is only one implementation at runtime. The overload signatures define the type-level contract; the implementation body handles all cases. |
| TF-30 | **T** | Rest parameters must come last and are typed as arrays: `function sum(...nums: number[])`. |
| TF-31 | **F** | Type assertions (`as Type`) are compile-time only. They tell TypeScript to treat the value as a different type but produce no runtime code. |
| TF-32 | **T** | The `!` operator removes `null | undefined` from the type with no runtime check. If the value is actually null, you get a runtime error. Use it only when you are certain the value is not null. |

---

### Part B: Short Answer

**SA-1.**
Type inference is TypeScript's ability to determine the type of a variable, return value, or expression from its context without an explicit annotation. When you write `const x = 5`, TypeScript infers `x` as `number` (or the literal `5` for `const`) from the assigned value. This means you only need annotations where inference is insufficient — such as function parameters, which TypeScript cannot infer from usage.

---

**SA-2.**
`a` has type `"hello"` (the string literal type). `b` has type `string`. `const` prevents reassignment, so TypeScript infers the narrowest literal type. `let` allows reassignment, so TypeScript widens to the base type.

---

**SA-3.**
`any` disables type checking entirely — you can perform any operation on an `any` value without error. `unknown` accepts any value but requires you to narrow it (with `typeof`, `instanceof`, a type guard, etc.) before performing operations. Use `unknown` when you genuinely don't know the type but still want type safety — for example, when parsing JSON or handling `catch` blocks.

---

**SA-4.**

```ts
type StringOrNumber = string | number;
```

---

**SA-5.**

```ts
function describe(value: string | number): string {
  if (typeof value === "string") {
    return "string: " + value;
  }
  return "number: " + value;
}
```

The `typeof` check narrows `value` to `string` in the `if` block and to `number` in the `else` branch.

---

**SA-6.**
Excess property checking is a special check that TypeScript performs when you assign an object literal directly to a typed variable. It catches properties that don't exist in the target type. It only triggers on direct object literal assignments, not when assigning a pre-existing variable. In the first case, `{ debug: true, verbose: true }` is a literal assigned to `Config`, so `verbose` is flagged. In the second case, `temp` is already a variable with an inferred type that is structurally compatible with `Config`, so the extra `verbose` property is permitted.

---

**SA-7.**

```ts
interface User {
  name: string;
  email: string;
  age?: number;
}
```

---

**SA-8.**
Declaration merging allows you to declare the same interface name more than once, and TypeScript combines the declarations into a single interface with all properties. Example:

```ts
interface Box {
  width: number;
}
interface Box {
  height: number;
}
// Box now has both width and height
const b: Box = { width: 10, height: 20 };
```

This is not possible with `type` aliases — declaring the same `type` twice is a compile error.

---

**SA-9.**

```ts
function greet(name: string, greeting?: string): string;
```

(A full implementation is also acceptable as long as the signature matches.)

---

**SA-10.**
`readonly` prevents reassigning the property itself (e.g., `point.x = 5` is an error). However, it is shallow: if a `readonly` property holds an object or array, the contents of that nested object can still be mutated. To get deep immutability, you would need `Readonly<T>` applied recursively, or a runtime mechanism like `Object.freeze`.

---

**SA-11.**

```ts
type Dictionary = {
  [key: string]: number;
};
```

(Using an interface with an index signature is also correct.)

---

**SA-12.**
The four main narrowing techniques are:

1. **`typeof` guards** — narrow primitive types (`string`, `number`, `boolean`, etc.)
2. **Truthiness narrowing** — eliminates `null`, `undefined`, and other falsy values in `if (value)` checks
3. **Equality narrowing** — uses `===`, `!==`, `==`, `!=` to narrow by comparing values, including narrowing both sides to their overlap
4. **`in` operator narrowing** — narrows union types based on whether a property exists on the value

(`instanceof` is also covered in the chapter and is an acceptable fifth answer.)

---

**SA-13.**
Inside the `if ("swim" in pet)` block, `pet` is narrowed to `Fish`. The `in` operator checks whether the `"swim"` property exists on `pet`. Since only `Fish` has `swim`, TypeScript narrows the union to `Fish`.

---

**SA-14.**
`void` means the function completes normally but its return value should not be used. `never` means the function never completes — it either always throws or has an infinite loop.

```ts
function log(msg: string): void { console.log(msg); }
function fail(msg: string): never { throw new Error(msg); }
```

---

**SA-15.**
Function overloads let you define multiple type-level signatures for a function that accepts different argument types/counts. Only one implementation body exists, and it must handle all overload cases. The overload signatures are visible to callers; the implementation signature is not directly callable.

```ts
function format(value: string): string;
function format(value: number): string;
function format(value: string | number): string {
  return String(value);
}
```

---

**SA-16.**
Structural typing means TypeScript checks type compatibility based on the shape (properties and their types) of a value, not its declared name. If type `A` has `{ name: string }` and type `B` has `{ name: string }`, they are compatible even though they are different names. This contrasts with nominal typing (used in languages like Java or C#), where two types with identical structures are incompatible unless they share a declared relationship (e.g., inheritance).

---

### Part C: Multiple Choice

| # | Answer | Explanation |
|---|---|---|
| MC-1 | **(b)** | `let` with an array literal infers a general array type: `number[]`. A tuple would require `as const` or an explicit annotation. |
| MC-2 | **(a)** | `"five"` is a `string`, which is not assignable to the `number` parameter. TypeScript catches this at compile time. |
| MC-3 | **(b)** | The function returns either `null` or a `number`, so TypeScript infers `number | null`. |
| MC-4 | **(c)** | After excluding `null` (first branch) and `string` (second branch), only `number` remains. |
| MC-5 | **(d)** | `x is string` is a type predicate used in a function return type, not as a standalone condition. You cannot write `if (x is string)` directly. |
| MC-6 | **(a)** | `readonly` properties produce a compile-time error on reassignment. The check is enforced by TypeScript, not at runtime. |
| MC-7 | **(c)** | Only interfaces support declaration merging. Declaring the same `type` alias twice is a compile error. |
| MC-8 | **(b)** | The `?` makes the property optional: it may be missing from the object entirely. If present, its value is `boolean`. |
| MC-9 | **(a)** | Without `noUncheckedIndexedAccess`, TypeScript trusts the index signature and types the result as `number`. With that flag enabled, it would be `number | undefined`. |
| MC-10 | **(b)** | Intersection of two object types combines all properties. The result has both `name: string` and `age: number`. |
| MC-11 | **(b)** | Mixed-element arrays are inferred as union arrays: `(number | string | boolean)[]`. |
| MC-12 | **(c)** | Truthiness narrowing removes all falsy values: `null`, `undefined`, `""`, `0`, `false`, `NaN`. This means empty strings are also eliminated, which can be a pitfall if empty strings are valid input. |
| MC-13 | **(b)** | Type assertions are compile-time instructions to TypeScript. They produce no runtime code. If the element is not actually a canvas, you'll get a runtime error later. |
| MC-14 | **(b)** | The `!` postfix operator removes `null | undefined` from the type. There is no runtime check. It is a promise to the compiler that you know the value is not null. |
| MC-15 | **(b)** | Overload signatures define the public-facing type contracts. The implementation signature handles all cases in one body. Callers cannot call the implementation signature directly — only the overloads are visible. |
| MC-16 | **(b)** | TypeScript infers the return type from the returned object literal: `{ first: number; second: string }`. |