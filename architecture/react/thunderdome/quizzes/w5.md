# Week 5 Quiz: React Rendering Model and React Compiler

**Scope:** Rendering pipeline (trigger/render/commit), Rules of React, React Compiler setup and automatic memoization, manual memoization as escape hatch, React DevTools Profiler, React.lazy and code splitting with Suspense.

**Scoring:** Wrong answers on T/F and MC are subtracted from right answers. Do not guess.

---

## Part A: True / False (32 Questions)

---

**TF-1.** React's rendering pipeline consists of three phases: trigger, render, and commit.

**TF-2.** The trigger phase occurs when a component's state changes, a parent re-renders, or a consumed Context value changes.

**TF-3.** During the render phase, React calls your component functions and computes a diff against the previous virtual DOM tree.

**TF-4.** The render phase modifies the actual DOM directly.

**TF-5.** The commit phase is when React applies the computed changes to the real DOM.

**TF-6.** After the commit phase, the browser paints the updated UI to the screen.

**TF-7.** A component only re-renders when its own props change; parent re-renders do not affect children.

**TF-8.** By default, when a parent component re-renders, all of its children re-render too, even if their props haven't changed.

**TF-9.** React preserves a component's state between re-renders as long as it appears at the same position in the tree with the same type.

**TF-10.** Changing a component's `key` prop forces React to destroy the old instance and create a new one with fresh state.

**TF-11.** Two components of different types at the same position share state between renders.

**TF-12.** The React Compiler was stabilized at v1.0 in October 2025 and automatically memoizes components and hooks at build time.

**TF-13.** With the React Compiler enabled, `React.memo`, `useMemo`, and `useCallback` are the primary performance optimization tools.

**TF-14.** Manual memoization (`React.memo`, `useMemo`, `useCallback`) is an escape hatch when the React Compiler is active, not a default practice.

**TF-15.** The Rules of React include: components must be pure (same inputs produce same output), and hooks must be called at the top level.

**TF-16.** Side effects during the render phase are acceptable as long as they are fast.

**TF-17.** Side effects belong in event handlers or `useEffect`, not in the render function body.

**TF-18.** The React Compiler relies on your code following the Rules of React. Violating them may cause incorrect memoization or bugs.

**TF-19.** `React.memo` is a higher-order component that skips re-rendering when props are shallowly equal.

**TF-20.** `useMemo` caches the result of an expensive computation between renders, recomputing only when its dependencies change.

**TF-21.** `useCallback` caches a function reference between renders, recomputing only when its dependencies change.

**TF-22.** You should wrap every component in `React.memo` and every function in `useCallback` as a best practice.

**TF-23.** Before adding manual memoization, you should use the React DevTools Profiler to confirm a performance bottleneck actually exists.

**TF-24.** `React.lazy` enables code splitting by dynamically importing a component so it is loaded only when first rendered.

**TF-25.** `React.lazy` requires a `Suspense` boundary ancestor to display a fallback while the lazy component loads.

**TF-26.** `Suspense` can wrap multiple lazy-loaded components, showing one fallback for all of them.

**TF-27.** Code splitting with `React.lazy` reduces the initial bundle size by deferring loading of infrequently used components.

**TF-28.** The React DevTools Profiler records rendering performance and shows which components rendered and how long each took.

**TF-29.** The Profiler's "Highlight updates" feature visually shows which components re-rendered on each update.

**TF-30.** A pure component function always returns the same output given the same props and state, with no observable side effects.

**TF-31.** Reading from and writing to a mutable variable outside the component during rendering is a violation of the Rules of React.

**TF-32.** Rendering must be idempotent: calling a component function multiple times with the same inputs should produce the same result.

---

## Part B: Short Answer (16 Questions)

---

**SA-1.** Describe the three phases of React's rendering pipeline. What happens in each?

---

**SA-2.** Explain what it means for a component to be "pure" in React's terms. Give an example of an impure component and explain why it violates the rules.

---

**SA-3.** What happens to a component's state when its parent re-renders? What about when the component's `key` changes?

---

**SA-4.** Two `<Counter />` components are rendered conditionally at the same position:

```tsx
{isA ? <Counter label="A" /> : <Counter label="B" />}
```

Does switching between A and B reset the counter's state? Why or why not? How would you force a reset?

---

**SA-5.** What is the React Compiler, and how does it change the way you think about performance optimization in React?

---

**SA-6.** What are the Rules of React that the Compiler relies on? List at least three.

---

**SA-7.** When would you still use `React.memo` manually in a project with the React Compiler enabled?

---

**SA-8.** Explain what `useMemo` does. Write a short example of a legitimate use case (not just wrapping every computation).

---

**SA-9.** Explain what `useCallback` does and why it was important before the React Compiler. Why is it less necessary now?

---

**SA-10.** How does `React.lazy` work? Write the code to lazy-load a `Dashboard` component with a Suspense fallback.

---

**SA-11.** What are the benefits and tradeoffs of code splitting? When should you split and when is it not worth it?

---

**SA-12.** Describe how you would use the React DevTools Profiler to identify a performance problem. What would you look for?

---

**SA-13.** A developer wraps every component in `React.memo` and every callback in `useCallback`. What is wrong with this approach?

---

**SA-14.** Explain the difference between the "render" phase and the "commit" phase. Can React abort a render before committing?

---

**SA-15.** What is "reconciliation" in React? How does it relate to the render phase?

---

**SA-16.** A component renders a large list, and scrolling is janky. Walk through the diagnostic steps you would take before adding any optimization code.

---

## Part C: Multiple Choice (16 Questions)

---

**MC-1.** What are React's three rendering phases, in order?

(a) Mount, Update, Unmount
(b) Trigger, Render, Commit
(c) Parse, Diff, Patch
(d) Create, Compare, Apply

---

**MC-2.** Which of the following causes a component to re-render?

(a) Its own state changes
(b) Its parent re-renders
(c) A consumed Context value changes
(d) All of the above

---

**MC-3.** What does the `key` prop control?

(a) CSS styling priority
(b) Component identity for reconciliation — changing `key` resets state
(c) Rendering order of sibling elements
(d) Performance optimization level

---

**MC-4.** What is the primary role of `React.memo` when the React Compiler is active?

(a) The default optimization for every component
(b) An escape hatch for edge cases where the Compiler's memoization is insufficient
(c) It replaces the Compiler entirely
(d) It has no effect

---

**MC-5.** Which is NOT a Rule of React?

(a) Components must be pure functions
(b) Hooks must be called at the top level
(c) All components must be wrapped in `React.memo`
(d) Side effects must not occur during rendering

---

**MC-6.** What does the render phase produce?

(a) Updated DOM nodes
(b) A description of what the UI should look like (virtual DOM / React elements) and a diff against the previous tree
(c) JavaScript bytecode
(d) CSS styles

---

**MC-7.** When does the commit phase update the DOM?

(a) Asynchronously, after the next animation frame
(b) Synchronously, after the render phase completes
(c) Only when the user scrolls
(d) Never — React uses a shadow DOM

---

**MC-8.** What does `React.lazy(() => import("./Settings"))` do?

(a) Eagerly loads the Settings component at build time
(b) Dynamically imports the Settings component only when it is first rendered
(c) Disables type checking for the Settings component
(d) Creates a web worker for the Settings component

---

**MC-9.** What must wrap a `React.lazy` component to handle the loading state?

(a) `React.Fragment`
(b) `React.Suspense` with a `fallback` prop
(c) `React.StrictMode`
(d) `ErrorBoundary`

---

**MC-10.** Before adding `useMemo` to optimize an expensive computation, what should you do first?

(a) Add it to every `useMemo`-eligible value
(b) Verify there is a measurable performance problem using the React DevTools Profiler
(c) Convert the component to a class
(d) Move the computation to a web worker

---

**MC-11.** What does `useMemo(() => expensiveComputation(data), [data])` do?

(a) Caches `data` between renders
(b) Caches the result of `expensiveComputation(data)` and only recomputes when `data` changes
(c) Runs `expensiveComputation` on every render regardless
(d) Moves the computation to a background thread

---

**MC-12.** What does `useCallback(fn, [deps])` cache?

(a) The return value of `fn`
(b) The function reference `fn` itself, creating a new reference only when `deps` change
(c) The arguments passed to `fn`
(d) The DOM nodes produced by `fn`

---

**MC-13.** A component renders the same output for the same props. The React Compiler is enabled. Should you add `React.memo`?

(a) Yes, always add `React.memo` for safety
(b) No — the Compiler handles this automatically. Only add `React.memo` if the Profiler shows a problem the Compiler isn't solving.
(c) Only if the component uses hooks
(d) Only if the component has children

---

**MC-14.** What does React do when it encounters two different component types at the same tree position?

(a) Preserves state and re-renders with new props
(b) Destroys the old component and mounts the new one with fresh state
(c) Merges the two components
(d) Throws an error

---

**MC-15.** What does the Profiler's flamegraph show?

(a) Network requests
(b) Which components rendered, how long each took, and what caused the render
(c) Memory allocation
(d) Bundle size breakdown

---

**MC-16.** A component reads `window.scrollY` during render and uses it to set a className. Is this a violation of the Rules of React?

(a) No — reading `window.scrollY` is a pure operation
(b) Yes — reading a mutable external value during render breaks purity because the result changes between calls with the same props/state
(c) Only if it also writes to `window`
(d) Only in strict mode

---

---

## Answer Key

### Part A: True / False

| # | Answer | Explanation |
|---|---|---|
| TF-1 | **T** | The three phases are trigger, render, and commit. |
| TF-2 | **T** | All three cause a re-render trigger. |
| TF-3 | **T** | The render phase is pure computation: call components, build element tree, diff. |
| TF-4 | **F** | The render phase does NOT touch the DOM. DOM changes happen in the commit phase. |
| TF-5 | **T** | Commit applies the minimal DOM changes. |
| TF-6 | **T** | The browser paints after React commits DOM changes. |
| TF-7 | **F** | Parent re-renders cause children to re-render by default, regardless of prop changes. |
| TF-8 | **T** | This is React's default behavior. The Compiler mitigates it via automatic memoization. |
| TF-9 | **T** | Same type + same position = preserved state. |
| TF-10 | **T** | Changing `key` tells React to treat it as a new instance. |
| TF-11 | **F** | Different types at the same position cause React to destroy the old tree and mount a new one. State is lost. |
| TF-12 | **T** | The Compiler is stable and performs automatic memoization at build time. |
| TF-13 | **F** | With the Compiler, manual memoization is an escape hatch, not the primary tool. |
| TF-14 | **T** | Correct — manual memo is for edge cases the Compiler cannot handle. |
| TF-15 | **T** | Purity and top-level hook calls are core rules. |
| TF-16 | **F** | Side effects during rendering violate purity. They must go in effects or event handlers. |
| TF-17 | **T** | This is correct placement for side effects. |
| TF-18 | **T** | The Compiler assumes rule compliance to safely apply optimizations. |
| TF-19 | **T** | `React.memo` wraps a component and skips re-rendering on shallow-equal props. |
| TF-20 | **T** | `useMemo` caches computation results based on dependencies. |
| TF-21 | **T** | `useCallback` caches function references based on dependencies. |
| TF-22 | **F** | This is over-optimization. With the Compiler, it's unnecessary. Even without it, profile first. |
| TF-23 | **T** | Always measure before optimizing. |
| TF-24 | **T** | `React.lazy` defers component loading via dynamic `import()`. |
| TF-25 | **T** | Without `Suspense`, React has no fallback to show while loading. |
| TF-26 | **T** | A single `Suspense` boundary can wrap multiple lazy components. |
| TF-27 | **T** | Code splitting reduces initial load by deferring rarely-used code. |
| TF-28 | **T** | The Profiler records render timings and trigger reasons. |
| TF-29 | **T** | Highlight updates shows visual indicators on re-rendered components. |
| TF-30 | **T** | Purity: same inputs, same output, no side effects. |
| TF-31 | **T** | Reading or writing mutable external state during render is impure. |
| TF-32 | **T** | Idempotency is a requirement for the Compiler to safely skip redundant renders. |

### Part B: Short Answer

**SA-1.** **Trigger:** A state change, initial mount, or Context change schedules a render. **Render:** React calls component functions, builds the new element tree, and diffs it against the previous tree. No DOM changes occur. **Commit:** React applies the minimal set of DOM mutations from the diff to the real DOM. The browser then paints.

**SA-2.** A pure component returns the same output for the same props/state with no side effects. Impure example: `function Counter() { window.count++; return <p>{window.count}</p>; }` — this reads and writes a mutable external variable during render, producing different results on repeated calls.

**SA-3.** When a parent re-renders, children re-render but their state is preserved (same type, same position). When `key` changes, React destroys the old instance and creates a new one — all state is reset.

**SA-4.** No, switching does NOT reset state. Both are `<Counter />` at the same position with the same type — React treats them as the same instance and preserves state, only updating the `label` prop. To force a reset, add a `key`: `{isA ? <Counter key="A" label="A" /> : <Counter key="B" label="B" />}`.

**SA-5.** The React Compiler (v1.0, Oct 2025) is a build-time tool that analyzes your components and automatically inserts memoization. It means you no longer need to manually wrap components in `React.memo` or computations in `useMemo`/`useCallback` as a default practice. You think about correctness (following the Rules of React) and the Compiler handles performance.

**SA-6.** (1) Components must be pure functions — same inputs produce same output. (2) Hooks must be called at the top level, not inside conditions, loops, or nested functions. (3) Side effects must not occur during rendering — they belong in effects or event handlers. (4) Props and state must be treated as immutable.

**SA-7.** When the Profiler shows a specific component is still a performance bottleneck that the Compiler hasn't addressed — for example, a component that receives a new object reference on every parent render due to an unavoidable pattern. This should be rare.

**SA-8.** `useMemo` caches a computed value: `const sorted = useMemo(() => items.sort(compareFn), [items])`. Legitimate use: an expensive sort/filter on a large array where `items` rarely changes but the component re-renders frequently for other reasons. With the Compiler active, this is usually unnecessary.

**SA-9.** `useCallback` caches a function reference so that children receiving it as a prop don't see a new reference on every render. Before the Compiler, this was needed to prevent unnecessary child re-renders. Now the Compiler handles reference stability automatically, making `useCallback` largely unnecessary.

**SA-10.** `React.lazy` wraps a dynamic `import()` call: `const Dashboard = React.lazy(() => import("./Dashboard"));`. Usage: `<Suspense fallback={<p>Loading...</p>}><Dashboard /></Suspense>`. The import runs only when `Dashboard` first renders. `Suspense` shows the fallback while loading.

**SA-11.** Benefits: smaller initial bundle, faster first load, better resource utilization. Tradeoffs: adds loading latency when the split chunk is first needed, increases complexity. Split routes and heavy features users might not visit. Don't split small components or frequently-used code.

**SA-12.** Open DevTools Profiler, click Record, perform the slow interaction, stop recording. Look at the flamegraph for: which components rendered, how long each took, what triggered the render (state change, parent re-render, Context change). Focus on components that took the longest or re-rendered unnecessarily.

**SA-13.** Wrapping everything adds visual noise, makes code harder to read, and provides minimal benefit with the Compiler active. Without the Compiler, it's still usually premature optimization — you should profile first and memo only the bottlenecks.

**SA-14.** The render phase is pure computation — React calls components and builds the virtual tree diff. It does not touch the DOM. The commit phase applies the diff to the real DOM. React can abort or restart a render (in concurrent mode) before committing.

**SA-15.** Reconciliation is the process by which React compares the new element tree with the previous one to determine the minimal set of DOM changes needed. It happens during the render phase. React uses heuristics like component type and `key` props to efficiently match old and new elements.

**SA-16.** (1) Open Profiler, record the scroll interaction. (2) Identify which components re-render during scroll and how long they take. (3) Check if the list renders all items or only visible ones (consider virtualization). (4) Check if expensive computations happen during render that could be moved or cached. (5) Only after identifying the specific bottleneck, apply targeted optimization (virtualization, memoization, or restructuring).

### Part C: Multiple Choice

| # | Answer | Explanation |
|---|---|---|
| MC-1 | **(b)** | Trigger, Render, Commit. |
| MC-2 | **(d)** | All three cause re-renders. |
| MC-3 | **(b)** | `key` controls component identity; changing it resets state. |
| MC-4 | **(b)** | Escape hatch, not default. |
| MC-5 | **(c)** | `React.memo` is not a Rule of React. |
| MC-6 | **(b)** | The render phase produces a virtual DOM diff. |
| MC-7 | **(b)** | Commit updates the DOM synchronously after render. |
| MC-8 | **(b)** | `React.lazy` dynamically imports on first render. |
| MC-9 | **(b)** | `Suspense` with `fallback` handles the loading state. |
| MC-10 | **(b)** | Profile first, optimize only confirmed bottlenecks. |
| MC-11 | **(b)** | Caches the result, recomputes when `data` changes. |
| MC-12 | **(b)** | Caches the function reference, not its return value. |
| MC-13 | **(b)** | The Compiler handles it. Only add `React.memo` if the Profiler shows a problem. |
| MC-14 | **(b)** | Different types at the same position destroy old and mount new. |
| MC-15 | **(b)** | Flamegraph shows render timings, components, and triggers. |
| MC-16 | **(b)** | Reading `window.scrollY` during render is impure — the value changes between calls with the same props/state. |
