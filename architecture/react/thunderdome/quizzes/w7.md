# Week 7 Quiz: Hooks in Depth

**Scope:** useRef (DOM refs and mutable values), useImperativeHandle, useLayoutEffect, custom hook design, race conditions, stale closures, effect dependencies, cleanup functions, "You Might Not Need an Effect."

**Scoring:** Wrong answers on T/F and MC are subtracted from right answers. Do not guess.

---

## Part A: True / False (32 Questions)

---

**TF-1.** `useRef` returns a mutable object `{ current: T }` that persists for the full lifetime of the component.

**TF-2.** Mutating `ref.current` causes the component to re-render.

**TF-3.** `useRef` can be used for two purposes: holding DOM element references and storing mutable values that don't trigger re-renders.

**TF-4.** `useRef<HTMLInputElement>(null)` returns a ref where `current` is typed as `HTMLInputElement | null`.

**TF-5.** You should read or write `ref.current` during the render phase because refs are always up to date.

**TF-6.** Reading or writing `ref.current` during rendering is generally unsafe because it can break the React Compiler's assumptions about purity.

**TF-7.** `useImperativeHandle` is the recommended way for every component to expose methods to parent components.

**TF-8.** `useImperativeHandle` should be used sparingly — only when a parent genuinely needs to call imperative methods on a child.

**TF-9.** `useLayoutEffect` fires asynchronously after the browser paints, just like `useEffect`.

**TF-10.** `useLayoutEffect` fires synchronously after DOM mutations but before the browser paints.

**TF-11.** `useLayoutEffect` is appropriate for measuring DOM elements (e.g., getting bounding rect) before the user sees the result.

**TF-12.** `useEffect` fires after the browser has painted, making it suitable for most side effects that don't need to block the paint.

**TF-13.** The dependency array of `useEffect` determines when the effect re-runs: the effect fires only when a dependency value has changed.

**TF-14.** Omitting the dependency array entirely causes the effect to run only on mount.

**TF-15.** An empty dependency array `[]` means the effect runs after every render.

**TF-16.** The cleanup function of `useEffect` runs before the effect re-executes and when the component unmounts.

**TF-17.** A stale closure occurs when a function captures a variable from a previous render's scope and uses the outdated value.

**TF-18.** The functional updater form of `setState` (e.g., `setCount(c => c + 1)`) avoids stale closures because it receives the current state as an argument.

**TF-19.** The `exhaustive-deps` ESLint rule warns when a reactive value used inside an effect is missing from the dependency array.

**TF-20.** It is safe to suppress `exhaustive-deps` warnings as long as the code works in development.

**TF-21.** A race condition in effects can occur when multiple async operations are in flight and an earlier one completes after a later one.

**TF-22.** The cleanup-flag pattern (`let ignore = false; return () => { ignore = true; }`) prevents stale async results from being applied.

**TF-23.** Custom hooks must begin with the `use` prefix for React to enforce the Rules of Hooks.

**TF-24.** Custom hooks can call other hooks, but regular functions that don't start with `use` cannot call hooks.

**TF-25.** A well-designed custom hook hides implementation details and provides a clean, focused return value.

**TF-26.** Custom hooks must always return an array tuple, never an object.

**TF-27.** "You Might Not Need an Effect" argues that many uses of `useEffect` can be replaced by computing values during render, handling logic in event handlers, or using initializer functions.

**TF-28.** Using `useEffect` to synchronize state with a prop change is always the correct approach.

**TF-29.** Fetching data in `useEffect` is a valid use case, though TanStack Query (Week 14) provides a better abstraction.

**TF-30.** An effect that subscribes to a browser API (e.g., `window.addEventListener`) should always return a cleanup function that unsubscribes.

**TF-31.** Each render has its own "snapshot" of state and props, which is why closures inside event handlers and effects capture values from that specific render.

**TF-32.** The "lifecycle of reactive effects" concept means effects synchronize with external systems, not with component lifecycle events like "mount" and "unmount."

---

## Part B: Short Answer (16 Questions)

---

**SA-1.** Explain the two distinct use cases of `useRef`. Write a short example of each.

---

**SA-2.** Why does mutating `ref.current` NOT cause a re-render? How does this differ from calling a state setter?

---

**SA-3.** Explain the timing difference between `useEffect` and `useLayoutEffect`. When should you use `useLayoutEffect`?

---

**SA-4.** What is `useImperativeHandle`? Write a minimal example of a component that uses `forwardRef` and `useImperativeHandle` to expose a `focus()` method to its parent.

---

**SA-5.** What is a stale closure in React? Write a `useEffect` that has a stale closure bug, and show how to fix it.

---

**SA-6.** Explain the `exhaustive-deps` lint rule. Why is it dangerous to suppress its warnings?

---

**SA-7.** Describe the race condition pattern with async operations in `useEffect`. Write the cleanup-flag solution.

---

**SA-8.** What is the purpose of the cleanup function returned by `useEffect`? When does it run?

---

**SA-9.** Name two anti-patterns from "You Might Not Need an Effect" and explain the correct alternative for each.

---

**SA-10.** Write a custom hook `useWindowSize()` that returns `{ width: number; height: number }` and updates when the window is resized. Include proper cleanup.

---

**SA-11.** Write a custom hook `usePrevious<T>(value: T): T | undefined` that returns the value from the previous render.

---

**SA-12.** Explain what "effects synchronize with external systems" means. How is this different from thinking about effects as "mount/unmount" lifecycle callbacks?

---

**SA-13.** A developer writes an effect with `setInterval` that uses `count` in the callback but only has `[]` as dependencies. The counter increments once and stops. Explain the bug and two possible fixes.

---

**SA-14.** When should a custom hook return a tuple `[value, setter]` versus an object `{ value, setter }`? What are the tradeoffs?

---

**SA-15.** An effect fetches user data when `userId` changes. The developer forgets the cleanup. What can go wrong if the user navigates quickly between profiles?

---

**SA-16.** A component measures a tooltip's position using `getBoundingClientRect()` in a `useEffect`. Users report a brief visual flash where the tooltip appears in the wrong position. Diagnose the problem and fix it.

---

## Part C: Multiple Choice (16 Questions)

---

**MC-1.** What does `useRef` return?

(a) A state variable that triggers re-renders
(b) A mutable object `{ current: T }` that persists across renders without triggering re-renders
(c) A DOM element directly
(d) An immutable snapshot of the current value

---

**MC-2.** What happens when you mutate `ref.current`?

(a) The component re-renders
(b) The value changes but no re-render occurs
(c) React throws an error
(d) The ref is reset to its initial value

---

**MC-3.** When does `useLayoutEffect` fire?

(a) Before the render phase
(b) After the browser paints
(c) Synchronously after DOM mutations, before the browser paints
(d) Asynchronously after all effects

---

**MC-4.** When should you use `useLayoutEffect` instead of `useEffect`?

(a) For all side effects
(b) When you need to measure or mutate the DOM before the browser paints, to prevent visual flashes
(c) When fetching data
(d) When setting up event listeners

---

**MC-5.** What does `useImperativeHandle` do?

(a) Automatically exposes all component state to parents
(b) Customizes the instance value exposed to parents via `forwardRef`
(c) Creates an imperative API for all hooks
(d) Replaces `useRef` for DOM access

---

**MC-6.** What does an empty dependency array `[]` on `useEffect` mean?

(a) The effect runs after every render
(b) The effect runs once after the initial render, and cleanup runs on unmount
(c) The effect never runs
(d) The dependency array is ignored

---

**MC-7.** What does omitting the dependency array entirely mean?

(a) The effect runs once on mount
(b) The effect runs after every render
(c) The effect runs only when state changes
(d) It is equivalent to `[]`

---

**MC-8.** What is a stale closure?

(a) A function that was garbage collected
(b) A function that captures a variable from a previous render and uses the outdated value
(c) A function that runs too slowly
(d) A memory leak from an uncleaned effect

---

**MC-9.** How does the functional updater form `setCount(c => c + 1)` help avoid stale closures?

(a) It forces a re-render
(b) It receives the current state as an argument, so it doesn't depend on the closed-over variable
(c) It runs synchronously
(d) It bypasses the dependency array

---

**MC-10.** What does the cleanup function of `useEffect` do?

(a) Cancels the effect before it runs
(b) Runs before the effect re-executes on subsequent renders and when the component unmounts
(c) Returns a value from the effect
(d) Prevents the component from re-rendering

---

**MC-11.** How do you prevent a race condition when fetching data in `useEffect`?

(a) Use `async/await` without any cleanup
(b) Set an `ignore` flag in the cleanup function so that stale responses are discarded
(c) Call `fetch` outside of `useEffect`
(d) Use `setTimeout` to delay the fetch

---

**MC-12.** Which is an anti-pattern described in "You Might Not Need an Effect"?

(a) Using `useEffect` to subscribe to an external event source
(b) Using `useEffect` to compute derived values that could be calculated during render
(c) Using `useEffect` for data fetching
(d) Using `useEffect` to set up a WebSocket connection

---

**MC-13.** A custom hook must start with `use` because:

(a) It is a naming convention with no enforcement
(b) React and its linter use the prefix to enforce the Rules of Hooks and the Compiler recognizes it
(c) The prefix enables special runtime optimizations
(d) It prevents name collisions

---

**MC-14.** What is the return type of `usePrevious<T>(value: T)`?

(a) `T`
(b) `T | undefined`
(c) `React.RefObject<T>`
(d) `[T, T]`

---

**MC-15.** A `useEffect` subscribes to `window.addEventListener("resize", handler)`. What is missing?

(a) Nothing — this is correct
(b) A cleanup function: `return () => window.removeEventListener("resize", handler)`
(c) A `try/catch` block
(d) A `useCallback` wrapper for `handler`

---

**MC-16.** A tooltip flickers into the wrong position before snapping to the correct one. The position is measured in `useEffect`. What is the fix?

(a) Add `React.memo` to the tooltip
(b) Use `useLayoutEffect` instead, so the measurement and position update happen before the browser paints
(c) Use `setTimeout` to delay the measurement
(d) Use a CSS transition to hide the flash

---

---

## Answer Key

### Part A: True / False

| # | Answer | Explanation |
|---|---|---|
| TF-1 | **T** | `useRef` returns `{ current }` that persists for the component's lifetime. |
| TF-2 | **F** | Mutating `ref.current` does NOT cause a re-render. This is the key difference from state. |
| TF-3 | **T** | DOM references and mutable values (interval IDs, previous values, etc.) are the two uses. |
| TF-4 | **T** | The initial `null` means `current` includes `null` in its type. |
| TF-5 | **F** | Reading/writing refs during render can break purity. Access refs in effects or event handlers. |
| TF-6 | **T** | The Compiler assumes render is pure. Ref mutations during render violate this. |
| TF-7 | **F** | `useImperativeHandle` should be used sparingly — it's for rare cases where imperative parent access is genuinely needed. |
| TF-8 | **T** | The React docs explicitly say to use it sparingly. |
| TF-9 | **F** | `useLayoutEffect` fires synchronously before the paint, not after like `useEffect`. |
| TF-10 | **T** | This is the defining characteristic of `useLayoutEffect`. |
| TF-11 | **T** | Measuring layout before paint avoids visual flashes. |
| TF-12 | **T** | `useEffect` fires after the browser paints. |
| TF-13 | **T** | Dependencies control when the effect re-runs. |
| TF-14 | **F** | Omitting the dependency array causes the effect to run after every render, not just mount. |
| TF-15 | **F** | `[]` means run once on mount, not every render. (TF-14 and TF-15 are a trap pair.) |
| TF-16 | **T** | Cleanup runs before re-execution and on unmount. |
| TF-17 | **T** | Stale closures capture old render values. |
| TF-18 | **T** | The updater function receives current state directly, bypassing the closure. |
| TF-19 | **T** | The lint rule catches missing dependencies that could cause stale closures. |
| TF-20 | **F** | Suppressing the warning often masks stale closure bugs that surface in production. |
| TF-21 | **T** | The classic race condition: response A arrives after response B but was initiated first. |
| TF-22 | **T** | The cleanup sets `ignore = true` before the next effect, discarding stale responses. |
| TF-23 | **T** | The `use` prefix is required for Rules of Hooks enforcement and Compiler recognition. |
| TF-24 | **T** | Only hooks and components may call hooks. |
| TF-25 | **T** | Good hook API design hides complexity and exposes a focused interface. |
| TF-26 | **F** | Custom hooks can return tuples, objects, single values, or nothing. Objects are often more ergonomic. |
| TF-27 | **T** | Many effects should be replaced with simpler patterns. |
| TF-28 | **F** | Often you can use the prop directly, use `key` to reset, or compute during render instead. |
| TF-29 | **T** | `useEffect` for fetching works but is error-prone. TanStack Query is better for production. |
| TF-30 | **T** | Always clean up subscriptions to prevent memory leaks and stale handlers. |
| TF-31 | **T** | Each render's closures capture that render's state and props. |
| TF-32 | **T** | Effects synchronize with external systems (network, DOM, timers). They are not lifecycle callbacks. |

### Part B: Short Answer

**SA-1.** (1) **DOM reference:** `const inputRef = useRef<HTMLInputElement>(null)` — used with `ref={inputRef}` to call `inputRef.current?.focus()`. (2) **Mutable value:** `const intervalRef = useRef<number | null>(null)` — stores an interval ID that persists across renders: `intervalRef.current = setInterval(...)` with cleanup `clearInterval(intervalRef.current)`. Neither use triggers re-renders.

**SA-2.** `ref.current` is a plain mutable property on a persistent object. React does not track changes to it. State setters enqueue a re-render through React's scheduling system. Refs are for values that need to persist but don't affect what's rendered.

**SA-3.** `useEffect` fires after the browser paints — the user may briefly see an intermediate state. `useLayoutEffect` fires synchronously after DOM mutations but before the paint. Use `useLayoutEffect` when you need to measure the DOM (e.g., `getBoundingClientRect`) or mutate it before the user sees the result, to prevent visual flashes.

**SA-4.**
```tsx
const FancyInput = forwardRef<{ focus: () => void }, { placeholder: string }>(
  ({ placeholder }, ref) => {
    const inputRef = useRef<HTMLInputElement>(null);
    useImperativeHandle(ref, () => ({
      focus: () => inputRef.current?.focus(),
    }));
    return <input ref={inputRef} placeholder={placeholder} />;
  }
);
// Parent: const ref = useRef(null); ref.current?.focus();
```

**SA-5.** A stale closure captures an old render's value:
```ts
useEffect(() => {
  const id = setInterval(() => {
    setCount(count + 1); // stale: count is always 0
  }, 1000);
  return () => clearInterval(id);
}, []); // count missing from deps
```
Fix: `setCount(c => c + 1)` — the updater receives current state, bypassing the stale closure.

**SA-6.** `exhaustive-deps` checks that all reactive values read inside an effect are listed in the dependency array. Suppressing it often hides stale closure bugs — the effect reads an old value and produces incorrect behavior. If the lint rule says a dependency is missing, the correct fix is to include it or restructure the effect, not suppress the warning.

**SA-7.** If `userId` changes rapidly, multiple fetches run concurrently. An older fetch may resolve after a newer one, overwriting correct data with stale data.
```ts
useEffect(() => {
  let ignore = false;
  async function fetchUser() {
    const res = await fetch(`/api/users/${userId}`);
    const data = await res.json();
    if (!ignore) setUser(data);
  }
  fetchUser();
  return () => { ignore = true; };
}, [userId]);
```

**SA-8.** The cleanup function tears down the previous effect: unsubscribes event listeners, clears timers, cancels requests. It runs (1) before the effect re-executes when dependencies change, and (2) when the component unmounts.

**SA-9.** (1) **Deriving computed values in an effect:** Using `useEffect` to filter a list and store it in state. Correct: compute during render `const filtered = items.filter(...)`. (2) **Responding to events in an effect:** Using `useEffect` to react to a state change triggered by a button click. Correct: put the logic in the `onClick` handler directly.

**SA-10.**
```ts
function useWindowSize() {
  const [size, setSize] = useState({ width: window.innerWidth, height: window.innerHeight });
  useEffect(() => {
    const handler = () => setSize({ width: window.innerWidth, height: window.innerHeight });
    window.addEventListener("resize", handler);
    return () => window.removeEventListener("resize", handler);
  }, []);
  return size;
}
```

**SA-11.**
```ts
function usePrevious<T>(value: T): T | undefined {
  const ref = useRef<T | undefined>(undefined);
  useEffect(() => {
    ref.current = value;
  });
  return ref.current;
}
```
The ref holds the value from the previous render because `useEffect` runs after render, updating the ref for the next render to read.

**SA-12.** Effects don't map to component lifecycle (mount/update/unmount). They synchronize your component with an external system (network, DOM API, timer, third-party library). Each effect has a setup and cleanup that form a pair. When dependencies change, React cleans up the old synchronization and starts a new one. Thinking in terms of "start syncing / stop syncing" is more correct than "run on mount / clean up on unmount."

**SA-13.** The effect captures the initial `count` (0) in a closure. The interval callback always reads `count = 0`, so `setCount(0 + 1)` sets it to 1 every tick. Fixes: (1) Use the functional updater: `setCount(c => c + 1)`. (2) Add `count` to the dependency array (though this recreates the interval on every tick, which is less efficient).

**SA-14.** **Tuple** `[value, setter]`: follows the `useState` convention, concise destructuring, but positional — renaming requires aliasing. Best for hooks with exactly two elements. **Object** `{ value, setter }`: named properties, easier to destructure selectively, scales better to many return values. Use an object when returning 3+ values or when names aid clarity.

**SA-15.** Without cleanup, if the user navigates from user A to user B, both fetch requests are in flight. If fetch A completes after fetch B, user B's profile is overwritten with user A's data — a race condition. The user sees incorrect data.

**SA-16.** `useEffect` fires after the browser paints, so the tooltip renders in its initial (wrong) position, the user sees it, then the effect measures and repositions it, causing a flash. Fix: use `useLayoutEffect` instead, so the measurement and position update happen before the paint.

### Part C: Multiple Choice

| # | Answer | Explanation |
|---|---|---|
| MC-1 | **(b)** | `useRef` returns a mutable persistent object that doesn't trigger re-renders. |
| MC-2 | **(b)** | The value changes silently — no re-render. |
| MC-3 | **(c)** | Synchronously after DOM mutations, before paint. |
| MC-4 | **(b)** | Layout measurement or mutation before paint to prevent visual flashes. |
| MC-5 | **(b)** | Customizes the ref value exposed to parents via `forwardRef`. |
| MC-6 | **(b)** | Runs once on mount; cleanup runs on unmount. |
| MC-7 | **(b)** | No dependency array = runs after every render. |
| MC-8 | **(b)** | Captures an outdated variable from a previous render. |
| MC-9 | **(b)** | The updater receives current state, avoiding reliance on the closed-over value. |
| MC-10 | **(b)** | Cleanup runs before re-execution and on unmount. |
| MC-11 | **(b)** | The ignore flag in cleanup discards stale responses. |
| MC-12 | **(b)** | Computing derived values in an effect is unnecessary — compute during render. |
| MC-13 | **(b)** | The `use` prefix enables Rules of Hooks enforcement and Compiler recognition. |
| MC-14 | **(b)** | On the first render, there is no previous value, so the return is `undefined`. |
| MC-15 | **(b)** | Must return a cleanup function that removes the listener. |
| MC-16 | **(b)** | `useLayoutEffect` measures and positions before the browser paints, preventing the flash. |
