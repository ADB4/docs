# Week 13 Quiz: Testing Philosophy and Vitest Fundamentals

**Scope:** Why we test, what not to test, the Testing Trophy, Vitest setup and configuration, test lifecycle hooks, basic assertions, `describe`/`it`/`expect` API, watch mode, test environments (`jsdom`, `happy-dom`).

**Assigned Readings:**
- KCD: "Write tests. Not too many. Mostly integration."
- KCD: "Testing Implementation Details"
- Vitest: "Getting Started"
- Vitest: "Features"
- Vitest: "Configuring Vitest"
- Vitest: "Test API Reference" (`describe`, `it`/`test`, `expect`, `beforeEach`, `afterEach`, `beforeAll`, `afterAll`)
- Vitest: "Test Environment" (`node`, `jsdom`, `happy-dom`)

**Scoring:** Wrong answers on T/F and MC are subtracted from right answers. Do not guess. Short answer questions are graded on correctness and conciseness — do not write more than is asked for.

---

## Part A: True / False (72 Questions)

---

**TF-1.** The primary purpose of writing tests is to gain confidence that your software works as expected when users interact with it.

**TF-2.** The Testing Trophy model places end-to-end tests at the base as the most valuable test type.

**TF-3.** In the Testing Trophy, integration tests provide the best balance of confidence and cost.

**TF-4.** Static analysis (TypeScript, ESLint) forms the base of the Testing Trophy because it catches errors with zero runtime cost.

**TF-5.** Unit tests provide higher confidence than integration tests because they test smaller, isolated pieces of code.

**TF-6.** The Testing Trophy differs from the Testing Pyramid by placing more emphasis on integration tests and less on unit tests.

**TF-7.** End-to-end tests are at the top of the Testing Trophy because they are expensive to write and maintain but provide the highest confidence.

**TF-8.** "Write tests. Not too many. Mostly integration." means you should only write integration tests and never write unit tests.

**TF-9.** Testing implementation details means writing tests that assert on internal component state, private methods, or the specific way something is built rather than how it behaves.

**TF-10.** A test that breaks when you refactor the implementation but the behavior stays the same is a sign that the test is testing implementation details.

**TF-11.** A test that continues to pass when you break the behavior it is supposed to verify is a false positive.

**TF-12.** Tests that test implementation details give you false confidence: they can pass even when the behavior is broken, or fail even when the behavior is correct.

**TF-13.** The ideal test should break when the application behavior changes and remain green when the implementation is refactored.

**TF-14.** Vitest is a standalone test framework that requires webpack to run.

**TF-15.** Vitest reuses your Vite configuration, including plugins and resolve aliases, by default.

**TF-16.** Vitest can read its configuration from a `test` key inside `vite.config.ts` or from a separate `vitest.config.ts` file.

**TF-17.** Vitest requires a separate TypeScript compilation step before running tests because it cannot process `.ts` files natively.

**TF-18.** Vitest transforms TypeScript files using esbuild by default, the same way Vite does in development.

**TF-19.** Vitest watch mode re-runs only the tests affected by a file change, not the entire test suite.

**TF-20.** Vitest is API-compatible with Jest, meaning most `expect` matchers and lifecycle hooks have the same names and signatures.

**TF-21.** The `describe` function in Vitest creates a test suite — a logical grouping of related tests.

**TF-22.** `it` and `test` in Vitest are different functions with different behavior.

**TF-23.** A test written with `it("should add two numbers", ...)` behaves identically to one written with `test("should add two numbers", ...)`.

**TF-24.** `expect(value).toBe(other)` uses `===` for comparison, meaning it checks referential equality for objects.

**TF-25.** `expect(value).toEqual(other)` performs a deep equality check, recursively comparing object properties and array elements.

**TF-26.** `expect(value).toBe(other)` is the correct matcher for comparing the contents of two separate objects with the same shape.

**TF-27.** `expect(value).toBeTruthy()` passes for any value that would be truthy in JavaScript, including `1`, `"hello"`, `[]`, and `{}`.

**TF-28.** `expect(value).toBeNull()` is equivalent to `expect(value).toBe(null)`.

**TF-29.** `expect(value).toBeUndefined()` will pass for a variable that has been declared but not assigned a value.

**TF-30.** `expect(() => fn()).toThrow()` checks that calling `fn()` throws an error. You must wrap the call in a function to catch the throw.

**TF-31.** If you write `expect(fn()).toThrow()` without wrapping `fn()` in an arrow function, the error is thrown before `expect` can catch it.

**TF-32.** `expect(value).toContain(item)` works for both arrays (checking element membership) and strings (checking substring presence).

**TF-33.** `expect(value).toHaveLength(n)` works on any value that has a `.length` property, including strings and arrays.

**TF-34.** `beforeEach` runs once before all tests in the enclosing `describe` block.

**TF-35.** `beforeEach` runs before each individual test inside the enclosing `describe` block, providing fresh setup for every test.

**TF-36.** `afterEach` is commonly used for cleanup tasks such as resetting mocks or clearing shared state between tests.

**TF-37.** `beforeAll` runs once before any test in the `describe` block and is useful for expensive setup that does not need to be repeated for each test.

**TF-38.** `afterAll` runs after every individual test, not just once at the end.

**TF-39.** Lifecycle hooks defined outside of any `describe` block apply to every test in the file.

**TF-40.** Nested `describe` blocks inherit `beforeEach` hooks from their parent `describe` blocks.

**TF-41.** If a `beforeEach` is defined in an outer `describe` and another `beforeEach` in an inner `describe`, the outer runs first, then the inner.

**TF-42.** You cannot nest `describe` blocks inside other `describe` blocks.

**TF-43.** The `jsdom` test environment provides a browser-like DOM implementation that runs in Node.js.

**TF-44.** The default Vitest test environment is `node`, which does not provide `document`, `window`, or any DOM APIs.

**TF-45.** `happy-dom` is an alternative to `jsdom` that is generally faster but may have less complete DOM API coverage.

**TF-46.** You must use a DOM environment (`jsdom` or `happy-dom`) to test React components because they need `document.createElement` and related APIs.

**TF-47.** You can set the test environment per-file using a special comment at the top of the test file: `// @vitest-environment jsdom`.

**TF-48.** Setting `globals: true` in Vitest config makes `describe`, `it`, `expect`, and lifecycle hooks available without importing them.

**TF-49.** When `globals: true` is not set, you must import test functions explicitly: `import { describe, it, expect } from 'vitest'`.

**TF-50.** The `setupFiles` configuration option specifies files that run once before the entire test suite, useful for global polyfills or DOM library setup.

**TF-51.** The `include` configuration option in Vitest determines which files are treated as test files, typically via glob patterns like `**/*.test.ts`.

**TF-52.** Vitest supports in-source testing, which means you can write tests inside your production source files using `if (import.meta.vitest)`.

**TF-53.** In-source tests are always included in the production build output.

**TF-54.** Vitest's watch mode is enabled by default when running `vitest` (without the `run` flag) and Vitest detects it is not in a CI environment.

**TF-55.** Running `vitest run` executes all tests once and exits, without entering watch mode.

**TF-56.** Tests in Vitest run sequentially by default within a single file.

**TF-57.** Different test files in Vitest can run in parallel, with each file running in its own isolated context.

**TF-58.** You should test every line of code and aim for 100% code coverage to ensure quality.

**TF-59.** Some code is not worth testing — for example, simple pass-through components with no logic, or third-party library internals.

**TF-60.** Testing a button's `onClick` handler by asserting that `setState` was called with a specific value is an example of testing implementation details.

**TF-61.** Testing that clicking a button causes a visible change in the rendered output is an example of testing behavior.

**TF-62.** The phrase "test behavior, not implementation" means you should test what the user sees and experiences, not the internal mechanics of how your code achieves it.

**TF-63.** A test that imports a component and directly accesses its internal state (e.g., via component instance methods) is testing behavior.

**TF-64.** If a test breaks because you renamed an internal helper function but the component still works correctly for users, that test is testing implementation details.

**TF-65.** `expect.assertions(n)` verifies that exactly `n` assertions were called during the test. This is useful in async tests to ensure assertions inside callbacks actually run.

**TF-66.** `it.skip` marks a test to be skipped during the current run without deleting it from the file.

**TF-67.** `it.only` runs only the marked test(s) in the file and skips all others. This is useful for debugging a specific test.

**TF-68.** `it.todo` marks a test as a placeholder that has not been implemented yet. It will appear in the test report but will not fail.

**TF-69.** Vitest can only run test files that end in `.test.ts` — it does not support `.spec.ts` or other naming conventions.

**TF-70.** The `expect(value).toMatchObject(obj)` matcher checks that `value` contains at least the properties in `obj`, without requiring an exact match.

**TF-71.** `expect(value).toStrictEqual(other)` is stricter than `toEqual` because it distinguishes between `undefined` properties and missing properties, and checks that objects have the same prototype.

**TF-72.** Vitest's `expect` API includes asymmetric matchers like `expect.any(Number)` and `expect.stringContaining("sub")` that can be used inside other matchers for partial matching.

---

## Part B: Short Answer (16 Questions)

---

**SA-1.** Describe the Testing Trophy in 3–4 sentences. Name each layer from bottom to top and explain why integration tests occupy the largest portion.

---

**SA-2.** Explain what Kent C. Dodds means by "testing implementation details." Give one concrete example of an implementation-detail test and one example of a behavior test for the same component (a counter with an increment button).

---

**SA-3.** What is the difference between a false positive and a false negative in the context of testing? Which one is more dangerous and why?

---

**SA-4.** Write a minimal Vitest configuration inside `vite.config.ts` that sets the test environment to `jsdom`, enables global test APIs, and specifies a setup file at `./src/test/setup.ts`.

---

**SA-5.** Explain the difference between `beforeEach` and `beforeAll`. Give one scenario where `beforeAll` is preferable to `beforeEach`.

---

**SA-6.** What happens if you write the following test? Explain why it does not work as intended and show the correct version.

```ts
it("throws on invalid input", () => {
  expect(processInput(-1)).toThrow();
});
```

---

**SA-7.** Explain the difference between `toBe` and `toEqual` when comparing objects. Write a short test demonstrating where they give different results.

---

**SA-8.** What is the difference between the `node`, `jsdom`, and `happy-dom` test environments in Vitest? When would you choose each one?

---

**SA-9.** What does the `globals: true` configuration option do in Vitest? What is the alternative if you leave it disabled?

---

**SA-10.** What is in-source testing in Vitest? Write a small example showing how you would add a test to a utility function's source file using `import.meta.vitest`.

---

**SA-11.** The Testing Trophy includes "static analysis" at its base. Name two specific tools the syllabus uses for static analysis and explain what each catches that tests do not.

---

**SA-12.** Explain in 2–3 sentences why 100% code coverage is not a goal. What does coverage actually measure, and what does it fail to measure?

---

**SA-13.** What is Vitest's watch mode? How do you enter it, how do you run tests once without it, and why is it useful during development?

---

**SA-14.** Describe the execution order of lifecycle hooks in the following structure. List each hook call in the order it would run for `test A`:

```ts
describe("outer", () => {
  beforeAll(() => console.log("outer beforeAll"));
  beforeEach(() => console.log("outer beforeEach"));
  afterEach(() => console.log("outer afterEach"));

  describe("inner", () => {
    beforeEach(() => console.log("inner beforeEach"));
    afterEach(() => console.log("inner afterEach"));

    it("test A", () => console.log("test A"));
  });
});
```

---

**SA-15.** What is the purpose of `expect.assertions(n)` and when would you use it? Write a short async test that would silently pass without `expect.assertions` but correctly fail with it.

---

**SA-16.** The syllabus says "Test behavior, not implementation." In 3–4 sentences, explain why a test that asserts `setState` was called with a specific value is less valuable than a test that asserts the rendered output changed. Connect your answer to the concept of test resilience to refactoring.

---

## Part C: Multiple Choice (48 Questions)

Choose the single best answer.

---

**MC-1.** According to the Testing Trophy, which type of test provides the best balance of confidence and cost?

(a) Unit tests
(b) Integration tests
(c) End-to-end tests
(d) Static analysis

---

**MC-2.** Which layer forms the base of the Testing Trophy?

(a) Unit tests
(b) Integration tests
(c) End-to-end tests
(d) Static analysis

---

**MC-3.** "Write tests. Not too many. Mostly integration." is a quote attributed to:

(a) Dan Abramov
(b) Kent C. Dodds
(c) Martin Fowler
(d) Ryan Florence

---

**MC-4.** What is a "false negative" in the context of testing?

(a) A test that passes when the behavior is broken
(b) A test that fails when the behavior is actually correct
(c) A test that never runs
(d) A test that takes too long to execute

---

**MC-5.** What is a "false positive" in the context of testing?

(a) A test that fails when the behavior is broken
(b) A test that fails when the behavior is actually correct
(c) A test that passes when the behavior is broken
(d) A test that produces random results

---

**MC-6.** A test that checks whether a component calls `useState` with a specific initial value is testing:

(a) Behavior
(b) Implementation details
(c) Integration
(d) Accessibility

---

**MC-7.** A test that clicks a button and asserts the displayed count increases is testing:

(a) Implementation details
(b) Performance
(c) Behavior
(d) The React internals

---

**MC-8.** Which of the following is NOT a reason to avoid testing implementation details?

(a) They make tests brittle — tests break when you refactor even though behavior is unchanged
(b) They give false confidence — tests can pass even when behavior is broken
(c) They are slower to run than behavior tests
(d) They couple tests to the code structure rather than the user experience

---

**MC-9.** Vitest is built on top of:

(a) webpack
(b) Vite
(c) Rollup
(d) Parcel

---

**MC-10.** Which command runs all tests once and exits without entering watch mode?

(a) `vitest`
(b) `vitest run`
(c) `vitest --once`
(d) `vitest --no-watch`

---

**MC-11.** Where does Vitest look for its configuration by default?

(a) `jest.config.ts`
(b) `vitest.config.ts` or the `test` key in `vite.config.ts`
(c) `package.json` under the `"vitest"` key
(d) `.vitestrc.json`

---

**MC-12.** What is the default test environment in Vitest?

(a) `jsdom`
(b) `happy-dom`
(c) `node`
(d) `browser`

---

**MC-13.** Why do React component tests require a DOM environment like `jsdom`?

(a) React cannot be imported in Node.js
(b) React components call DOM APIs like `document.createElement` during rendering
(c) TypeScript requires a DOM environment for type checking
(d) Vitest cannot parse JSX without a DOM

---

**MC-14.** What is the difference between `jsdom` and `happy-dom`?

(a) `jsdom` is faster; `happy-dom` is more complete
(b) `happy-dom` is generally faster; `jsdom` has more complete DOM API coverage
(c) They are identical implementations
(d) `happy-dom` only works on Linux

---

**MC-15.** How do you set the test environment for a single test file without changing the global config?

(a) `import { setEnvironment } from 'vitest'`
(b) Add `// @vitest-environment jsdom` at the top of the file
(c) `describe.env("jsdom", () => { ... })`
(d) You cannot override the environment per-file

---

**MC-16.** What does `globals: true` do in Vitest configuration?

(a) Exposes all Node.js global variables
(b) Makes `describe`, `it`, `expect`, and lifecycle hooks available without importing them
(c) Enables global state sharing between test files
(d) Makes all test variables accessible globally

---

**MC-17.** What is the purpose of `setupFiles` in Vitest configuration?

(a) Files that are compiled first for performance
(b) Files that run before each individual test
(c) Files that run once before the entire test suite, used for global setup like polyfills
(d) Files that define test fixtures

---

**MC-18.** What does `expect(x).toBe(y)` use for comparison?

(a) `==` (loose equality)
(b) `===` (strict equality / reference equality)
(c) Deep structural comparison
(d) `Object.is()`

---

**MC-19.** Given `const a = { x: 1 }; const b = { x: 1 };`, which assertion passes?

(a) `expect(a).toBe(b)`
(b) `expect(a).toEqual(b)`
(c) Both (a) and (b)
(d) Neither (a) nor (b)

---

**MC-20.** What is the result of this test?

```ts
it("test", () => {
  expect([1, 2, 3]).toContain(2);
});
```

(a) Passes
(b) Fails because `toContain` only works on strings
(c) Fails because `toContain` uses strict object comparison
(d) Throws a runtime error

---

**MC-21.** What does `expect(fn).toThrow("invalid")` check?

(a) That `fn` throws an error whose message contains the string `"invalid"`
(b) That `fn` returns the string `"invalid"`
(c) That `fn` returns a rejected Promise with `"invalid"`
(d) That `fn` logs `"invalid"` to the console

---

**MC-22.** Which of the following correctly tests that a function throws?

(a) `expect(myFn()).toThrow()`
(b) `expect(() => myFn()).toThrow()`
(c) `expect(myFn).toThrow()` (where `myFn` takes no arguments)
(d) Both (b) and (c)

---

**MC-23.** `beforeEach` runs:

(a) Once before all tests in the file
(b) Once before all tests in the `describe` block
(c) Before each individual test in the enclosing scope
(d) After each test completes

---

**MC-24.** `beforeAll` runs:

(a) Before each individual test
(b) Once before the first test in its enclosing scope
(c) After all tests complete
(d) At the start of every `describe` block in the file

---

**MC-25.** What happens when you nest `describe` blocks and define `beforeEach` in both the outer and inner blocks?

(a) Only the inner `beforeEach` runs
(b) Only the outer `beforeEach` runs
(c) The outer `beforeEach` runs first, then the inner `beforeEach`
(d) The inner `beforeEach` runs first, then the outer `beforeEach`

---

**MC-26.** What is the correct execution order for a test inside a nested `describe` with hooks in both levels?

(a) `beforeAll (outer)` → `beforeAll (inner)` → `beforeEach (outer)` → `beforeEach (inner)` → test → `afterEach (inner)` → `afterEach (outer)`
(b) `beforeEach (outer)` → `beforeAll (inner)` → `beforeEach (inner)` → test → `afterAll (inner)` → `afterEach (outer)`
(c) `beforeAll (outer)` → `beforeEach (inner)` → `beforeEach (outer)` → test → `afterEach (outer)` → `afterEach (inner)`
(d) `beforeEach (outer)` → `beforeEach (inner)` → `beforeAll (inner)` → test → `afterEach (outer)` → `afterEach (inner)`

---

**MC-27.** Which hook would you use to set up a database connection shared across all tests in a file?

(a) `beforeEach`
(b) `beforeAll`
(c) `afterAll`
(d) `afterEach`

---

**MC-28.** Which modifier skips a test without removing it from the file?

(a) `it.only`
(b) `it.skip`
(c) `it.todo`
(d) `it.disabled`

---

**MC-29.** Which modifier marks a test as a placeholder to be written later?

(a) `it.only`
(b) `it.skip`
(c) `it.todo`
(d) `it.pending`

---

**MC-30.** What does `it.only` do?

(a) Marks the test as the only passing test
(b) Runs only the marked test(s) in the file and skips all others
(c) Fails all other tests in the file
(d) Removes all other tests from the report

---

**MC-31.** By default, how does Vitest handle test file parallelism?

(a) All tests in all files run sequentially
(b) Tests within a file run in parallel; files run sequentially
(c) Different files can run in parallel; tests within a file run sequentially
(d) Everything runs in parallel

---

**MC-32.** What is in-source testing in Vitest?

(a) Testing production source files by importing them into separate test files
(b) Writing tests directly inside production source files using `if (import.meta.vitest)`
(c) Running tests in the production build
(d) Using the source map to trace test failures

---

**MC-33.** In-source tests are included in the production build:

(a) Always
(b) Never — Vitest strips them during build when properly configured
(c) Only in development mode
(d) Only if explicitly included in `vite.config.ts`

---

**MC-34.** What does `expect.assertions(2)` do when placed at the top of a test?

(a) Limits the test to only 2 `expect` calls
(b) Verifies that exactly 2 `expect` assertions are called during the test, failing if not
(c) Runs the test 2 times
(d) Skips the test if fewer than 2 assertions exist

---

**MC-35.** When is `expect.assertions(n)` most useful?

(a) In synchronous tests with multiple conditions
(b) In async tests where assertions inside callbacks might not execute if the async flow fails
(c) In tests that test pure functions
(d) When you want to limit the number of matchers

---

**MC-36.** `expect(value).toMatchObject({ name: "Alice" })` when `value` is `{ name: "Alice", age: 30 }`:

(a) Fails because the objects are not identical
(b) Passes because `value` contains at least the properties in the expected object
(c) Throws a type error
(d) Passes only if `age` is also in the expected object

---

**MC-37.** What is the difference between `toEqual` and `toStrictEqual`?

(a) `toStrictEqual` ignores `undefined` properties; `toEqual` does not
(b) `toStrictEqual` distinguishes `undefined` properties from missing properties and checks prototypes; `toEqual` does not
(c) They are identical
(d) `toEqual` is stricter than `toStrictEqual`

---

**MC-38.** Which file naming patterns does Vitest treat as test files by default?

(a) Only `*.test.ts`
(b) Only `*.spec.ts`
(c) Files matching patterns like `*.test.ts`, `*.test.tsx`, `*.spec.ts`, `*.spec.tsx`
(d) Any `.ts` file in a `__tests__` directory only

---

**MC-39.** What does `expect(value).toBeGreaterThan(3)` check?

(a) `value > 3`
(b) `value >= 3`
(c) `value === 3`
(d) `value.length > 3`

---

**MC-40.** Which asymmetric matcher checks that a value is any instance of `Number`?

(a) `expect.number()`
(b) `expect.any(Number)`
(c) `expect.instanceOf(Number)`
(d) `expect.typeOf("number")`

---

**MC-41.** `expect("hello world").toMatch(/world/)` will:

(a) Pass
(b) Fail because `toMatch` only accepts strings, not regex
(c) Throw a runtime error
(d) Fail because the regex does not match the full string

---

**MC-42.** What does `expect.stringContaining("test")` do when used inside `toEqual`?

(a) Checks that the compared value is exactly `"test"`
(b) Acts as a partial matcher that passes if the actual string contains `"test"` anywhere
(c) Throws because asymmetric matchers cannot be nested
(d) Converts the expected value to a regex

---

**MC-43.** Which Vitest configuration option specifies the glob patterns for files to include as tests?

(a) `testFiles`
(b) `include`
(c) `testMatch`
(d) `files`

---

**MC-44.** The `test` key in `vite.config.ts` is used by:

(a) Vite's dev server
(b) Vite's build process
(c) Vitest
(d) TypeScript

---

**MC-45.** In the Testing Trophy, which layer has the lowest confidence but the lowest cost?

(a) Unit tests
(b) Integration tests
(c) End-to-end tests
(d) Static analysis

---

**MC-46.** A developer writes a test that checks whether `localStorage.setItem` was called with `"theme"` and `"dark"`. The component switches to dark mode by toggling a class on the body element. This test is:

(a) Testing behavior — it verifies the persistence mechanism
(b) Testing implementation details — a refactor to use a cookie instead of localStorage would break this test even though the behavior is the same
(c) An integration test — it tests the interaction between the component and the browser
(d) An end-to-end test

---

**MC-47.** A developer writes a test that clicks a "Dark Mode" toggle and then asserts that the body has a `dark` class. This test is:

(a) Testing implementation details because it relies on a CSS class name
(b) Testing behavior — it verifies what the user would see (a visual change) via the mechanism the CSS uses
(c) Not a valid test
(d) An end-to-end test

---

**MC-48.** Which of the following is NOT a valid Vitest lifecycle hook?

(a) `beforeEach`
(b) `afterEach`
(c) `beforeAll`
(d) `beforeTest`

---

---

## Answer Key

---

### Part A: True / False

| # | Answer | Explanation |
|---|---|---|
| TF-1 | **T** | Confidence in correct behavior for users is the fundamental purpose of testing. |
| TF-2 | **F** | The Testing Trophy places static analysis at the base, not e2e tests. E2e tests are at the top. |
| TF-3 | **T** | Integration tests occupy the largest portion of the Testing Trophy because they test how multiple pieces work together at a cost-to-confidence ratio that beats both unit and e2e tests. |
| TF-4 | **T** | Static analysis (TypeScript, linters) catches type errors, syntax issues, and code smells at zero runtime cost. It forms the base of the Trophy. |
| TF-5 | **F** | Unit tests test isolated pieces but provide lower confidence than integration tests because they do not verify that pieces work correctly together. |
| TF-6 | **T** | The traditional Testing Pyramid emphasizes unit tests as the base. The Testing Trophy shifts emphasis to integration tests as the most valuable layer. |
| TF-7 | **T** | E2e tests simulate real user flows across the full stack. They are expensive but provide the highest confidence that the system works end-to-end. |
| TF-8 | **F** | The quote means the majority of your tests should be integration tests, but unit and e2e tests still have their place. "Not too many" means you should be judicious, not that you should avoid other types entirely. |
| TF-9 | **T** | Testing implementation details means coupling your tests to how the code works internally rather than to the user-visible behavior. |
| TF-10 | **T** | This is the classic symptom of an implementation-detail test: it breaks on refactor even though behavior is preserved, creating a false negative. |
| TF-11 | **F** | A test that passes when behavior is broken is a false negative — it fails to detect the bug. (Note: some sources call this a false positive in terms of "false assurance." The KCD convention: false negative = fails to catch a bug.) |
| TF-12 | **T** | Implementation-detail tests can pass when behavior is broken (false confidence / false negative) and fail when behavior is correct (false positive / noise). Both reduce trust in the test suite. |
| TF-13 | **T** | The ideal test is sensitive to behavior changes and resilient to implementation changes. |
| TF-14 | **F** | Vitest is built on Vite, not webpack. It uses Vite's transformation pipeline natively. |
| TF-15 | **T** | Vitest automatically reads your Vite config (plugins, resolve, etc.) so your test environment matches your dev environment. |
| TF-16 | **T** | Both locations are supported. `vitest.config.ts` takes precedence if both exist. |
| TF-17 | **F** | Vitest transforms TypeScript via esbuild (same as Vite dev) without a separate compilation step. |
| TF-18 | **T** | Vitest leverages Vite's esbuild-based transformation for TypeScript files by default. |
| TF-19 | **T** | Vitest's watch mode uses Vite's module graph to determine which tests are affected by a change and only re-runs those. |
| TF-20 | **T** | Vitest intentionally maintains API compatibility with Jest for `expect` matchers, lifecycle hooks, and mock APIs, easing migration. |
| TF-21 | **T** | `describe` groups related tests into a suite, which can contain tests, lifecycle hooks, and nested `describe` blocks. |
| TF-22 | **F** | `it` and `test` are aliases. They are the same function with different names. |
| TF-23 | **T** | `it` and `test` are identical in behavior. The choice between them is purely stylistic. |
| TF-24 | **T** | `toBe` uses `Object.is()` which behaves like `===` for most cases. For objects, it checks referential identity, not structural equality. |
| TF-25 | **T** | `toEqual` recursively checks each property and element for equality, making it suitable for comparing objects and arrays by value. |
| TF-26 | **F** | `toBe` checks reference equality. Two separate objects with the same shape are different references. Use `toEqual` for structural comparison. |
| TF-27 | **T** | `toBeTruthy` passes for any JavaScript truthy value. `[]` and `{}` are truthy (only `0`, `""`, `null`, `undefined`, `NaN`, and `false` are falsy). |
| TF-28 | **T** | Both check for `null` using strict equality. They are functionally equivalent. |
| TF-29 | **T** | An unassigned declared variable has the value `undefined`, so `toBeUndefined` passes. |
| TF-30 | **T** | You must pass a function that calls the throwing code so `expect` can catch the error. |
| TF-31 | **T** | Without the wrapper, `fn()` executes immediately and the thrown error propagates before `expect` can handle it, causing the test to fail with an unhandled error. |
| TF-32 | **T** | `toContain` works on arrays (element in array) and strings (substring match). |
| TF-33 | **T** | `toHaveLength` checks the `.length` property, which exists on strings, arrays, and other array-like objects. |
| TF-34 | **F** | `beforeEach` runs before each individual test, not once before all tests. That is `beforeAll`. |
| TF-35 | **T** | `beforeEach` provides fresh setup before every test, helping ensure tests are isolated from each other. |
| TF-36 | **T** | `afterEach` is the standard place for test cleanup: resetting mocks, clearing DOM state, etc. |
| TF-37 | **T** | `beforeAll` runs once for the entire scope. It is used for expensive one-time setup like opening database connections. |
| TF-38 | **F** | `afterAll` runs once after all tests in its scope have completed, not after every individual test. |
| TF-39 | **T** | Top-level lifecycle hooks (outside any `describe`) apply to every test in the file. |
| TF-40 | **T** | Hooks are inherited: an inner `describe` runs its parent's `beforeEach` before its own. |
| TF-41 | **T** | Outer `beforeEach` runs first, then inner `beforeEach`, for each test inside the inner block. |
| TF-42 | **F** | `describe` blocks can be nested to any depth, which is how you create hierarchical test organization. |
| TF-43 | **T** | `jsdom` implements a substantial portion of the DOM and browser APIs in pure JavaScript, running inside Node.js. |
| TF-44 | **T** | The default environment is `node`, which provides no DOM. You must explicitly configure `jsdom` or `happy-dom` for component testing. |
| TF-45 | **T** | `happy-dom` is designed for performance and is faster than `jsdom`, but it has some gaps in API coverage. |
| TF-46 | **T** | React's rendering process calls DOM APIs. Without a DOM implementation, `render()` would fail. |
| TF-47 | **T** | The per-file comment `// @vitest-environment jsdom` overrides the global config for that file. |
| TF-48 | **T** | With `globals: true`, Vitest injects these functions globally, similar to how Jest works by default. |
| TF-49 | **T** | Without `globals: true`, all test APIs must be explicitly imported from `'vitest'`. |
| TF-50 | **T** | `setupFiles` run once before the suite starts. Common uses include importing `@testing-library/jest-dom` matchers or setting up global polyfills. |
| TF-51 | **T** | The `include` option accepts glob patterns to determine which files Vitest recognizes as tests. |
| TF-52 | **T** | In-source testing is a Vitest feature that lets you colocate tests with their source code using the `import.meta.vitest` guard. |
| TF-53 | **F** | In-source tests are tree-shaken out of the production build by Vite when configured correctly. The `import.meta.vitest` guard ensures the test code is only included during testing. |
| TF-54 | **T** | Running `vitest` without the `run` flag starts watch mode automatically (unless CI is detected). |
| TF-55 | **T** | `vitest run` is the non-interactive, single-run mode used in CI pipelines and scripts. |
| TF-56 | **T** | Within a single file, Vitest runs tests sequentially by default. |
| TF-57 | **T** | Vitest can parallelize across files using worker threads or child processes, with each file isolated in its own context. |
| TF-58 | **F** | 100% coverage is not a useful goal. Some code is trivial, some is better tested via integration, and coverage measures execution, not correctness. The Testing Trophy philosophy is "not too many." |
| TF-59 | **T** | Not all code warrants its own tests. Trivial pass-through code and third-party internals are often tested implicitly through integration tests or not at all. |
| TF-60 | **T** | Asserting that `setState` was called with a specific value tests how the component achieves its result, not what the user sees. This is an implementation detail. |
| TF-61 | **T** | Clicking a button and checking the rendered output mirrors what a real user would see. This is a behavior test. |
| TF-62 | **T** | "Test behavior" means testing from the user's perspective — what they see, click, and experience. |
| TF-63 | **F** | Accessing internal state directly tests how the component works internally, not what the user experiences. This is testing implementation details. |
| TF-64 | **T** | If renaming an internal helper breaks a test but the component still works correctly, the test was coupled to internal naming — an implementation detail. |
| TF-65 | **T** | `expect.assertions(n)` is a safeguard for async tests, ensuring that assertions inside callbacks actually execute and are not silently skipped. |
| TF-66 | **T** | `it.skip` skips the test while preserving it in the source for later use. |
| TF-67 | **T** | `it.only` focuses the test run on the marked test(s), useful for isolating failures during debugging. |
| TF-68 | **T** | `it.todo` is a placeholder. It shows up in the report as "todo" without executing or failing. |
| TF-69 | **F** | Vitest supports multiple naming conventions by default: `.test.ts`, `.test.tsx`, `.spec.ts`, `.spec.tsx`, and files in `__tests__` directories. |
| TF-70 | **T** | `toMatchObject` is a subset matcher: it checks that the actual value contains at least the specified properties without requiring an exact match. |
| TF-71 | **T** | `toStrictEqual` is more precise than `toEqual`: it checks prototypes, distinguishes between `undefined` properties and missing properties, and rejects sparse array elements. |
| TF-72 | **T** | Asymmetric matchers like `expect.any(Number)` and `expect.stringContaining("sub")` enable partial matching inside `toEqual`, `toMatchObject`, and other structural matchers. |

---

### Part B: Short Answer

**SA-1.**
The Testing Trophy has four layers, bottom to top: static analysis, unit tests, integration tests, and end-to-end tests. Integration tests occupy the largest portion because they test how multiple pieces of code work together — for example, rendering a component with its children, interacting with it, and asserting the result — which closely mirrors how users actually use the software. They catch bugs that unit tests miss (because individual units might work fine in isolation but fail when composed) while being far cheaper and faster to write and maintain than end-to-end tests. The result is the best ratio of confidence gained per unit of time and effort spent.

---

**SA-2.**
"Testing implementation details" means writing tests that depend on how a component achieves its result rather than what the user sees. For a counter with an increment button:

Implementation-detail test: You spy on the `useState` setter (or check that the component's internal `count` state variable equals `1` after clicking). This breaks if you refactor from `useState` to `useReducer`, even though the counter still works.

Behavior test: You render the counter, click the increment button, and assert that the displayed text shows `"1"`. This test mirrors what a user does and survives any internal refactor.

---

**SA-3.**
A false negative is when a test fails to detect a real bug — the test passes, but the behavior is actually broken. A false positive is when a test fails even though the behavior is correct — typically caused by testing implementation details during a refactor. False negatives are more dangerous because they give you false confidence: you believe your code works when it does not, and bugs reach users. False positives are annoying (they slow you down), but at least they get your attention.

---

**SA-4.**
```ts
// vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: ['./src/test/setup.ts'],
  },
});
```

---

**SA-5.**
`beforeEach` runs before every individual test in its scope, providing a fresh setup each time. `beforeAll` runs once before any test in its scope. Use `beforeAll` when the setup is expensive and does not need to be reset between tests — for example, establishing a database connection or reading a large fixture file from disk. Since the setup is shared, you must be careful that tests do not mutate the shared state in ways that affect other tests.

---

**SA-6.**
The problem is that `processInput(-1)` is called immediately, and if it throws, the error escapes before `expect` can catch it. The test crashes instead of failing gracefully with a matcher error. The correct version wraps the call in a function:

```ts
it("throws on invalid input", () => {
  expect(() => processInput(-1)).toThrow();
});
```

The arrow function defers execution so `expect` can invoke it inside a try/catch and evaluate the `.toThrow()` matcher.

---

**SA-7.**
`toBe` uses `Object.is()` (essentially `===`), which checks referential identity. Two separate objects with identical contents are different references, so `toBe` fails. `toEqual` performs a deep structural comparison and passes if the contents match.

```ts
it("demonstrates toBe vs toEqual", () => {
  const a = { x: 1, y: 2 };
  const b = { x: 1, y: 2 };

  expect(a).toEqual(b);   // passes — same contents
  expect(a).toBe(b);      // fails — different references
});
```

---

**SA-8.**
`node` is the default — a plain Node.js environment with no DOM APIs. Use it for testing pure logic (utility functions, reducers, data transformations). `jsdom` provides a comprehensive browser-like DOM implementation in Node.js and is the standard choice for React component testing. `happy-dom` is a lighter, faster alternative to `jsdom` with most DOM APIs but some gaps in coverage — use it when speed matters and your components do not rely on obscure browser APIs. For React Testing Library usage, both `jsdom` and `happy-dom` work; `jsdom` is the safer default.

---

**SA-9.**
`globals: true` makes Vitest's test APIs (`describe`, `it`, `expect`, `beforeEach`, `afterEach`, `beforeAll`, `afterAll`) available as global functions in every test file without needing to import them. If you leave it disabled (the default), you must explicitly import them at the top of every test file:

```ts
import { describe, it, expect, beforeEach } from 'vitest';
```

---

**SA-10.**
In-source testing lets you write tests directly inside your source file, guarded by `import.meta.vitest` so they are stripped from the production build:

```ts
// src/utils/math.ts
export function add(a: number, b: number): number {
  return a + b;
}

if (import.meta.vitest) {
  const { describe, it, expect } = import.meta.vitest;

  describe("add", () => {
    it("adds two numbers", () => {
      expect(add(2, 3)).toBe(5);
    });
  });
}
```

Vitest detects and runs these tests during `vitest` or `vitest run`. In production builds, the `import.meta.vitest` block is tree-shaken away.

---

**SA-11.**
The syllabus uses TypeScript and ESLint. TypeScript catches type errors at compile time — such as passing a string where a number is expected, misspelling a property name, or forgetting to handle `null`. ESLint catches code quality issues, potential bugs, and convention violations — such as unused variables, missing dependencies in `useEffect`, or accessibility issues (via eslint-plugin-jsx-a11y). Both run without executing the code, catching entire categories of bugs that would require many tests to cover otherwise.

---

**SA-12.**
Code coverage measures which lines, branches, and statements were executed during the test run — not whether the behavior is correct. A test that calls a function without asserting anything about its result achieves coverage but provides zero confidence. Coverage also cannot tell you about missing functionality: if you never wrote a feature, there is no code to cover, so your coverage number stays high even though the feature is absent. Coverage is a useful tool for finding untested areas, but it should never be a target in itself.

---

**SA-13.**
Watch mode is Vitest's interactive mode where it monitors file changes and re-runs only the affected tests in real time. You enter watch mode by running `vitest` without the `run` flag (it starts automatically outside CI). You exit it with `q` or Ctrl+C. To run tests once without watch mode, use `vitest run`. Watch mode is useful during development because you get instant feedback on the tests related to the file you just changed, without waiting for the entire suite to run.

---

**SA-14.**
For `test A` inside the inner `describe`, the execution order is:

1. `outer beforeAll` (once, before any test in the outer block)
2. `outer beforeEach` (before each test, inherited by the inner block)
3. `inner beforeEach` (before each test in the inner block)
4. `test A`
5. `inner afterEach` (after each test in the inner block)
6. `outer afterEach` (after each test, inherited by the inner block)

So the console output would be: `outer beforeAll`, `outer beforeEach`, `inner beforeEach`, `test A`, `inner afterEach`, `outer afterEach`.

---

**SA-15.**
`expect.assertions(n)` verifies that exactly `n` assertion calls were made during the test. It is essential in async tests where an assertion inside a `.then()` or `.catch()` might never execute if the async operation resolves/rejects unexpectedly — the test would pass silently with zero assertions.

```ts
it("calls the error handler on rejection", async () => {
  expect.assertions(1);

  try {
    await fetchData("bad-url");
  } catch (error) {
    expect(error).toBeDefined();
  }
});
```

Without `expect.assertions(1)`, if `fetchData` resolves instead of rejecting, the catch block never runs and the test passes with zero assertions — a false negative. With it, Vitest fails the test because no assertions were called.

---

**SA-16.**
A test that asserts `setState` was called with a specific value is coupled to how the component manages its state internally. If you refactor from `useState` to `useReducer`, or move state into a parent component, the test breaks even though the user experience is identical. A test that asserts the rendered output changed — for example, that the displayed count went from `"0"` to `"1"` after a click — mirrors how a real user interacts with the component and what they observe. This test survives any internal refactor as long as the behavior remains the same. This resilience to refactoring is the defining property of a good test: it should only fail when behavior changes, not when implementation changes.

---

### Part C: Multiple Choice

| # | Answer | Explanation |
|---|---|---|
| MC-1 | **(b)** | The Testing Trophy places integration tests as the largest, most valuable layer — the best confidence-to-cost ratio. |
| MC-2 | **(d)** | Static analysis (TypeScript, ESLint) forms the base of the Testing Trophy. |
| MC-3 | **(b)** | This is Kent C. Dodds' widely cited summary of his testing philosophy, from his article and talk of the same name. |
| MC-4 | **(b)** | A false negative means the test fails to catch a bug — it passes when the behavior is broken. But in KCD's usage for tests specifically: a test that fails when behavior is correct is a false negative in the sense that it falsely signals failure. (This question follows the convention: false negative = test fails when it shouldn't.) |
| MC-5 | **(c)** | A false positive = the test passes when behavior is broken. (Following the convention: the test "positively" reports success when it shouldn't.) |
| MC-6 | **(b)** | Checking whether a specific hook was called with a specific value is an implementation detail. The user does not care how state is managed internally. |
| MC-7 | **(c)** | Clicking a button and asserting visible output mirrors user interaction and tests behavior. |
| MC-8 | **(c)** | Implementation-detail tests are not inherently slower to run. The problems are brittleness, false confidence, and coupling to code structure. |
| MC-9 | **(b)** | Vitest is built natively on Vite, reusing its configuration and transformation pipeline. |
| MC-10 | **(b)** | `vitest run` executes all tests once and exits. `vitest` alone enters watch mode. |
| MC-11 | **(b)** | Vitest looks for `vitest.config.ts` or the `test` key inside `vite.config.ts`. |
| MC-12 | **(c)** | The default environment is `node` — no DOM APIs. You must explicitly set `jsdom` or `happy-dom` for component tests. |
| MC-13 | **(b)** | React calls `document.createElement` and other DOM APIs during rendering. Without a DOM implementation, rendering fails. |
| MC-14 | **(b)** | `happy-dom` is generally faster; `jsdom` has more complete API coverage. |
| MC-15 | **(b)** | The `// @vitest-environment jsdom` comment at the top of a file overrides the global environment for that file. |
| MC-16 | **(b)** | `globals: true` makes test APIs available globally without explicit imports. |
| MC-17 | **(c)** | `setupFiles` run once before the test suite starts. They are for global setup like importing custom matchers. |
| MC-18 | **(b)** | `toBe` uses `Object.is()`, which behaves like `===` for most values (strict/referential equality). |
| MC-19 | **(b)** | `a` and `b` are different references, so `toBe` fails. `toEqual` does a deep comparison and passes. |
| MC-20 | **(a)** | `toContain` checks array membership. `2` is in `[1, 2, 3]`, so it passes. |
| MC-21 | **(a)** | `toThrow("invalid")` checks that the thrown error's message contains the substring `"invalid"`. |
| MC-22 | **(d)** | Both work. (b) wraps the call in an arrow function. (c) passes the function reference directly (valid when it takes no arguments). Both allow `expect` to invoke the function and catch the throw. |
| MC-23 | **(c)** | `beforeEach` runs before each individual test in its enclosing scope. |
| MC-24 | **(b)** | `beforeAll` runs once before the first test in its enclosing scope. |
| MC-25 | **(c)** | The outer `beforeEach` runs first, then the inner `beforeEach`, for each test in the inner block. |
| MC-26 | **(a)** | `beforeAll` hooks run first (outer then inner), then `beforeEach` hooks (outer then inner), then the test, then `afterEach` (inner then outer). |
| MC-27 | **(b)** | `beforeAll` runs once for the entire scope and is appropriate for expensive one-time setup like database connections. |
| MC-28 | **(b)** | `it.skip` skips the test without removing it from the file. |
| MC-29 | **(c)** | `it.todo` is a placeholder for tests to be written later. |
| MC-30 | **(b)** | `it.only` focuses the run on the marked test(s) and skips all others in the file. |
| MC-31 | **(c)** | By default, Vitest runs different files in parallel (using worker threads) but tests within a file sequentially. |
| MC-32 | **(b)** | In-source testing means writing tests inside the production source file, guarded by `if (import.meta.vitest)`. |
| MC-33 | **(b)** | In-source tests are tree-shaken from the production build when Vitest is configured correctly. |
| MC-34 | **(b)** | `expect.assertions(2)` verifies exactly 2 assertions ran. If the test completes with fewer or more, it fails. |
| MC-35 | **(b)** | It is most useful in async tests where assertions inside callbacks might be silently skipped if the async flow does not reach them. |
| MC-36 | **(b)** | `toMatchObject` is a subset matcher. `value` has all properties from the expected object, so it passes even though `value` has extra properties. |
| MC-37 | **(b)** | `toStrictEqual` is stricter: it checks prototypes, distinguishes `undefined` properties from missing ones, and rejects sparse arrays. |
| MC-38 | **(c)** | Vitest matches `*.test.ts`, `*.test.tsx`, `*.spec.ts`, `*.spec.tsx`, and files in `__tests__` directories by default. |
| MC-39 | **(a)** | `toBeGreaterThan(3)` checks `value > 3` (strictly greater than). |
| MC-40 | **(b)** | `expect.any(Number)` is an asymmetric matcher that matches any number value. |
| MC-41 | **(a)** | `toMatch` accepts both strings and regular expressions. `/world/` matches the substring `"world"` in `"hello world"`. |
| MC-42 | **(b)** | `expect.stringContaining("test")` is an asymmetric matcher that passes if the actual string contains `"test"` as a substring. |
| MC-43 | **(b)** | The `include` configuration option specifies glob patterns for test file discovery. |
| MC-44 | **(c)** | The `test` key in `vite.config.ts` is read by Vitest, not by Vite's dev server or build process. |
| MC-45 | **(d)** | Static analysis has the lowest cost (runs automatically, no test code to write) but also the lowest per-assertion confidence (it cannot verify runtime behavior). |
| MC-46 | **(b)** | Checking that `localStorage.setItem` was called is an implementation detail. A refactor to cookies would break this test even though dark mode still works. |
| MC-47 | **(b)** | Checking for a CSS class is a reasonable proxy for visual behavior — it is the mechanism that controls what the user sees. While not perfect, it tests closer to behavior than checking internal state. |
| MC-48 | **(d)** | `beforeTest` is not a Vitest lifecycle hook. The valid hooks are `beforeAll`, `beforeEach`, `afterAll`, and `afterEach`. |