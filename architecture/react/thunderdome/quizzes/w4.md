# Week 4 Quiz: TypeScript Project Configuration

**Scope:** tsconfig.json for production, declaration files in depth, `as const` assertions, template literal types, branded types, ES modules vs CommonJS, `import type`, `moduleResolution`, Vite and TypeScript.

**Assigned Readings:**
- TS-HB: "tsconfig.json" overview and reference entries for strict, noUncheckedIndexedAccess, exactOptionalPropertyTypes, moduleResolution, target, lib
- TS-HB: "Modules" chapter
- Article: "as const" (TypeScript 3.4 release notes)
- Article: Branded types (Matt Pocock or equivalent)
- Vite: "Getting Started" and "Features"

**Scoring:** Wrong answers on T/F and MC are subtracted from right answers. Do not guess.

---

## Part A: True / False (32 Questions)

---

**TF-1.** `"strict": true` in tsconfig enables a single strictness check.

**TF-2.** `"strict": true` is a shorthand that enables multiple stricter type-checking flags including `strictNullChecks`, `noImplicitAny`, `strictFunctionTypes`, and others.

**TF-3.** `noUncheckedIndexedAccess` is included in the `strict` family of flags and is enabled by `"strict": true`.

**TF-4.** With `noUncheckedIndexedAccess` enabled, `arr[0]` on a `number[]` is typed as `number | undefined`.

**TF-5.** `exactOptionalPropertyTypes` makes a distinction between a property that is missing and a property that is explicitly set to `undefined`.

**TF-6.** The `target` setting in tsconfig determines which JavaScript features are downleveled for older runtimes.

**TF-7.** The `lib` setting controls which built-in type declaration files (e.g., DOM, ES2020) are available in your program.

**TF-8.** Setting `target` to `ES5` will cause TypeScript to error if you use `Array.prototype.includes`, because that method is not available in ES5.

**TF-9.** In TypeScript, a file is considered a module if it contains at least one top-level `import` or `export` statement.

**TF-10.** A file without any `import` or `export` is treated as a script whose declarations are in the global scope.

**TF-11.** Adding `export {}` to a file with no other imports or exports converts it into a module.

**TF-12.** ES Modules use `import`/`export` syntax, while CommonJS uses `require`/`module.exports`.

**TF-13.** `import type { User } from "./types"` imports the `User` type and also causes the `"./types"` module to be loaded at runtime.

**TF-14.** `import type` is completely erased in the JavaScript output, ensuring no runtime side effects from the import.

**TF-15.** Inline type imports (`import { type User, createUser } from "./types"`) allow mixing type-only and value imports in a single statement.

**TF-16.** `"moduleResolution": "bundler"` aligns module resolution with how modern bundlers like Vite and esbuild resolve imports.

**TF-17.** `"moduleResolution": "node"` is the recommended setting for new Vite projects.

**TF-18.** `as const` makes a value deeply readonly and infers the narrowest possible literal types.

**TF-19.** `as const` freezes the value at runtime, equivalent to `Object.freeze`.

**TF-20.** `const directions = ["north", "south"] as const` infers `directions` as `readonly ["north", "south"]`, not `string[]`.

**TF-21.** Without `as const`, `const config = { retries: 3 }` infers `retries` as `number`, not `3`.

**TF-22.** `as const` is useful for creating discriminated union types from configuration objects because it preserves literal types.

**TF-23.** Template literal types use backtick syntax at the type level to construct string types from literal parts and placeholders.

**TF-24.** `` type Route = `/api/${string}` `` matches any string that starts with `/api/`.

**TF-25.** Template literal types can combine multiple string literal unions to produce a cross-product of all combinations.

**TF-26.** A branded type adds a hidden property to the JavaScript object at runtime to enforce nominal type distinctions.

**TF-27.** Branded types are a compile-time-only technique where a phantom intersection property creates nominal distinctions between structurally identical types.

**TF-28.** `type UserId = string & { readonly __brand: unique symbol }` makes `UserId` and plain `string` incompatible at the type level, even though both are strings at runtime.

**TF-29.** Vite performs TypeScript type checking during development as part of its hot module replacement pipeline.

**TF-30.** Vite uses esbuild to strip type annotations for fast transpilation, but type checking must be done separately via `tsc --noEmit` or an IDE.

**TF-31.** In a Vite project, `tsc --noEmit` is used to type-check the entire project without producing JavaScript output.

**TF-32.** Declaration files (`.d.ts`) produced by `tsc` with the `declaration` compiler option allow other TypeScript projects to consume your library with full type information.

---

## Part B: Short Answer (16 Questions)

Answer in 1–4 sentences or a short code snippet. Write valid TypeScript where code is requested.

---

**SA-1.** List four flags that `"strict": true` enables. For each, write one sentence explaining what it does.

---

**SA-2.** Explain what `noUncheckedIndexedAccess` does. Given `const arr = [1, 2, 3]`, what is the type of `arr[0]` with and without this flag?

---

**SA-3.** Explain the difference between the `target` and `lib` settings in tsconfig. Give a scenario where you might set them independently.

---

**SA-4.** What makes a TypeScript file a "module" versus a "script"? What are the implications of each for variable scoping?

---

**SA-5.** What is the difference between `import { User } from "./types"` and `import type { User } from "./types"`? Why does it matter for bundlers?

---

**SA-6.** What does `export {}` accomplish when added to a file that has no other imports or exports?

---

**SA-7.** What does `"moduleResolution": "bundler"` do, and why is it recommended for Vite projects? How does it differ from `"node"`?

---

**SA-8.** Given the following code, what are the types of `config.endpoint` and `config.retries`? Explain why.

```ts
const config = {
  endpoint: "/api",
  retries: 3,
} as const;
```

---

**SA-9.** What is the difference between these two declarations? What can you do with `a` that you cannot do with `b`?

```ts
const a = ["north", "south", "east"];
const b = ["north", "south", "east"] as const;
```

---

**SA-10.** Write a template literal type `ApiEndpoint` that represents strings of the form `/api/v${number}/${string}` — for example, `"/api/v1/users"` or `"/api/v2/posts"`.

---

**SA-11.** What is a branded type and what problem does it solve? Write branded types `UserId` and `PostId` that are both strings at runtime but incompatible at the type level.

---

**SA-12.** Given the branded types from SA-11, write a function `getUser(id: UserId): void`. Then show what happens when you try to call it with a plain `string` and with a `PostId`.

---

**SA-13.** Explain how Vite handles TypeScript during development. What tool does it use for transpilation, and what does it NOT do?

---

**SA-14.** In a Vite + TypeScript project, how do you ensure type safety if Vite itself doesn't type-check? Describe the typical workflow.

---

**SA-15.** What is `exactOptionalPropertyTypes` and how does it change the behavior of optional properties? Give an example where it matters.

---

**SA-16.** Your project has the following tsconfig. Identify one problem and explain how to fix it.

```json
{
  "compilerOptions": {
    "target": "ES5",
    "module": "commonjs",
    "strict": false,
    "moduleResolution": "node"
  }
}
```

---

## Part C: Multiple Choice (16 Questions)

Choose the single best answer.

---

**MC-1.** Which flag is NOT enabled by `"strict": true`?

(a) `strictNullChecks`
(b) `noImplicitAny`
(c) `noUncheckedIndexedAccess`
(d) `strictFunctionTypes`

---

**MC-2.** With `noUncheckedIndexedAccess` enabled, what is the type of `val`?

```ts
const obj: Record<string, number> = { a: 1, b: 2 };
const val = obj["c"];
```

(a) `number`
(b) `number | undefined`
(c) `any`
(d) `never`

---

**MC-3.** What does `as const` do to this array?

```ts
const colors = ["red", "green", "blue"] as const;
```

(a) Types it as `string[]`
(b) Types it as `readonly ["red", "green", "blue"]` with literal element types
(c) Freezes the array at runtime with `Object.freeze`
(d) Types it as `("red" | "green" | "blue")[]`

---

**MC-4.** What is the type of `config.port` after this declaration?

```ts
const config = {
  host: "localhost",
  port: 3000,
  debug: true,
} as const;
```

(a) `number`
(b) `3000`
(c) `any`
(d) `number | undefined`

---

**MC-5.** What does the template literal type `` type EventName = `on${string}` `` match?

(a) Only the literal string `"on${string}"`
(b) Any string that starts with `"on"`, such as `"onClick"`, `"onHover"`, `"onX"`
(c) Only `"on"` by itself
(d) Any string at all

---

**MC-6.** What is the purpose of a branded type?

```ts
type UserId = string & { readonly __brand: unique symbol };
type PostId = string & { readonly __brand: unique symbol };
```

(a) It adds a `__brand` property to the JavaScript object at runtime
(b) It creates compile-time nominal distinctions between types that are structurally identical (both are strings at runtime)
(c) It converts strings to unique symbols
(d) It creates a new JavaScript class

---

**MC-7.** What happens when you try to pass a plain `string` to a function that expects a branded `UserId`?

```ts
type UserId = string & { readonly __brand: unique symbol };
function getUser(id: UserId): void { }
const id: string = "abc";
getUser(id); // ?
```

(a) No error; `string` is assignable to `UserId`
(b) A compile-time error because `string` is not assignable to `UserId`
(c) A runtime error
(d) TypeScript adds the brand automatically

---

**MC-8.** What is the difference between `import { User }` and `import type { User }`?

(a) No difference; they are identical
(b) `import type` only imports type information and is erased in the JS output; `import` may retain the module import at runtime
(c) `import type` imports the value but restricts usage to type positions
(d) `import type` is deprecated

---

**MC-9.** What does `export {}` do in a file?

(a) Exports all variables in the file
(b) Converts the file to a module with no exports, giving it its own scope
(c) Clears all existing exports
(d) Nothing; it is ignored

---

**MC-10.** Why is `"moduleResolution": "bundler"` recommended for Vite projects?

(a) It uses the Node.js CommonJS resolution algorithm
(b) It matches how modern bundlers resolve imports, supporting extensionless imports, `exports` fields, and `import` conditions
(c) It bundles all modules into one file
(d) It disables module resolution entirely

---

**MC-11.** How does Vite handle TypeScript during development?

(a) It runs `tsc` for both type checking and transpilation
(b) It uses esbuild to strip types quickly without performing type checking
(c) It uses Babel with the TypeScript preset
(d) It interprets TypeScript directly without compilation

---

**MC-12.** In a Vite project, how should you type-check your code?

(a) Vite handles type checking automatically during `vite dev`
(b) Run `tsc --noEmit` separately, either in your IDE, as a build step, or in CI
(c) Install a special Vite type-checking plugin that replaces `tsc`
(d) Type checking is not needed when using Vite

---

**MC-13.** What does the `target` setting in tsconfig control?

(a) Which TypeScript version to use
(b) Which JavaScript features are downleveled for compatibility with older runtimes
(c) Which files to compile
(d) Which IDE to use

---

**MC-14.** What does the `lib` setting in tsconfig control?

(a) Which npm packages to install
(b) Which built-in type declaration files are available, such as DOM APIs or ECMAScript features
(c) Which test runner to use
(d) The output directory for compiled files

---

**MC-15.** Which tsconfig setting should be `true` for all new projects according to the syllabus?

(a) `allowJs`
(b) `strict`
(c) `skipLibCheck`
(d) `noEmit`

---

**MC-16.** Your tsconfig has `"strict": true` and `"noUncheckedIndexedAccess": true`. You write the following code:

```ts
const scores: number[] = [90, 85, 70];
const first = scores[0];
first.toFixed(2); // ?
```

What happens?

(a) No error; `first` is `number`
(b) A compile-time error because `first` is `number | undefined`, and you must check for `undefined` before calling `.toFixed()`
(c) A runtime error
(d) TypeScript ignores the index access

---

---

## Answer Key

### Part A: True / False

| # | Answer | Explanation |
|---|---|---|
| TF-1 | **F** | `strict` enables multiple flags, not just one. |
| TF-2 | **T** | It enables `strictNullChecks`, `noImplicitAny`, `strictFunctionTypes`, `strictBindCallApply`, `strictPropertyInitialization`, `noImplicitThis`, `alwaysStrict`, and `useUnknownInCatchVariables`. |
| TF-3 | **F** | `noUncheckedIndexedAccess` is NOT part of `strict`. It must be enabled separately. |
| TF-4 | **T** | The flag adds `undefined` to indexed access types, forcing explicit handling of possibly-missing values. |
| TF-5 | **T** | With this flag, `{ prop?: string }` means the property can be absent, but you cannot explicitly set it to `undefined` unless the type includes `| undefined`. |
| TF-6 | **T** | `target` controls which JS syntax features are downleveled. ES5 target will compile arrow functions to regular functions, for example. |
| TF-7 | **T** | `lib` determines which `.d.ts` files for built-in APIs are available. `["ES2020", "DOM"]` gives you ES2020 language features and browser APIs. |
| TF-8 | **T** | `Array.prototype.includes` is an ES2016+ feature. With `target: "ES5"` and no explicit `lib` override, it won't be available. (If `lib` is set explicitly to include newer features, it may be available for type checking but not polyfilled.) |
| TF-9 | **T** | A top-level `import` or `export` makes the file a module. |
| TF-10 | **T** | Scripts have global scope. Modules have their own scope. |
| TF-11 | **T** | `export {}` is the idiomatic way to make a file a module when it has no natural exports. |
| TF-12 | **T** | These are the two major module systems. ESM is the standard; CJS is the Node.js legacy format. |
| TF-13 | **F** | `import type` is completely erased. The module is NOT loaded at runtime. |
| TF-14 | **T** | `import type` guarantees zero runtime side effects from the import. |
| TF-15 | **T** | Inline type imports (TypeScript 4.5+) allow `import { type User, createUser }` where `User` is erased and `createUser` remains. |
| TF-16 | **T** | `"bundler"` resolution supports features like extensionless imports and `exports` fields that modern bundlers handle. |
| TF-17 | **F** | `"node"` uses the Node.js CommonJS algorithm. For Vite, `"bundler"` is recommended. |
| TF-18 | **T** | `as const` infers literal types and makes the entire structure deeply `readonly`. |
| TF-19 | **F** | `as const` is compile-time only. It does not call `Object.freeze` or affect runtime behavior. |
| TF-20 | **T** | `as const` produces a readonly tuple with literal element types, not a mutable `string[]`. |
| TF-21 | **T** | Without `as const`, `const` only prevents reassignment of the variable, not widening of property types. |
| TF-22 | **T** | `as const` preserves literals like `"admin"` and `"user"` instead of widening to `string`, which is essential for discriminated unions. |
| TF-23 | **T** | Template literal types use backtick syntax at the type level: `` `prefix${string}` ``. |
| TF-24 | **T** | The type matches any string beginning with `/api/` followed by anything. |
| TF-25 | **T** | `` `${"get" | "set"}${"Name" | "Age"}` `` produces `"getName" | "setName" | "getAge" | "setAge"`. |
| TF-26 | **F** | Branded types are compile-time only. No property is added at runtime. |
| TF-27 | **T** | The phantom intersection creates a nominal distinction that exists only in the type system. |
| TF-28 | **T** | The brand makes the types incompatible. A plain `string` cannot be assigned to `UserId` without an explicit assertion. |
| TF-29 | **F** | Vite does not type-check. It uses esbuild for fast transpilation only. |
| TF-30 | **T** | esbuild strips types for speed. `tsc --noEmit` or an IDE provides the actual type checking. |
| TF-31 | **T** | `tsc --noEmit` type-checks without producing output files. |
| TF-32 | **T** | The `declaration` flag generates `.d.ts` files that allow consumers to get type information from your compiled library. |

### Part B: Short Answer

**SA-1.**
Four flags enabled by `strict`:
1. **`strictNullChecks`**: `null` and `undefined` are their own types and not assignable to other types without explicit unions.
2. **`noImplicitAny`**: TypeScript errors when it cannot infer a type and would fall back to `any`.
3. **`strictFunctionTypes`**: Function parameter types are checked contravariantly (stricter subtype checking).
4. **`noImplicitThis`**: TypeScript errors when `this` has an implicit `any` type.

---

**SA-2.**
`noUncheckedIndexedAccess` adds `undefined` to any type accessed via an index or key lookup. Without the flag, `arr[0]` is `number`. With the flag, `arr[0]` is `number | undefined`, which forces you to handle the case where the index is out of bounds. This catches a common source of runtime errors.

---

**SA-3.**
`target` controls which JavaScript syntax features are downleveled in the output (e.g., ES5 compiles arrow functions to regular functions). `lib` controls which built-in type declarations are available for type checking (e.g., DOM APIs, ES2020 methods). You might set them independently when targeting an older runtime but using polyfills: `target: "ES2015"` for syntax, `lib: ["ES2020", "DOM"]` to allow modern APIs that are polyfilled.

---

**SA-4.**
A file is a module if it contains a top-level `import` or `export`. A file without either is a script. Modules execute in their own scope — variables declared in a module are not visible globally. Scripts share the global scope, so variables and types declared in one script are visible to all others.

---

**SA-5.**
`import { User }` may result in a runtime module import in the JavaScript output (even if `User` is only a type). `import type { User }` is completely erased — no import statement appears in the JS. This matters for bundlers because `import type` signals that the import has no side effects and can be safely removed during tree-shaking.

---

**SA-6.**
`export {}` converts a file from a script to a module. As a module, the file gets its own scope, so its declarations no longer leak into the global scope. This is useful when a file doesn't naturally import or export anything but you want module scoping.

---

**SA-7.**
`"moduleResolution": "bundler"` resolves modules the way modern bundlers (Vite, esbuild, webpack) actually do: supporting extensionless imports, the `exports` field in `package.json`, and `import`/`require` conditions. The `"node"` setting uses the older Node.js CommonJS algorithm, which doesn't support these features and doesn't match how Vite resolves modules.

---

**SA-8.**
`config.endpoint` is `"/api"` (the string literal type). `config.retries` is `3` (the numeric literal type). `as const` infers the narrowest possible literal types and makes the entire object `readonly`. Without `as const`, the types would be `string` and `number` respectively.

---

**SA-9.**
`a` is typed as `string[]` — a mutable array of strings. You can `push`, `pop`, and reassign elements. `b` is typed as `readonly ["north", "south", "east"]` — a readonly tuple with literal element types. You cannot mutate `b` (no `push`, `pop`, or element reassignment), and each position has a specific literal type.

---

**SA-10.**

```ts
type ApiEndpoint = `/api/v${number}/${string}`;

// Valid: "/api/v1/users", "/api/v2/posts"
// Invalid: "/api/users", "/v1/posts"
```

---

**SA-11.**
A branded type uses a phantom intersection property to create nominal type distinctions between structurally identical types. It solves the problem of accidentally passing one ID where another is expected (e.g., a `PostId` where a `UserId` is required), even though both are strings at runtime.

```ts
type UserId = string & { readonly __brand: unique symbol };
type PostId = string & { readonly __brand: unique symbol };
```

---

**SA-12.**

```ts
function getUser(id: UserId): void {
  // ...
}

const plainString: string = "abc";
getUser(plainString); // Error: string is not assignable to UserId

const postId = "xyz" as PostId;
getUser(postId); // Error: PostId is not assignable to UserId
```

You typically create branded values through a constructor function: `function createUserId(id: string): UserId { return id as UserId; }`.

---

**SA-13.**
Vite uses esbuild to strip TypeScript type annotations during development. esbuild is extremely fast because it only removes types — it does not perform type checking, semantic analysis, or emit diagnostics. This means Vite's dev server starts quickly, but type errors will not be caught by Vite itself.

---

**SA-14.**
Since Vite does not type-check, you ensure type safety through separate mechanisms: (1) your IDE (VS Code) provides real-time type checking as you edit, (2) you run `tsc --noEmit` as a separate command or build step to catch project-wide type errors, and (3) you add `tsc --noEmit` to your CI pipeline to prevent type errors from reaching production.

---

**SA-15.**
`exactOptionalPropertyTypes` distinguishes between a property being absent and a property being explicitly `undefined`. Without it, `{ name?: string }` allows both `{}` and `{ name: undefined }`. With it, `{ name: undefined }` is an error unless the type explicitly includes `| undefined`: `{ name?: string | undefined }`. This matters when APIs treat missing properties differently from `undefined` values.

---

**SA-16.**
The most critical problem is `"strict": false`. The syllabus requires strict mode for all new projects. Fix: `"strict": true`. Additional improvements: `target` should be at least `"ES2015"` or higher (ES5 is rarely needed in 2026), `module` should be `"ESNext"` for a modern bundler, and `moduleResolution` should be `"bundler"` for Vite compatibility. The full fix:

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "strict": true,
    "moduleResolution": "bundler",
    "noUncheckedIndexedAccess": true
  }
}
```

---

### Part C: Multiple Choice

| # | Answer | Explanation |
|---|---|---|
| MC-1 | **(c)** | `noUncheckedIndexedAccess` is NOT part of `strict`. It must be enabled separately. |
| MC-2 | **(b)** | With the flag, any indexed access includes `undefined`: `obj["c"]` is `number | undefined`. |
| MC-3 | **(b)** | `as const` produces a readonly tuple with literal element types: `readonly ["red", "green", "blue"]`. |
| MC-4 | **(b)** | `as const` infers `port` as the literal type `3000`, not the widened `number`. |
| MC-5 | **(b)** | The template literal type matches any string starting with `"on"` followed by any string. |
| MC-6 | **(b)** | Branded types create compile-time nominal distinctions. The `__brand` property does not exist at runtime. |
| MC-7 | **(b)** | A plain `string` is not assignable to `UserId` because it lacks the phantom brand intersection. |
| MC-8 | **(b)** | `import type` is erased entirely. A regular `import` may remain in the output if the module has side effects. |
| MC-9 | **(b)** | `export {}` converts the file to a module with its own scope, exporting nothing. |
| MC-10 | **(b)** | `"bundler"` resolution matches modern bundler behavior including `exports` fields and extensionless imports. |
| MC-11 | **(b)** | Vite uses esbuild for fast type stripping. It does not type-check. |
| MC-12 | **(b)** | Type checking is done separately via `tsc --noEmit`, your IDE, or a CI step. |
| MC-13 | **(b)** | `target` determines which JS syntax is downleveled (e.g., arrow functions, optional chaining). |
| MC-14 | **(b)** | `lib` controls which built-in declarations are available (DOM, ES2020, etc.). |
| MC-15 | **(b)** | TypeScript strict mode is non-negotiable for new projects per the syllabus. |
| MC-16 | **(b)** | `noUncheckedIndexedAccess` makes `scores[0]` typed as `number | undefined`. Calling `.toFixed()` without checking is a compile error. |