# Week 2 Quiz: Advanced TypeScript

**Scope:** Generics, utility types (Partial, Pick, Omit, Record, Required, ReturnType), `satisfies` operator, discriminated unions, type guards, conditional types (intro), mapped types, `typeof` type operator, indexed access types, template literal types (awareness).

**Assigned Readings:**
- TS-HB: "Generics" (through "Generic Constraints")
- TS-HB: "Typeof Type Operator" and "Indexed Access Types"
- TS-HB: "Conditional Types"
- TS-HB: "Mapped Types"
- TS-HB: "Template Literal Types" (skim)
- TypeScript docs: "Utility Types" reference (Partial, Required, Pick, Omit, Record, ReturnType)
- Article: "The satisfies operator" (TS 4.9 release notes)

**Scoring:** Wrong answers on T/F and MC are subtracted from right answers. Do not guess.

---

## Part A: True / False (32 Questions)

---

**TF-1.** A generic function allows you to write a single function that works with multiple types while preserving type information about the specific type used at each call site.

**TF-2.** Generic type parameters are preserved at runtime and can be inspected using `typeof` at execution time.

**TF-3.** In `function identity<T>(value: T): T`, the type `T` is inferred from the argument passed at the call site.

**TF-4.** You can explicitly provide a type argument to a generic function: `identity<string>("hello")`.

**TF-5.** A generic constraint `T extends string` means `T` can only be `string` exactly — no subtypes or string literal types are allowed.

**TF-6.** The constraint `T extends { length: number }` allows `T` to be any type that has at least a `length` property of type `number`, including `string` and arrays.

**TF-7.** You can use one type parameter as a constraint for another: `<T, K extends keyof T>` ensures `K` is a valid key of `T`.

**TF-8.** `keyof T` produces a union of string literal types representing the property names of `T`.

**TF-9.** Indexed access types (`T[K]`) let you look up the type of a specific property on another type.

**TF-10.** `typeof` in a type position extracts the TypeScript type of a runtime variable, which is different from the JavaScript `typeof` operator.

**TF-11.** `Partial<T>` makes every property of `T` optional.

**TF-12.** `Required<T>` makes every property of `T` optional.

**TF-13.** `Pick<T, K>` creates a type containing only the properties of `T` whose keys are in `K`.

**TF-14.** `Omit<T, K>` creates a type containing all properties of `T` except those whose keys are in `K`.

**TF-15.** `Record<"a" | "b", number>` produces the type `{ a: number; b: number }`.

**TF-16.** `ReturnType<T>` extracts the return type of a function type.

**TF-17.** Mapped types use the syntax `[K in keyof T]` to iterate over the keys of a type and produce a new type with transformed properties.

**TF-18.** `Partial`, `Required`, and `Readonly` are all implemented as mapped types internally.

**TF-19.** Conditional types (`T extends U ? X : Y`) are evaluated at runtime to choose between `X` and `Y`.

**TF-20.** When a conditional type is applied to a union type, it distributes over each member of the union individually.

**TF-21.** `Exclude<T, U>` removes from union `T` all members that are assignable to `U`.

**TF-22.** `Extract<T, U>` removes from union `T` all members that are assignable to `U`.

**TF-23.** The `satisfies` operator changes the type of the variable to the target type, widening it.

**TF-24.** `satisfies` validates that a value matches a type while preserving the narrower inferred type of the value.

**TF-25.** In a discriminated union, the discriminant property must be a literal type that is unique to each member of the union.

**TF-26.** TypeScript can narrow a discriminated union in a `switch` statement by switching on the discriminant property.

**TF-27.** The exhaustive check pattern (`const _: never = value` in a `default` branch) produces a compile-time error if a new variant is added to a union without being handled.

**TF-28.** A custom type guard function uses the syntax `value is Type` in its return type position to tell TypeScript to narrow the type when the function returns `true`.

**TF-29.** Template literal types allow you to construct string types using backtick syntax at the type level, such as `` type Route = `/api/${string}` ``.

**TF-30.** A generic class can reference its type parameter in static members.

**TF-31.** Generic default parameters (e.g., `<T = string>`) provide a fallback type when no type argument is provided and one cannot be inferred.

**TF-32.** The `infer` keyword in conditional types allows you to declare a type variable to be inferred from a pattern match, such as extracting the element type of an array.

---

## Part B: Short Answer (16 Questions)

Answer in 1–4 sentences or a short code snippet. Write valid TypeScript where code is requested.

---

**SA-1.** Explain what a generic function is and why it is more useful than writing a function that accepts `any`.

---

**SA-2.** Write a generic function `first<T>` that takes an array of `T` and returns the first element (or `undefined` if the array is empty). Include the return type annotation.

---

**SA-3.** Explain what a generic constraint does. Write a function `getLength<T extends { length: number }>(item: T): number` and list three types that satisfy this constraint.

---

**SA-4.** What does `keyof` produce, and how does it relate to indexed access types? Given `type User = { name: string; age: number }`, what is `keyof User` and what is `User["name"]`?

---

**SA-5.** What is the difference between `Pick<T, K>` and `Omit<T, K>`? Given `type Full = { a: number; b: string; c: boolean }`, what are `Pick<Full, "a" | "c">` and `Omit<Full, "b">`?

---

**SA-6.** Write a `Record` type called `Scores` that maps student names (`"alice" | "bob" | "carol"`) to `number` values.

---

**SA-7.** Explain what a mapped type is. Write a mapped type `Nullable<T>` that takes an object type `T` and makes every property's type `T[K] | null`.

---

**SA-8.** What is the `satisfies` operator, and how does it differ from a type annotation? Give a concrete example where `satisfies` preserves a narrower type than an annotation would.

---

**SA-9.** What is a discriminated union? Write a type `Shape` that is a union of `{ kind: "circle"; radius: number }` and `{ kind: "rect"; width: number; height: number }`, then write a function `area(shape: Shape): number` that uses a `switch` on `kind` to calculate the area.

---

**SA-10.** Explain the exhaustive check pattern using `never`. Why does assigning an unhandled union member to `never` produce a compile error, and why is this useful?

---

**SA-11.** Write a custom type guard function `isString(value: unknown): value is string` and show how it narrows in the calling code.

---

**SA-12.** Explain in 2–3 sentences what conditional types are and when you might use them. You do not need to write complex conditional type syntax.

---

**SA-13.** What does the `typeof` type operator do in a type position? Write a short example showing how you extract a type from a value using `typeof`.

---

**SA-14.** What does `ReturnType<typeof fn>` produce? Write a function `fn` and show how `ReturnType` extracts its return type.

---

**SA-15.** What is the difference between `Exclude<T, U>` and `Extract<T, U>`? Given `type T = "a" | "b" | "c"`, what does `Exclude<T, "a">` produce? What does `Extract<T, "a" | "b">` produce?

---

**SA-16.** A colleague writes the following and finds that `config.endpoint` is typed as `string` instead of `"/api/v1"`. Explain what is wrong and how to fix it using `satisfies`.

```ts
const config: Record<string, string> = {
  endpoint: "/api/v1",
  env: "production",
};
// config.endpoint is string, not "/api/v1"
```

---

## Part C: Multiple Choice (16 Questions)

Choose the single best answer.

---

**MC-1.** What is the inferred return type of `identity("hello")`?

```ts
function identity<T>(value: T): T {
  return value;
}
const result = identity("hello");
```

(a) `string`
(b) `"hello"`
(c) `T`
(d) `any`

---

**MC-2.** Why does the following code produce an error?

```ts
function loggingIdentity<T>(arg: T): T {
  console.log(arg.length); // Error
  return arg;
}
```

(a) `T` could be any type, and not all types have a `length` property
(b) Generic functions cannot access properties
(c) `console.log` does not accept generic arguments
(d) `T` is always `never`

---

**MC-3.** Which version correctly constrains `T` so the function compiles?

(a) `function loggingIdentity<T extends object>(arg: T): T`
(b) `function loggingIdentity<T extends { length: number }>(arg: T): T`
(c) `function loggingIdentity<T = { length: number }>(arg: T): T`
(d) `function loggingIdentity<T extends any>(arg: T): T`

---

**MC-4.** What is the type of `result`?

```ts
type User = { name: string; age: number; email: string };
type Result = Omit<User, "email">;
```

(a) `{ name: string; age: number }`
(b) `{ email: string }`
(c) `{ name: string; age: number; email: string }`
(d) `{ name: string }`

---

**MC-5.** What does this mapped type produce?

```ts
type Flags<T> = {
  [K in keyof T]: boolean;
};
type Result = Flags<{ name: string; active: boolean }>;
```

(a) `{ name: boolean; active: boolean }`
(b) `{ name: string; active: boolean }`
(c) `boolean`
(d) `{ [key: string]: boolean }`

---

**MC-6.** What does the `satisfies` keyword do in this code?

```ts
const palette = {
  red: [255, 0, 0],
  green: "#00ff00",
} satisfies Record<string, string | number[]>;
```

(a) Changes the type of `palette` to `Record<string, string | number[]>`
(b) Validates the value matches the target type while keeping the narrower inferred type (so `palette.red` is `number[]`, not `string | number[]`)
(c) Makes `palette` immutable
(d) Is identical to using `as const`

---

**MC-7.** What is the type of `shape` inside `case "circle"`?

```ts
type Shape =
  | { kind: "circle"; radius: number }
  | { kind: "square"; side: number };

function describe(shape: Shape) {
  switch (shape.kind) {
    case "circle":
      // what is shape's type here?
  }
}
```

(a) `Shape`
(b) `{ kind: "circle"; radius: number }`
(c) `{ kind: "square"; side: number }`
(d) `never`

---

**MC-8.** If a third variant `{ kind: "triangle"; base: number; height: number }` is added to `Shape` but the `switch` is not updated, and the `default` branch contains `const _: never = shape`, what happens?

(a) No error; the default branch handles all remaining cases
(b) A runtime error when a triangle is passed
(c) A compile-time error because the triangle variant is not assignable to `never`
(d) TypeScript silently ignores the new variant

---

**MC-9.** What is `keyof { a: number; b: string; c: boolean }`?

(a) `string`
(b) `"a" | "b" | "c"`
(c) `number`
(d) `["a", "b", "c"]`

---

**MC-10.** What does the indexed access type `User["name"]` resolve to?

```ts
type User = { name: string; age: number };
```

(a) `"name"`
(b) `string`
(c) `User`
(d) `{ name: string }`

---

**MC-11.** What does this conditional type evaluate to?

```ts
type IsNumber<T> = T extends number ? "yes" : "no";
type A = IsNumber<42>;
type B = IsNumber<string>;
```

(a) `A` is `"yes"`, `B` is `"no"`
(b) `A` is `"no"`, `B` is `"yes"`
(c) Both are `"yes"`
(d) Both are `boolean`

---

**MC-12.** What does `Exclude<"a" | "b" | "c", "a" | "c">` produce?

(a) `"a" | "c"`
(b) `"b"`
(c) `"a" | "b" | "c"`
(d) `never`

---

**MC-13.** What does `Extract<"a" | "b" | "c", "a" | "c">` produce?

(a) `"b"`
(b) `"a" | "c"`
(c) `"a" | "b" | "c"`
(d) `never`

---

**MC-14.** What does this code produce for the type of `settings`?

```ts
const defaults = {
  theme: "dark",
  fontSize: 14,
  debug: false,
};
type Settings = typeof defaults;
```

(a) `{ theme: string; fontSize: number; debug: boolean }`
(b) `{ theme: "dark"; fontSize: 14; debug: false }`
(c) `object`
(d) `any`

---

**MC-15.** A type guard function has this signature: `function isFish(pet: Fish | Bird): pet is Fish`. What does `pet is Fish` mean?

(a) The function converts `pet` to `Fish` at runtime
(b) If the function returns `true`, TypeScript narrows `pet` to `Fish` in the calling scope
(c) The function throws if `pet` is not `Fish`
(d) `pet` is always `Fish` after calling this function, regardless of return value

---

**MC-16.** Why can't a generic class use its type parameter in `static` members?

```ts
class Box<T> {
  static defaultValue: T; // Error
}
```

(a) Static members belong to the class constructor, not instances, and there is only one copy shared across all instantiations — so `T` has no single resolved type
(b) TypeScript does not support static members
(c) Generic classes cannot have static members at all
(d) The `T` parameter must be explicitly provided for static members

---

---

## Answer Key

### Part A: True / False

| # | Answer | Explanation |
|---|---|---|
| TF-1 | **T** | Generics preserve type information across a function call, unlike `any` which discards it. |
| TF-2 | **F** | Generic type parameters are fully erased at compile time. There is no runtime representation. |
| TF-3 | **T** | TypeScript infers `T` from the argument: `identity("hello")` infers `T` as `"hello"`. |
| TF-4 | **T** | Explicit type arguments override inference: `identity<string>("hello")` forces `T` to `string`. |
| TF-5 | **F** | `T extends string` allows `string` and any subtype, including string literal types like `"hello"`. |
| TF-6 | **T** | Any type with a `length: number` property satisfies the constraint: strings, arrays, tuples, custom objects. |
| TF-7 | **T** | This is the standard pattern for type-safe property access: `<T, K extends keyof T>`. |
| TF-8 | **T** | `keyof { name: string; age: number }` produces `"name" | "age"`. |
| TF-9 | **T** | `User["name"]` resolves to `string` — the type of the `name` property on `User`. |
| TF-10 | **T** | `typeof x` in a type position extracts the compile-time type. The runtime `typeof` returns strings like `"string"`. |
| TF-11 | **T** | `Partial<T>` uses a mapped type to add `?` to every property. |
| TF-12 | **F** | `Required<T>` makes every property required (removes `?`). It is the opposite of `Partial`. |
| TF-13 | **T** | `Pick<User, "name">` produces `{ name: string }`. |
| TF-14 | **T** | `Omit<User, "name">` produces `{ age: number; email: string }` (everything except `name`). |
| TF-15 | **T** | `Record<K, V>` maps each key in `K` to value type `V`. With a literal union for keys, you get an object with exactly those keys. |
| TF-16 | **T** | `ReturnType<typeof fn>` extracts the return type of `fn`. |
| TF-17 | **T** | Mapped types iterate over keys with `in keyof` and produce new property types. |
| TF-18 | **T** | All three are defined as mapped types in TypeScript's `lib.es5.d.ts`. |
| TF-19 | **F** | Conditional types are resolved entirely at compile time within the type system. |
| TF-20 | **T** | Distributive conditional types apply the condition to each member of a union separately. `IsString<string | number>` distributes to `IsString<string> | IsString<number>`. |
| TF-21 | **T** | `Exclude<"a" | "b", "a">` produces `"b"`. |
| TF-22 | **F** | `Extract` keeps members assignable to `U` (the opposite of `Exclude`). `Extract<"a" | "b", "a">` produces `"a"`. |
| TF-23 | **F** | `satisfies` does not change the type. It validates without widening. |
| TF-24 | **T** | This is the key benefit: validation plus narrow type preservation. |
| TF-25 | **T** | The discriminant (e.g., `kind: "circle"`) must be a literal type unique to each union member for narrowing to work. |
| TF-26 | **T** | `switch (shape.kind)` narrows `shape` to the specific member in each `case`. |
| TF-27 | **T** | If an unhandled member reaches the `default` branch, it cannot be assigned to `never`, producing a compile error. |
| TF-28 | **T** | The `value is Type` syntax is a type predicate. When the function returns `true`, TypeScript narrows accordingly. |
| TF-29 | **T** | Template literal types use backtick syntax at the type level to construct string types from literal and type parts. |
| TF-30 | **F** | Static members belong to the class constructor, not instances. There is only one copy, so `T` has no single resolved type. The Handbook explicitly prohibits this. |
| TF-31 | **T** | `<T = string>` provides a default when no argument is given and inference has nothing to work with. |
| TF-32 | **T** | `infer` declares a type variable within a conditional type: `T extends Array<infer U> ? U : never` extracts the element type. |

### Part B: Short Answer

**SA-1.**
A generic function uses a type parameter (like `<T>`) to preserve type information across the call. Unlike `any`, which erases all type information and disables checking, a generic function maintains the relationship between input and output types. If you pass a `string`, the return type is `string` — not `any`.

---

**SA-2.**

```ts
function first<T>(arr: T[]): T | undefined {
  return arr[0];
}
```

The return type is `T | undefined` because the array could be empty.

---

**SA-3.**
A generic constraint restricts what types can be used as the type argument. `T extends { length: number }` means `T` must have at least a `length` property of type `number`. Three types that satisfy this: `string` (has `.length`), `number[]` (has `.length`), and `{ length: number; name: string }` (custom object with `.length`).

```ts
function getLength<T extends { length: number }>(item: T): number {
  return item.length;
}
```

---

**SA-4.**
`keyof` produces a union of the literal key names of a type. For `type User = { name: string; age: number }`, `keyof User` is `"name" | "age"`. Indexed access types use these keys to look up property types: `User["name"]` is `string`. Together they enable type-safe property access patterns like `<T, K extends keyof T>(obj: T, key: K): T[K]`.

---

**SA-5.**
`Pick<T, K>` creates a type with only the specified keys. `Omit<T, K>` creates a type with everything except the specified keys. They are complementary. For `type Full = { a: number; b: string; c: boolean }`:
- `Pick<Full, "a" | "c">` is `{ a: number; c: boolean }`
- `Omit<Full, "b">` is `{ a: number; c: boolean }` (same result in this case)

---

**SA-6.**

```ts
type Scores = Record<"alice" | "bob" | "carol", number>;
```

This produces `{ alice: number; bob: number; carol: number }`.

---

**SA-7.**
A mapped type iterates over the keys of a type using `[K in keyof T]` and produces a new type with transformed properties.

```ts
type Nullable<T> = {
  [K in keyof T]: T[K] | null;
};
```

Applied to `{ name: string; age: number }`, this produces `{ name: string | null; age: number | null }`.

---

**SA-8.**
`satisfies` validates that a value conforms to a target type without changing the variable's type. A type annotation (`const x: T = ...`) widens the type to `T`. With `satisfies`, the variable keeps its narrower inferred type.

```ts
// Annotation: routes.home is string
const routes: Record<string, string> = { home: "/", about: "/about" };

// satisfies: routes.home is "/"
const routes = { home: "/", about: "/about" } satisfies Record<string, string>;
```

---

**SA-9.**

```ts
type Shape =
  | { kind: "circle"; radius: number }
  | { kind: "rect"; width: number; height: number };

function area(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "rect":
      return shape.width * shape.height;
  }
}
```

A discriminated union is a union type where each member has a common property (the discriminant) with a unique literal type. TypeScript uses the discriminant to narrow the union in control flow.

---

**SA-10.**
`never` is the bottom type — no value is assignable to it. In a `default` branch after handling all union members, the remaining type is `never`. If a new variant is added to the union without updating the switch, that variant reaches the `default` branch, where it is not assignable to `never`, causing a compile error. This guarantees at compile time that all variants are handled.

---

**SA-11.**

```ts
function isString(value: unknown): value is string {
  return typeof value === "string";
}

function process(input: unknown) {
  if (isString(input)) {
    // input is narrowed to string here
    console.log(input.toUpperCase());
  }
}
```

The `value is string` return type is a type predicate that tells TypeScript to narrow `value` to `string` when the function returns `true`.

---

**SA-12.**
Conditional types use the syntax `T extends U ? X : Y` to select between two types based on whether `T` is assignable to `U`. They are resolved at compile time. You might use them to create utility types that behave differently for different inputs — for example, extracting the element type of an array (`T extends Array<infer U> ? U : T`) or filtering members from a union.

---

**SA-13.**
The `typeof` type operator in a type position extracts the TypeScript type of a value-level variable.

```ts
const config = { debug: true, retries: 3 };
type Config = typeof config;
// Config is { debug: boolean; retries: number }
```

This is distinct from the runtime `typeof` which returns a string like `"object"`.

---

**SA-14.**

```ts
function add(a: number, b: number) {
  return a + b;
}
type AddReturn = ReturnType<typeof add>;
// AddReturn is number
```

`ReturnType<typeof fn>` first uses `typeof` to get the function's type, then `ReturnType` extracts its return type.

---

**SA-15.**
`Exclude<T, U>` removes from `T` all members assignable to `U`. `Extract<T, U>` keeps only the members assignable to `U`. They are complements.

- `Exclude<"a" | "b" | "c", "a">` produces `"b" | "c"`
- `Extract<"a" | "b" | "c", "a" | "b">` produces `"a" | "b"`

---

**SA-16.**
The type annotation `Record<string, string>` widens the type of `config` so that all property values are typed as `string` — the literal `"/api/v1"` is lost. Fix using `satisfies`:

```ts
const config = {
  endpoint: "/api/v1",
  env: "production",
} satisfies Record<string, string>;
// config.endpoint is now "/api/v1"
```

`satisfies` validates the shape without widening, preserving the literal types.

---

### Part C: Multiple Choice

| # | Answer | Explanation |
|---|---|---|
| MC-1 | **(b)** | TypeScript infers `T` as the literal type `"hello"` from the argument, so the return type is `"hello"`. |
| MC-2 | **(a)** | `T` is unconstrained, so it could be `number`, `boolean`, or any type without `length`. TypeScript correctly rejects the property access. |
| MC-3 | **(b)** | `T extends { length: number }` constrains `T` to types that have `length`. Option (a) constrains to `object` but not all objects have `length`. Option (c) provides a default, not a constraint. Option (d) `extends any` is no constraint at all. |
| MC-4 | **(a)** | `Omit<User, "email">` removes `email`, leaving `{ name: string; age: number }`. |
| MC-5 | **(a)** | The mapped type replaces every property's type with `boolean`, producing `{ name: boolean; active: boolean }`. |
| MC-6 | **(b)** | `satisfies` validates structure without widening. `palette.red` keeps type `number[]` instead of becoming `string | number[]`. |
| MC-7 | **(b)** | The `switch` narrows on `kind`. In the `"circle"` case, `shape` is narrowed to `{ kind: "circle"; radius: number }`. |
| MC-8 | **(c)** | The triangle variant is not handled by any `case`, so it reaches `default` where it cannot be assigned to `never`. This is a compile-time error. |
| MC-9 | **(b)** | `keyof` produces the union of literal key names: `"a" | "b" | "c"`. |
| MC-10 | **(b)** | `User["name"]` is an indexed access type that resolves to the type of the `name` property: `string`. |
| MC-11 | **(a)** | `42 extends number` is true, so `A` is `"yes"`. `string extends number` is false, so `B` is `"no"`. |
| MC-12 | **(b)** | `Exclude` removes members assignable to the second argument. `"a"` and `"c"` are removed, leaving `"b"`. |
| MC-13 | **(b)** | `Extract` keeps members assignable to the second argument. `"a"` and `"c"` are kept. |
| MC-14 | **(a)** | `defaults` is declared with `const` but without `as const`, so properties are widened: `theme` is `string`, not `"dark"`. `typeof` extracts this widened type. |
| MC-15 | **(b)** | The `pet is Fish` return type is a type predicate. When the function returns `true`, TypeScript narrows `pet` to `Fish` in the calling scope. |
| MC-16 | **(a)** | Static members belong to the class constructor, not to instances. There is only one `Box.defaultValue` slot shared across all `Box<T>` instantiations, so there is no single `T` to resolve to. |