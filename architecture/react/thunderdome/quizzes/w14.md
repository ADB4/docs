# Week 14 Quiz: React Testing Library — Rendering, Queries, and user-event

**Scope:** RTL philosophy, `render` and `screen`, query variants (`getBy`, `queryBy`, `findBy`, `getAllBy`), query priority (`getByRole` > `getByLabelText` > `getByText` > `getByTestId`), accessible queries and ARIA roles, `user-event` vs. `fireEvent`, `waitFor` and async utilities, `within`, `cleanup`, debugging with `screen.debug()` and `logRoles`.

**Assigned Readings:**
- RTL: "Introduction" and "Guiding Principles"
- TL: "About Queries" (full query priority table)
- TL: "ByRole" query page
- UE: "Introduction," "Setup," and API pages (`click`, `type`, `clear`, `selectOptions`, `keyboard`, `tab`)
- KCD: "Common Mistakes with React Testing Library"
- RTL: "API" reference (`render`, `wrapper`, `cleanup`)

**Scoring:** Wrong answers on T/F and MC are subtracted from right answers. Do not guess. Short answer questions are graded on correctness and conciseness — do not write more than is asked for.

---

## Part A: True / False (72 Questions)

---

**TF-1.** React Testing Library's guiding principle is: "The more your tests resemble the way your software is used, the more confidence they can give you."

**TF-2.** React Testing Library exposes component instance methods and internal state so you can test them directly.

**TF-3.** RTL encourages testing components the way a user would interact with them: finding elements by visible text, labels, or roles, then simulating user actions.

**TF-4.** The `render` function from RTL renders a React component into a DOM container and returns utility functions for querying the rendered output.

**TF-5.** The `screen` object is the recommended way to query the rendered output. It references the `document.body` and provides all query methods.

**TF-6.** Using `screen` instead of destructuring query methods from `render` is a common best practice because it keeps the test code more consistent and readable.

**TF-7.** The `render` function requires a DOM environment (like `jsdom`) because it renders the component into an actual DOM tree.

**TF-8.** RTL's `cleanup` function unmounts the rendered component and removes it from the DOM. In Vitest with RTL, cleanup runs automatically after each test.

**TF-9.** You need to manually call `cleanup()` in an `afterEach` block in every test file when using Vitest with RTL.

**TF-10.** `getByRole` is the highest-priority query in RTL's recommended query hierarchy because it queries elements the way assistive technology sees them.

**TF-11.** `getByTestId` is the preferred query method because it is the most stable and never breaks.

**TF-12.** The recommended query priority order is: `getByRole` > `getByLabelText` > `getByText` > `getByTestId`.

**TF-13.** `getByRole('button', { name: /submit/i })` finds a button whose accessible name matches the regex `/submit/i`.

**TF-14.** The `name` option in `getByRole` matches against the element's accessible name, which can come from text content, `aria-label`, `aria-labelledby`, or an associated `<label>`.

**TF-15.** HTML `<button>` elements have an implicit ARIA role of `"button"` without needing an explicit `role` attribute.

**TF-16.** An `<input type="text">` has an implicit ARIA role of `"textbox"`.

**TF-17.** An `<a href="...">` element has an implicit ARIA role of `"link"`.

**TF-18.** An `<h1>` element has an implicit ARIA role of `"heading"` with `level: 1`.

**TF-19.** You can query a specific heading level with `getByRole('heading', { level: 2 })` to find an `<h2>`.

**TF-20.** `<select>` elements have an implicit ARIA role of `"combobox"`.

**TF-21.** An `<input type="checkbox">` has an implicit ARIA role of `"checkbox"`.

**TF-22.** `getByLabelText` is the preferred query for form fields because it mimics how users identify form controls — by their labels.

**TF-23.** `getByLabelText("Email")` finds an input that has an associated `<label>` with the text "Email", either via `htmlFor`/`id` pairing or by wrapping.

**TF-24.** `getByText` finds elements by their visible text content and is the best choice for non-interactive content like paragraphs and headings.

**TF-25.** `getByPlaceholderText` is a higher-priority query than `getByLabelText` because placeholder text is always visible.

**TF-26.** `getByDisplayValue` finds form elements by their current value and is useful for finding inputs that already have a value filled in.

**TF-27.** `getByAltText` is used to find elements (typically images) by their `alt` attribute text.

**TF-28.** `getByTitle` queries elements by their `title` attribute and is a higher-priority query than `getByRole`.

**TF-29.** `getByTestId` queries elements by their `data-testid` attribute and should be used as a last resort when no semantic query works.

**TF-30.** `getBy` queries throw an error if no matching element is found.

**TF-31.** `getBy` queries throw an error if more than one matching element is found.

**TF-32.** `queryBy` returns `null` if no matching element is found, rather than throwing.

**TF-33.** `queryBy` is the correct choice when you want to assert that an element does NOT exist in the DOM.

**TF-34.** `findBy` queries return a Promise that resolves when the element appears in the DOM, making them suitable for elements that appear asynchronously.

**TF-35.** `findBy` is equivalent to calling `waitFor` with a `getBy` query inside it.

**TF-36.** `getAllBy` returns an array of all matching elements and throws if no elements are found.

**TF-37.** `queryAllBy` returns an empty array if no matching elements are found, rather than throwing.

**TF-38.** If you want to assert that exactly 3 items are rendered in a list, you should use `getAllByRole('listitem')` and assert on the array length.

**TF-39.** `user-event` simulates user interactions more realistically than `fireEvent` because it fires all the intermediate events that a real browser would (focus, keydown, keypress, input, keyup, etc.).

**TF-40.** `fireEvent.click(element)` fires only the `click` event. `user.click(element)` fires the full sequence: `pointerdown`, `mousedown`, `pointerup`, `mouseup`, `click`, and potentially `focus`.

**TF-41.** `user-event` is always preferred over `fireEvent` because it better simulates actual user behavior.

**TF-42.** The recommended setup for `user-event` in a test is `const user = userEvent.setup()`, which returns a user instance for the test.

**TF-43.** `user.type(element, "hello")` simulates a user typing "hello" character by character, firing all keyboard events for each character.

**TF-44.** `user.clear(element)` clears the current value of a text input by selecting all text and deleting it.

**TF-45.** `user.click(element)` is synchronous and does not need to be awaited.

**TF-46.** All `user-event` methods return Promises and should be awaited.

**TF-47.** `user.selectOptions(selectElement, ['option1'])` simulates selecting an option from a `<select>` dropdown.

**TF-48.** `user.tab()` simulates pressing the Tab key, moving focus to the next focusable element.

**TF-49.** `user.keyboard('{Enter}')` simulates pressing the Enter key.

**TF-50.** `waitFor` repeatedly calls the provided callback until it stops throwing or the timeout is reached.

**TF-51.** `waitFor` is the only way to test async behavior in RTL.

**TF-52.** `waitForElementToBeRemoved` waits until the queried element is no longer in the DOM, useful for testing loading states that disappear.

**TF-53.** You should prefer `findBy` over the `waitFor` + `getBy` combination for waiting for an element to appear.

**TF-54.** Wrapping `render()` calls inside `act()` manually is necessary in RTL tests to avoid state update warnings.

**TF-55.** RTL's `render` and `user-event` methods already handle `act()` internally, so you should not manually wrap calls in `act()` in most cases.

**TF-56.** `screen.debug()` prints the current DOM tree to the console, which is useful for debugging test failures.

**TF-57.** `screen.debug()` takes an optional element argument: `screen.debug(element)` prints only that element's subtree.

**TF-58.** `logRoles` is an RTL utility that prints all the ARIA roles found in the rendered DOM, helping you discover which roles to use in `getByRole`.

**TF-59.** The `within` function from RTL lets you scope queries to a specific container element, creating a "mini screen" for a subtree.

**TF-60.** `within(container).getByText("hello")` searches for "hello" only inside `container`, not the entire document.

**TF-61.** The `render` function's `wrapper` option lets you specify a component that wraps the rendered component, useful for providing Context, ThemeProvider, or other required providers.

**TF-62.** RTL tests should always test components in complete isolation, never with their child components.

**TF-63.** RTL encourages testing components as users experience them, which often means rendering a component with its real children rather than mocking everything.

**TF-64.** `getByRole('textbox')` can find both `<input type="text">` and `<textarea>` elements because both have the `textbox` role.

**TF-65.** Regex matchers passed to query methods (e.g., `getByText(/submit/i)`) are useful for case-insensitive matching and partial text matching.

**TF-66.** `getByText("Submit")` performs an exact string match by default and will not match "Submit Form".

**TF-67.** You can pass `{ exact: false }` as an option to `getByText` to enable substring matching.

**TF-68.** `getByRole('button', { name: "Submit" })` performs an exact string match on the accessible name by default.

**TF-69.** `screen.getByRole('dialog')` can find elements with `role="dialog"` or native `<dialog>` elements.

**TF-70.** Using `data-testid` attributes creates a coupling between tests and the DOM that is invisible to users and should be minimized.

**TF-71.** `user.type(input, "abc{backspace}")` types "abc" and then simulates pressing Backspace, resulting in "ab" in the input.

**TF-72.** `findByRole` and other `findBy` queries accept a `timeout` option that controls how long to wait before giving up.

---

## Part B: Short Answer (16 Questions)

---

**SA-1.** List the RTL query priority hierarchy from highest to lowest priority. For each level, give one example query and explain why it has that priority.

---

**SA-2.** Explain the difference between `getBy`, `queryBy`, and `findBy`. When would you use each one?

---

**SA-3.** What is the accessible name of the following button, and how would you query it with `getByRole`?

```tsx
<button aria-label="Close dialog">X</button>
```

---

**SA-4.** Write a test that renders a `LoginForm` component, finds the email input by its label, the password input by its label, and the submit button by its role, types credentials, clicks submit, and asserts that a success message appears. Use `user-event` and accessible queries.

---

**SA-5.** Explain why `user-event` is preferred over `fireEvent`. Give a specific example where the difference matters.

---

**SA-6.** What does `screen.debug()` do? When would you use it, and what additional debugging tool does RTL provide for discovering ARIA roles?

---

**SA-7.** Explain the `within` utility. Write a short test snippet that uses `within` to find a button inside a specific section of the page.

---

**SA-8.** Why does KCD say not to wrap things in `act()` when using RTL? What does RTL do behind the scenes that makes manual `act()` unnecessary?

---

**SA-9.** Write a test that asserts an element does NOT exist in the DOM. Explain why you must use `queryBy` instead of `getBy` for this assertion.

---

**SA-10.** Explain the `render` function's `wrapper` option. Write a test that renders a component with a ThemeProvider wrapper.

---

**SA-11.** What is the implicit ARIA role for each of these HTML elements: `<button>`, `<a href="...">`, `<input type="text">`, `<input type="checkbox">`, `<h2>`, `<ul>`, `<li>`, `<img alt="photo">`?

---

**SA-12.** Explain the difference between `findBy` and `waitFor` + `getBy`. When should you use each pattern?

---

**SA-13.** KCD's article "Common Mistakes with React Testing Library" lists several mistakes. Name three specific mistakes and explain the correct approach for each.

---

**SA-14.** What does `getAllByRole('listitem')` return when there are 5 `<li>` elements inside a `<ul>`? How do you assert on the count?

---

**SA-15.** A developer writes this test but it fails. Explain why and fix it.

```tsx
it("shows error on invalid email", () => {
  render(<LoginForm />);
  const input = screen.getByTestId("email-input");
  fireEvent.change(input, { target: { value: "invalid" } });
  fireEvent.click(screen.getByTestId("submit-btn"));
  expect(screen.getByTestId("error-msg")).toBeInTheDocument();
});
```

Focus on the query choices and event simulation, not the assertion logic.

---

**SA-16.** What is `waitForElementToBeRemoved`? Write a test that waits for a loading spinner to disappear before asserting the final content is rendered.

---

## Part C: Multiple Choice (48 Questions)

Choose the single best answer.

---

**MC-1.** RTL's guiding principle is:

(a) "Test internals to catch bugs early"
(b) "The more your tests resemble the way your software is used, the more confidence they can give you"
(c) "Always mock child components for isolation"
(d) "Maximize code coverage for confidence"

---

**MC-2.** What is the recommended way to access queries in RTL tests?

(a) Destructure queries from `render()`: `const { getByText } = render(<App />)`
(b) Use the `screen` object: `screen.getByText("hello")`
(c) Use `document.querySelector`
(d) Access the component instance directly

---

**MC-3.** Which query should you try first when looking for a button?

(a) `getByText("Submit")`
(b) `getByTestId("submit-button")`
(c) `getByRole('button', { name: /submit/i })`
(d) `document.querySelector('button')`

---

**MC-4.** Which query is best for finding a text input with a visible label "Email Address"?

(a) `getByTestId("email-input")`
(b) `getByPlaceholderText("Email Address")`
(c) `getByLabelText("Email Address")`
(d) `getByRole('input')`

---

**MC-5.** `getByTestId` should be used:

(a) As the default query for all elements
(b) For interactive elements like buttons
(c) As a last resort when no semantic query works
(d) For all form inputs

---

**MC-6.** What does `getByRole('heading', { level: 2 })` match?

(a) Any element with `role="heading"`
(b) An `<h2>` element
(c) Any heading element (`<h1>` through `<h6>`)
(d) An element with `aria-level="2"`

---

**MC-7.** What is the implicit ARIA role of a `<select>` element?

(a) `select`
(b) `dropdown`
(c) `combobox`
(d) `listbox`

---

**MC-8.** What does `getBy` do when no matching element is found?

(a) Returns `null`
(b) Returns an empty array
(c) Throws an error
(d) Returns `undefined`

---

**MC-9.** What does `queryBy` do when no matching element is found?

(a) Throws an error
(b) Returns `null`
(c) Returns `undefined`
(d) Returns `false`

---

**MC-10.** When should you use `queryBy` instead of `getBy`?

(a) When the element might appear asynchronously
(b) When asserting that an element does NOT exist in the DOM
(c) When querying multiple elements
(d) When the element has no accessible name

---

**MC-11.** `findBy` queries are most useful when:

(a) The element is already in the DOM
(b) The element will appear asynchronously after some state change or data fetch
(c) You want to find multiple elements
(d) You want to assert the element does not exist

---

**MC-12.** `findBy` returns:

(a) The element immediately
(b) `null` if not found
(c) A Promise that resolves when the element appears
(d) An array of elements

---

**MC-13.** What does `getAllByRole('listitem')` return?

(a) The first `<li>` element found
(b) An array of all elements with the `listitem` role
(c) A Promise resolving to an array
(d) `null` if no items are found

---

**MC-14.** What happens when `getAllBy` finds no matching elements?

(a) Returns an empty array
(b) Returns `null`
(c) Throws an error
(d) Returns `undefined`

---

**MC-15.** What is the difference between `fireEvent.click(element)` and `user.click(element)`?

(a) They are identical
(b) `fireEvent.click` dispatches only the `click` event; `user.click` fires the full pointer/mouse/click sequence
(c) `user.click` is synchronous; `fireEvent.click` is async
(d) `fireEvent.click` works on all elements; `user.click` only works on buttons

---

**MC-16.** How do you set up `user-event` in a test?

(a) `import user from '@testing-library/user-event'`
(b) `const user = userEvent.setup()` at the beginning of the test or `beforeEach`
(c) `const user = new UserEvent()`
(d) `fireEvent.enableUserEvents()`

---

**MC-17.** `user.type(element, "hello")` simulates:

(a) Setting the input's value property directly to "hello"
(b) Typing "hello" character by character, firing keyboard events for each character
(c) Pasting "hello" into the input
(d) Calling `element.setAttribute("value", "hello")`

---

**MC-18.** Which `user-event` method clears the current value of an input field?

(a) `user.delete(element)`
(b) `user.clear(element)`
(c) `user.reset(element)`
(d) `user.empty(element)`

---

**MC-19.** `user-event` methods are:

(a) Synchronous — they resolve immediately
(b) Asynchronous — they return Promises and should be awaited
(c) Some are sync and some are async
(d) Only async in strict mode

---

**MC-20.** `user.tab()` simulates:

(a) Opening a new browser tab
(b) Inserting a tab character
(c) Pressing the Tab key to move focus to the next focusable element
(d) Indenting text

---

**MC-21.** `user.selectOptions(select, ['value1'])` is used for:

(a) Selecting text in an input
(b) Selecting an option from a `<select>` dropdown or listbox
(c) Checking checkboxes
(d) Choosing radio buttons

---

**MC-22.** What does `waitFor` do?

(a) Waits for a specified number of milliseconds
(b) Repeatedly calls the provided callback until it stops throwing or the timeout is reached
(c) Pauses the test execution
(d) Waits for all Promises to resolve

---

**MC-23.** What is the advantage of using `findBy` over `waitFor` + `getBy`?

(a) `findBy` is faster
(b) `findBy` combines the wait-and-query into a single, more readable call
(c) `findBy` works without a DOM
(d) `findBy` never times out

---

**MC-24.** `waitForElementToBeRemoved` is used to:

(a) Remove an element from the DOM
(b) Wait until a queried element is no longer present in the DOM
(c) Delete a component from memory
(d) Unmount a component

---

**MC-25.** Should you manually wrap RTL calls in `act()`?

(a) Yes, always
(b) No — `render` and `user-event` already handle `act()` internally
(c) Only for async operations
(d) Only for class components

---

**MC-26.** `screen.debug()` prints:

(a) The component's props and state
(b) The current DOM tree to the console
(c) A list of all available queries
(d) The React fiber tree

---

**MC-27.** `logRoles(container)` is useful for:

(a) Logging all event handlers on an element
(b) Discovering which ARIA roles are present in the rendered DOM, helping you write `getByRole` queries
(c) Printing the component hierarchy
(d) Listing all CSS classes

---

**MC-28.** The `within` function:

(a) Limits a test to a specific time window
(b) Scopes queries to a specific container element
(c) Creates a new `describe` block
(d) Filters test files

---

**MC-29.** What does the `wrapper` option in `render` do?

(a) Wraps the test function in a try/catch
(b) Wraps the rendered component in a specified provider component (e.g., ThemeProvider)
(c) Wraps the DOM in a shadow root
(d) Wraps the component in React.StrictMode

---

**MC-30.** Which of the following is a "Common Mistake" identified by KCD?

(a) Using `screen` to access queries
(b) Using `getByRole` as the primary query
(c) Destructuring queries from `render` instead of using `screen`
(d) Using `user-event` instead of `fireEvent`

---

**MC-31.** Another common mistake identified by KCD is:

(a) Using `findBy` for async elements
(b) Unnecessarily wrapping things in `act()`
(c) Using `getByLabelText` for form inputs
(d) Awaiting `user-event` methods

---

**MC-32.** KCD recommends using `findBy` instead of:

(a) `getBy`
(b) `queryBy`
(c) `waitFor` + `getBy` for waiting for elements to appear
(d) `getAllBy`

---

**MC-33.** What is the correct way to assert that an element is NOT in the DOM?

(a) `expect(screen.getByText("Error")).not.toBeInTheDocument()`
(b) `expect(screen.queryByText("Error")).not.toBeInTheDocument()`
(c) `expect(screen.findByText("Error")).not.toBeInTheDocument()`
(d) `expect(screen.getByText("Error")).toBeNull()`

---

**MC-34.** Where does `.toBeInTheDocument()` come from?

(a) It is built into Vitest
(b) It is built into RTL
(c) It comes from `@testing-library/jest-dom`, which must be imported in a setup file
(d) It comes from `jsdom`

---

**MC-35.** `getByText(/submit/i)` uses the `i` flag in the regex to:

(a) Make the match case-sensitive
(b) Make the match case-insensitive
(c) Enable multiline matching
(d) Match only the first character

---

**MC-36.** `getByText("Submit")` with default options will match:

(a) Any element containing "Submit" as a substring
(b) Only an element whose entire text content is exactly "Submit"
(c) Any element with "Submit" in its `value` attribute
(d) Only `<button>` elements with "Submit" text

---

**MC-37.** To make `getByText` perform a substring match, you can:

(a) Pass `{ exact: false }` as the second argument
(b) Pass `{ partial: true }`
(c) Use `getByTextContaining` instead
(d) You cannot; use regex instead

---

**MC-38.** What is the accessible name of this button?

```tsx
<button>Save Changes</button>
```

(a) `"button"`
(b) `"Save Changes"`
(c) `"save-changes"`
(d) It has no accessible name

---

**MC-39.** What is the accessible name of this input?

```tsx
<label htmlFor="email">Email Address</label>
<input id="email" type="text" />
```

(a) `"email"`
(b) `"Email Address"`
(c) `"text"`
(d) `"textbox"`

---

**MC-40.** Which query finds the input in MC-39?

(a) `getByRole('textbox', { name: /email address/i })`
(b) `getByRole('input', { name: /email/i })`
(c) `getByTestId("email")`
(d) `getByRole('textbox', { id: 'email' })`

---

**MC-41.** `user.keyboard('{Enter}')` simulates:

(a) Typing the literal text "{Enter}"
(b) Pressing the Enter key
(c) Submitting a form
(d) Creating a new line

---

**MC-42.** `user.type(input, "abc{backspace}")` results in:

(a) `"abc{backspace}"` as the input value
(b) `"ab"` as the input value (types "abc" then deletes the last character)
(c) `"abcBackspace"` as the input value
(d) An error because `{backspace}` is not valid

---

**MC-43.** RTL automatically cleans up after each test by:

(a) Deleting all test files
(b) Unmounting rendered components and clearing the DOM
(c) Resetting the JavaScript runtime
(d) Restarting the test environment

---

**MC-44.** A test needs to check that a tooltip appears when hovering over a button. Which `user-event` method should be used?

(a) `user.click(button)`
(b) `user.hover(button)`
(c) `user.mouseOver(button)`
(d) `user.focus(button)`

---

**MC-45.** The `<img alt="User avatar">` element can be found with:

(a) `getByRole('img', { name: /user avatar/i })`
(b) `getByAltText(/user avatar/i)`
(c) Both (a) and (b)
(d) Neither — images cannot be queried

---

**MC-46.** A `<nav>` element has the implicit ARIA role:

(a) `navigation`
(b) `nav`
(c) `menu`
(d) `region`

---

**MC-47.** Which query would you use to find a `<textarea>` with a label "Description"?

(a) `getByRole('textarea', { name: /description/i })`
(b) `getByRole('textbox', { name: /description/i })`
(c) `getByLabelText(/description/i)`
(d) Both (b) and (c) work

---

**MC-48.** `queryAllByRole('listitem')` returns what when there are no `<li>` elements?

(a) Throws an error
(b) Returns `null`
(c) Returns an empty array `[]`
(d) Returns `undefined`

---

---

## Answer Key

---

### Part A: True / False

| # | Answer | Explanation |
|---|---|---|
| TF-1 | **T** | This is RTL's stated guiding principle. Tests should mirror real user interactions. |
| TF-2 | **F** | RTL intentionally does NOT expose component instances or internal state. This is by design — it forces you to test behavior, not implementation. |
| TF-3 | **T** | RTL's API is built around finding elements the way users do (by visible text, roles, labels) and interacting with them (clicking, typing). |
| TF-4 | **T** | `render()` renders the component into `jsdom`'s document and returns utilities for interacting with the rendered output. |
| TF-5 | **T** | `screen` queries against `document.body` and provides all query variants. It is the recommended way to access queries. |
| TF-6 | **T** | Using `screen` avoids destructuring and keeps all queries accessed the same way across tests. KCD lists destructuring from `render` as a common mistake. |
| TF-7 | **T** | `render` creates real DOM elements. Without a DOM environment, DOM APIs like `document.createElement` are unavailable. |
| TF-8 | **T** | `cleanup` unmounts components and clears the DOM. RTL with Vitest auto-cleans after each test via a setup hook. |
| TF-9 | **F** | With Vitest and RTL properly configured (via `setupFiles` or auto-cleanup), cleanup happens automatically. Manual cleanup is unnecessary. |
| TF-10 | **T** | `getByRole` queries by ARIA role, which is how assistive technologies (and therefore many users) interact with the page. It is the highest-priority query. |
| TF-11 | **F** | `getByTestId` is the lowest-priority query. It tests nothing about accessibility and should only be used as a last resort. |
| TF-12 | **T** | This is RTL's recommended priority: role-based → label-based → text-based → test ID. The hierarchy prioritizes queries accessible to all users. |
| TF-13 | **T** | The `name` option in `getByRole` filters by accessible name. The regex `/submit/i` performs a case-insensitive match. |
| TF-14 | **T** | Accessible name can come from multiple sources: text content, `aria-label`, `aria-labelledby`, or associated `<label>` elements. |
| TF-15 | **T** | `<button>` has the implicit ARIA role `button` per the HTML specification. |
| TF-16 | **T** | `<input type="text">` maps to the ARIA role `textbox`. |
| TF-17 | **T** | `<a href="...">` has the implicit role `link`. (Note: `<a>` without `href` has no implicit role.) |
| TF-18 | **T** | `<h1>` has role `heading` with `aria-level` of `1`. You can query it with `getByRole('heading', { level: 1 })`. |
| TF-19 | **T** | The `level` option in `getByRole('heading', { level: 2 })` matches heading elements of that specific level. |
| TF-20 | **T** | A `<select>` (particularly with no `multiple` attribute and no `size > 1`) has the implicit role `combobox`. |
| TF-21 | **T** | `<input type="checkbox">` has the implicit ARIA role `checkbox`. |
| TF-22 | **T** | `getByLabelText` mimics how sighted users (via label text) and assistive technology users (via label association) identify form controls. |
| TF-23 | **T** | `getByLabelText` follows the label-input association, whether via `htmlFor`/`id`, wrapping `<label>`, or `aria-labelledby`. |
| TF-24 | **T** | `getByText` is good for non-interactive elements where the visible text is the most natural identifier. For interactive elements, `getByRole` is preferred. |
| TF-25 | **F** | `getByPlaceholderText` is lower priority than `getByLabelText`. Labels are more accessible than placeholders, which disappear when the user starts typing. |
| TF-26 | **T** | `getByDisplayValue` is useful for finding pre-filled form fields by their current value. |
| TF-27 | **T** | `getByAltText` targets the `alt` attribute, primarily used for images. |
| TF-28 | **F** | `getByTitle` is a lower-priority semantic query. `getByRole` is always the highest priority. |
| TF-29 | **T** | `getByTestId` is the last resort. It has no semantic meaning and is invisible to users. |
| TF-30 | **T** | `getBy` throws immediately if no match is found, which causes the test to fail with a descriptive error. |
| TF-31 | **T** | `getBy` also throws if multiple matches are found. It expects exactly one matching element. |
| TF-32 | **T** | `queryBy` returns `null` on no match instead of throwing, making it safe for negative assertions. |
| TF-33 | **T** | `queryBy` + `.not.toBeInTheDocument()` is the correct pattern for asserting absence. `getBy` would throw before the assertion runs. |
| TF-34 | **T** | `findBy` returns a Promise that resolves when the element appears, which is how you handle elements that render asynchronously. |
| TF-35 | **T** | `findBy` is syntactic sugar for `waitFor(() => getBy(...))`. |
| TF-36 | **T** | `getAllBy` returns an array of matching elements and throws if the array would be empty. |
| TF-37 | **T** | `queryAllBy` returns an empty array `[]` when no matches are found, rather than throwing. |
| TF-38 | **T** | `getAllByRole('listitem')` returns all matching elements, and you can assert `expect(items).toHaveLength(3)`. |
| TF-39 | **T** | `user-event` dispatches the full event sequence that a real browser would, including focus, pointer, mouse, keyboard, and input events. |
| TF-40 | **T** | `fireEvent.click` dispatches only the synthetic `click` event. `user.click` fires the realistic sequence: pointer events, mouse events, focus, and click. |
| TF-41 | **T** | `user-event` is always preferred because it more accurately simulates real user interactions, catching bugs that `fireEvent` would miss. |
| TF-42 | **T** | `userEvent.setup()` creates a configured user instance. This pattern is recommended over calling `userEvent.click()` directly. |
| TF-43 | **T** | `user.type` simulates character-by-character input, including `keydown`, `keypress`, `input`, and `keyup` for each character. |
| TF-44 | **T** | `user.clear` selects all text in the input and deletes it, simulating Ctrl+A followed by Delete. |
| TF-45 | **F** | All `user-event` methods are async and return Promises. You must `await` them. |
| TF-46 | **T** | Every `user-event` interaction method returns a Promise. Always `await` them to ensure all events have been processed. |
| TF-47 | **T** | `user.selectOptions` simulates selecting one or more options from a `<select>` or listbox element. |
| TF-48 | **T** | `user.tab()` moves focus to the next focusable element, simulating the Tab key press. |
| TF-49 | **T** | Special keys are specified with curly braces: `{Enter}`, `{Escape}`, `{Tab}`, `{Backspace}`, etc. |
| TF-50 | **T** | `waitFor` polls the callback at intervals until it succeeds (no throw) or the timeout expires, at which point it throws the last error. |
| TF-51 | **F** | `findBy` queries also handle async elements. `waitFor` is for more complex async scenarios; `findBy` is preferred for simply waiting for an element to appear. |
| TF-52 | **T** | `waitForElementToBeRemoved` waits for the element to be removed from the DOM. It is useful for verifying that loading indicators disappear. |
| TF-53 | **T** | `findBy` is a cleaner, more readable API for the common case of waiting for an element to appear. KCD recommends it over `waitFor` + `getBy`. |
| TF-54 | **F** | RTL already wraps `render` and `fireEvent` in `act()`. Manually adding `act()` is unnecessary and is listed as a common mistake by KCD. |
| TF-55 | **T** | RTL handles `act()` internally. Adding it manually creates noise and indicates a misunderstanding of the library. |
| TF-56 | **T** | `screen.debug()` pretty-prints the current DOM to the console, helping you see what the test "sees." |
| TF-57 | **T** | `screen.debug(element)` narrows the output to just the subtree of the specified element. |
| TF-58 | **T** | `logRoles` lists all ARIA roles in the container, which helps you write correct `getByRole` queries. |
| TF-59 | **T** | `within` scopes all queries to a specific container, useful when the same text or role appears in multiple parts of the page. |
| TF-60 | **T** | `within(container)` returns a bound set of query methods that only search inside `container`. |
| TF-61 | **T** | The `wrapper` option in `render` wraps the component in a provider. This avoids repeating provider boilerplate in every test. |
| TF-62 | **F** | RTL encourages rendering components with their real children when practical. Full isolation (mocking all children) tests implementation details rather than behavior. |
| TF-63 | **T** | RTL's philosophy favors testing components as users experience them, which means rendering with real children unless there is a specific reason to mock. |
| TF-64 | **T** | Both `<input type="text">` and `<textarea>` have the `textbox` role, so `getByRole('textbox')` can match either. |
| TF-65 | **T** | Regex matchers are useful for flexible matching. `/submit/i` matches "Submit", "SUBMIT", "submit", or any element containing "submit" as a substring. |
| TF-66 | **T** | By default, `getByText("Submit")` is an exact, full-content match. "Submit Form" would not match. |
| TF-67 | **T** | `{ exact: false }` enables substring matching for text queries. |
| TF-68 | **T** | The `name` option in `getByRole` performs an exact string match by default. Use regex for flexible matching. |
| TF-69 | **T** | Both explicit `role="dialog"` and native `<dialog>` elements have the `dialog` role and can be found with `getByRole('dialog')`. |
| TF-70 | **T** | `data-testid` attributes are meaningless to users and assistive technology. They are a testing-only concern and create test-to-DOM coupling. |
| TF-71 | **T** | `user.type` interprets `{backspace}` as a special key. After typing "abc", Backspace deletes "c", leaving "ab". |
| TF-72 | **T** | `findBy` queries accept options including `timeout` (default 1000ms) and `interval` to customize waiting behavior. |

---

### Part B: Short Answer

**SA-1.**
The RTL query priority hierarchy, highest to lowest:

1. **Queries Accessible to Everyone:** `getByRole` (highest — queries by ARIA role, the way assistive technology sees elements; e.g., `getByRole('button')`), `getByLabelText` (finds form controls by their label text; e.g., `getByLabelText('Email')`), `getByPlaceholderText`, `getByText` (finds by visible text content; e.g., `getByText('Submit')`), `getByDisplayValue`.

2. **Semantic Queries:** `getByAltText` (finds images by `alt` text; e.g., `getByAltText('Logo')`), `getByTitle`.

3. **Test IDs:** `getByTestId` (lowest — queries by `data-testid` attribute, invisible to users; e.g., `getByTestId('submit-btn')`). Used only as a last resort.

Higher-priority queries are preferred because they reflect how real users (including those using assistive technology) find elements. Lower-priority queries are fallbacks for when no semantic query works.

---

**SA-2.**
`getBy` returns the matching element immediately or throws if none (or more than one) is found. Use it when the element should already be in the DOM.

`queryBy` returns the element if found, or `null` if not. It never throws on no match. Use it when asserting that an element does NOT exist: `expect(screen.queryByText("Error")).not.toBeInTheDocument()`.

`findBy` returns a Promise that resolves when the element appears in the DOM (it retries on an interval). Use it when the element will appear asynchronously, such as after a data fetch or state update: `const message = await screen.findByText("Success")`.

---

**SA-3.**
The accessible name is `"Close dialog"`, because `aria-label` overrides the text content "X" for the accessible name. Query it with:

```ts
screen.getByRole('button', { name: /close dialog/i })
```

---

**SA-4.**
```tsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import LoginForm from './LoginForm';

it("submits credentials and shows success", async () => {
  const user = userEvent.setup();
  render(<LoginForm />);

  const emailInput = screen.getByLabelText(/email/i);
  const passwordInput = screen.getByLabelText(/password/i);
  const submitButton = screen.getByRole('button', { name: /submit/i });

  await user.type(emailInput, "alice@example.com");
  await user.type(passwordInput, "password123");
  await user.click(submitButton);

  expect(await screen.findByText(/success/i)).toBeInTheDocument();
});
```

The test uses `getByLabelText` for form fields (accessible, label-based), `getByRole` for the button (highest-priority query), `user-event` for realistic interaction, and `findByText` for the async success message.

---

**SA-5.**
`user-event` is preferred because it simulates the full sequence of events that a real browser fires. `fireEvent.click(button)` dispatches only a synthetic `click` event. `user.click(button)` fires `pointerdown`, `mousedown`, `pointerup`, `mouseup`, `click`, and also handles focus changes.

This matters for components that listen to events other than `click`. For example, a dropdown that opens on `mousedown` (not `click`) would work correctly with `user.click` but not with `fireEvent.click`. Similarly, `user.type` fires all keyboard events character by character, which matters for components with `onKeyDown` handlers or input masking.

---

**SA-6.**
`screen.debug()` pretty-prints the current state of the DOM tree to the console. Use it when a test fails and you want to see what the test "sees" — which elements are present, what their text content is, and what the DOM structure looks like.

For discovering ARIA roles, use `logRoles(container)` from `@testing-library/dom`. It prints all elements with their computed ARIA roles, which helps you determine the correct role to pass to `getByRole`. For example, you might discover that your custom component renders with role `textbox` instead of `input`.

---

**SA-7.**
`within` scopes all queries to a specific container element, useful when the same text or role appears in multiple parts of the page:

```tsx
import { render, screen, within } from '@testing-library/react';

it("finds the save button inside the header", () => {
  render(<Page />);

  const header = screen.getByRole('banner');
  const saveButton = within(header).getByRole('button', { name: /save/i });

  expect(saveButton).toBeInTheDocument();
});
```

Without `within`, `getByRole('button', { name: /save/i })` might match a save button in the footer instead. `within` narrows the search to just the header.

---

**SA-8.**
KCD says manual `act()` wrapping is unnecessary because RTL already wraps `render`, `fireEvent`, and `user-event` calls in `act()` behind the scenes. React's `act()` ensures that all state updates and effects triggered by an interaction are flushed before the test proceeds. Since RTL handles this for you, adding `act()` manually creates noise, makes tests harder to read, and can mask real async issues (where you should be using `findBy` or `waitFor` instead of forcing synchronous flushing).

---

**SA-9.**
```tsx
it("does not show an error message initially", () => {
  render(<Form />);

  expect(screen.queryByText("Invalid email")).not.toBeInTheDocument();
});
```

You must use `queryByText` because `getByText` throws if the element is not found. Since we are asserting the element does NOT exist, throwing would crash the test before the assertion runs. `queryByText` returns `null` when the element is absent, which allows `.not.toBeInTheDocument()` to pass.

---

**SA-10.**
The `wrapper` option in `render` wraps the component being tested in a specified provider component. This is useful when the component requires Context (theme, router, state) to render:

```tsx
import { ThemeProvider, createTheme } from '@mui/material';

const theme = createTheme();

it("renders with theme", () => {
  render(<MyComponent />, {
    wrapper: ({ children }) => (
      <ThemeProvider theme={theme}>{children}</ThemeProvider>
    ),
  });

  expect(screen.getByText("Themed content")).toBeInTheDocument();
});
```

This avoids wrapping the component manually inside `render(<ThemeProvider><MyComponent /></ThemeProvider>)` and is especially powerful when combined with a custom `renderWithProviders` utility used across all tests.

---

**SA-11.**
- `<button>` → `button`
- `<a href="...">` → `link`
- `<input type="text">` → `textbox`
- `<input type="checkbox">` → `checkbox`
- `<h2>` → `heading` (level 2)
- `<ul>` → `list`
- `<li>` → `listitem`
- `<img alt="photo">` → `img`

---

**SA-12.**
`findBy` is shorthand for `waitFor(() => getBy(...))`. Use `findBy` when you are simply waiting for a single element to appear in the DOM — it is cleaner and more readable.

Use `waitFor` explicitly when you need to wait for a condition that is not just an element appearing — for example, waiting for an element's text to change, waiting for a specific number of elements to appear, or waiting for a complex async side effect. `waitFor` gives you full control over the assertion inside the callback, whereas `findBy` is specifically for element appearance.

---

**SA-13.**
Three common mistakes from KCD's article:

1. **Using `getByTestId` as the default query.** Correct: Use `getByRole` first, then `getByLabelText`, then `getByText`. `getByTestId` is a last resort.

2. **Wrapping things in `act()` unnecessarily.** Correct: RTL's `render` and `user-event` already handle `act()`. If you see `act()` warnings, the fix is usually to `await` async operations or use `findBy` queries, not to add more `act()` wrappers.

3. **Using `fireEvent` instead of `user-event`.** Correct: `user-event` simulates real user interactions more accurately. Always prefer `user.click()` over `fireEvent.click()`.

---

**SA-14.**
`getAllByRole('listitem')` returns an array of 5 DOM elements (one for each `<li>`). To assert the count:

```ts
const items = screen.getAllByRole('listitem');
expect(items).toHaveLength(5);
```

If you needed to check a specific item's content, you could index into the array: `expect(items[0]).toHaveTextContent("First item")`.

---

**SA-15.**
The test has several issues related to query and event choices:

1. **Query choice:** All three queries use `getByTestId`, which is the lowest-priority query. The email input should use `getByLabelText(/email/i)` or `getByRole('textbox', { name: /email/i })`. The submit button should use `getByRole('button', { name: /submit/i })`. The error message should use `getByText` or `getByRole('alert')`.

2. **Event simulation:** `fireEvent.change` dispatches a synthetic change event. `user.type` is preferred because it simulates real keystroke-by-keystroke typing, which may be needed for validation logic that runs on each keystroke. Similarly, `user.click` should replace `fireEvent.click`.

Improved version:
```tsx
it("shows error on invalid email", async () => {
  const user = userEvent.setup();
  render(<LoginForm />);

  await user.type(screen.getByLabelText(/email/i), "invalid");
  await user.click(screen.getByRole('button', { name: /submit/i }));

  expect(screen.getByText(/invalid email/i)).toBeInTheDocument();
});
```

---

**SA-16.**
`waitForElementToBeRemoved` waits until a specified element is no longer in the DOM. It is useful for asserting that loading states complete:

```tsx
it("shows data after loading spinner disappears", async () => {
  render(<DataList />);

  // Spinner should be visible initially
  expect(screen.getByRole('progressbar')).toBeInTheDocument();

  // Wait for the spinner to be removed
  await waitForElementToBeRemoved(() => screen.queryByRole('progressbar'));

  // Now the data should be visible
  expect(screen.getByText("Item 1")).toBeInTheDocument();
  expect(screen.getByText("Item 2")).toBeInTheDocument();
});
```

Note that the callback passed to `waitForElementToBeRemoved` should use `queryBy` (not `getBy`) because the element will eventually not exist, and `getBy` would throw at that point.

---

### Part C: Multiple Choice

| # | Answer | Explanation |
|---|---|---|
| MC-1 | **(b)** | This is RTL's stated guiding principle: tests that resemble real usage give the most confidence. |
| MC-2 | **(b)** | `screen` is the recommended way to access queries. Destructuring from `render` is listed by KCD as a common mistake. |
| MC-3 | **(c)** | `getByRole` is the highest-priority query. `getByRole('button', { name: /submit/i })` queries by role and accessible name. |
| MC-4 | **(c)** | `getByLabelText` is the best query for form fields with visible labels. It mimics how users find form controls. |
| MC-5 | **(c)** | `getByTestId` is a last resort when no accessible or semantic query works. It has no meaning to users. |
| MC-6 | **(b)** | `getByRole('heading', { level: 2 })` specifically matches `<h2>` elements (role `heading`, level 2). |
| MC-7 | **(c)** | A `<select>` element (single-select without `size > 1`) has the implicit ARIA role `combobox`. |
| MC-8 | **(c)** | `getBy` throws an error when no match is found, causing the test to fail with a descriptive message. |
| MC-9 | **(b)** | `queryBy` returns `null` when no match is found, which is safe for negative assertions. |
| MC-10 | **(b)** | `queryBy` is used when asserting absence: `expect(screen.queryByText("X")).not.toBeInTheDocument()`. |
| MC-11 | **(b)** | `findBy` is for elements that appear asynchronously. It returns a Promise that resolves when the element appears. |
| MC-12 | **(c)** | `findBy` returns a Promise. You must `await` it. |
| MC-13 | **(b)** | `getAllBy` returns an array of all matching elements. |
| MC-14 | **(c)** | `getAllBy` throws if no elements are found. Use `queryAllBy` if an empty array is acceptable. |
| MC-15 | **(b)** | `fireEvent.click` dispatches only `click`. `user.click` fires the full pointer/mouse/focus/click sequence. |
| MC-16 | **(b)** | `const user = userEvent.setup()` creates a user instance with proper event coordination. This is the recommended pattern. |
| MC-17 | **(b)** | `user.type` simulates character-by-character input with all associated keyboard events. |
| MC-18 | **(b)** | `user.clear(element)` clears the input's value. |
| MC-19 | **(b)** | All `user-event` methods return Promises and should be awaited. |
| MC-20 | **(c)** | `user.tab()` simulates pressing the Tab key to move focus. |
| MC-21 | **(b)** | `user.selectOptions` simulates selecting options from a `<select>` or listbox. |
| MC-22 | **(b)** | `waitFor` repeatedly invokes the callback on an interval until it stops throwing or times out. |
| MC-23 | **(b)** | `findBy` is a single, readable call that combines waiting and querying. It is preferred over the more verbose `waitFor` + `getBy`. |
| MC-24 | **(b)** | `waitForElementToBeRemoved` waits until the element is gone from the DOM. |
| MC-25 | **(b)** | RTL handles `act()` internally. Manual `act()` is unnecessary and is a common mistake per KCD. |
| MC-26 | **(b)** | `screen.debug()` prints the DOM tree to the console for debugging. |
| MC-27 | **(b)** | `logRoles` prints all ARIA roles in the container, helping you discover correct roles for `getByRole`. |
| MC-28 | **(b)** | `within` scopes queries to a specific container element. |
| MC-29 | **(b)** | The `wrapper` option wraps the rendered component in a provider (e.g., ThemeProvider, Router). |
| MC-30 | **(c)** | KCD identifies destructuring from `render` instead of using `screen` as a common mistake. |
| MC-31 | **(b)** | Unnecessarily wrapping things in `act()` is another mistake KCD identifies. RTL handles `act()` for you. |
| MC-32 | **(c)** | KCD recommends `findBy` over the `waitFor` + `getBy` pattern for waiting for elements to appear. |
| MC-33 | **(b)** | `queryByText` returns `null` when not found, allowing `.not.toBeInTheDocument()`. `getByText` would throw first. |
| MC-34 | **(c)** | `.toBeInTheDocument()` is a custom matcher from `@testing-library/jest-dom`. It must be imported (usually via `setupFiles`). |
| MC-35 | **(b)** | The `i` flag in regex makes the match case-insensitive. |
| MC-36 | **(b)** | `getByText("Submit")` does an exact, full-content match by default. Substring matches require `{ exact: false }` or regex. |
| MC-37 | **(a)** | `{ exact: false }` enables substring matching. Alternatively, you can use regex: `getByText(/Submit/)`. |
| MC-38 | **(b)** | The accessible name of a `<button>` is derived from its text content: `"Save Changes"`. |
| MC-39 | **(b)** | The `<label htmlFor="email">Email Address</label>` associates with the input, giving it the accessible name `"Email Address"`. |
| MC-40 | **(a)** | The input has role `textbox` and accessible name `"Email Address"` from its label. `getByRole('textbox', { name: /email address/i })` matches. |
| MC-41 | **(b)** | `{Enter}` in `user.keyboard` is a special key notation that simulates pressing the Enter key. |
| MC-42 | **(b)** | `user.type` processes `{backspace}` as a special key. After typing "abc", Backspace deletes "c", leaving "ab". |
| MC-43 | **(b)** | RTL auto-cleanup unmounts rendered components and clears the DOM after each test. |
| MC-44 | **(b)** | `user.hover(button)` simulates mouse hover, which would trigger tooltip display. |
| MC-45 | **(c)** | Both work. `<img>` has role `img` and the `alt` text provides the accessible name. `getByAltText` also targets `alt` text. |
| MC-46 | **(a)** | `<nav>` has the implicit ARIA role `navigation`. |
| MC-47 | **(d)** | Both work. `<textarea>` has role `textbox`, so `getByRole('textbox', { name: /description/i })` works. `getByLabelText(/description/i)` also finds it via label. |
| MC-48 | **(c)** | `queryAllBy` returns an empty array `[]` when no matches are found, rather than throwing. |