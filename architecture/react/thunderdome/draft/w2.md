# Week 2: Advanced TypeScript — Expanded Edition

**Scope:** Generics, utility types (Partial, Pick, Omit, Record, Required, ReturnType), `satisfies` operator, discriminated unions, type guards, conditional types (intro), mapped types, `typeof` type operator, indexed access types, template literal types (awareness).

**Assigned Readings:**
- TS-HB: "Generics" (through "Generic Constraints")
- TS-HB: "Typeof Type Operator" and "Indexed Access Types"
- TS-HB: "Conditional Types"
- TS-HB: "Mapped Types"
- TS-HB: "Template Literal Types" (skim)
- TypeScript docs: "Utility Types" reference (Partial, Required, Pick, Omit, Record, ReturnType)
- Article: "The satisfies operator" (TS 4.9 release notes)

**Scoring:** Wrong answers on T/F and MC are subtracted from right answers. Do not guess.

---

## Part A: True / False (96 Questions)

---

### Generics (TF-1 through TF-48)

**TF-1.** A generic function allows you to write a single function that works with multiple types while preserving type information about the specific type used at each call site.

**TF-2.** Generic type parameters are preserved at runtime and can be inspected using `typeof` at execution time.

**TF-3.** In `function identity<T>(value: T): T`, the type `T` is inferred from the argument passed at the call site.

**TF-4.** You can explicitly provide a type argument to a generic function: `identity<string>("hello")`.

**TF-5.** A generic constraint `T extends string` means `T` can only be `string` exactly — no subtypes or string literal types are allowed.

**TF-6.** The constraint `T extends { length: number }` allows `T` to be any type that has at least a `length` property of type `number`, including `string` and arrays.

**TF-7.** You can use one type parameter as a constraint for another: `<T, K extends keyof T>` ensures `K` is a valid key of `T`.

**TF-8.** `keyof T` produces a union of string literal types representing the property names of `T`.

**TF-9.** Indexed access types (`T[K]`) let you look up the type of a specific property on another type.

**TF-10.** `typeof` in a type position extracts the TypeScript type of a runtime variable, which is different from the JavaScript `typeof` operator.

**TF-33.** A generic function that takes `arg: T` where `T` is unconstrained can safely access `arg.toString()` because `toString()` exists on all JavaScript values.

**TF-34.** When calling `identity("hello")` without an explicit type argument, TypeScript infers `T` as the literal type `"hello"`, not `string`.

**TF-35.** Multiple type parameters can be used in a single generic function: `function pair<A, B>(a: A, b: B): [A, B]`.

**TF-36.** A generic constraint `T extends string | number` allows `T` to be `string`, `number`, any string literal type, or any numeric literal type.

**TF-37.** `keyof any` evaluates to `string | number | symbol` — the set of all possible property key types.

**TF-38.** Indexed access types can use union keys: `T["a" | "b"]` produces the union of `T["a"] | T["b"]`.

**TF-39.** `keyof` on an array type like `string[]` includes `number` and all the array method names (`push`, `map`, etc.).

**TF-40.** You cannot provide default type parameters for generic functions — defaults only work on generic type aliases and interfaces.

**TF-41.** A generic interface (e.g., `interface Box<T> { value: T }`) requires a type argument when used: `Box<string>`.

**TF-42.** TypeScript can infer generic type arguments for classes in the same way it does for functions — from constructor arguments.

**TF-43.** A generic function can have its type parameter constrained by another type parameter: `<T, K extends keyof T>(obj: T, key: K): T[K]`.

**TF-44.** The return type `T[K]` in `function get<T, K extends keyof T>(obj: T, key: K): T[K]` is an indexed access type that resolves based on the actual key used.

**TF-45.** Generic type parameters can have default values, like `<T = string>`, which are used when the type cannot be inferred.

**TF-46.** You can constrain a generic type to be a function: `T extends (...args: any[]) => any`.

**TF-47.** A generic class can use its type parameter in static methods and static properties.

**TF-48.** `Array<T>` and `T[]` are identical types — they are interchangeable syntax.

---

### Utility Types (TF-11 through TF-16, plus TF-49 through TF-64)

**TF-11.** `Partial<T>` makes every property of `T` optional.

**TF-12.** `Required<T>` makes every property of `T` optional.

**TF-13.** `Pick<T, K>` creates a type containing only the properties of `T` whose keys are in `K`.

**TF-14.** `Omit<T, K>` creates a type containing all properties of `T` except those whose keys are in `K`.

**TF-15.** `Record<"a" | "b", number>` produces the type `{ a: number; b: number }`.

**TF-16.** `ReturnType<T>` extracts the return type of a function type.

**TF-49.** `Partial<T>` is implemented as a mapped type: `{ [K in keyof T]?: T[K] }`.

**TF-50.** `Required<T>` removes optional modifiers by using the `-?` syntax: `{ [K in keyof T]-?: T[K] }`.

**TF-51.** `Readonly<T>` is a mapped type that adds `readonly` to every property: `{ readonly [K in keyof T]: T[K] }`.

**TF-52.** `Pick<User, "name">` produces a type with only the `name` property from `User`.

**TF-53.** `Omit` is implemented using `Pick` and `Exclude`: `Omit<T, K> = Pick<T, Exclude<keyof T, K>>`.

**TF-54.** `Record<string, unknown>` is a common type for representing any object whose values are unknown.

**TF-55.** `NonNullable<T>` removes `null` and `undefined` from a type. `NonNullable<string | null>` is `string`.

**TF-56.** `Parameters<T>` extracts the parameter types of a function type as a tuple. `Parameters<(a: string, b: number) => void>` is `[string, number]`.

**TF-57.** `ReturnType` can only be applied to function types. Applying it to a non-function type (e.g., `ReturnType<string>`) is a compile error.

**TF-58.** `Awaited<T>` unwraps the resolved type of a `Promise`. `Awaited<Promise<string>>` is `string`.

**TF-59.** Utility types are part of TypeScript's standard library — they are defined in `lib.es5.d.ts` and do not need to be imported.

**TF-60.** `Partial` makes properties optional only one level deep — it is shallow, not recursive.

**TF-61.** You can nest utility types: `Required<Pick<User, "name" | "email">>` makes those picked properties required.

**TF-62.** `Record<K, V>` is equivalent to the mapped type `{ [P in K]: V }`.

**TF-63.** `Omit` is type-safe in that it errors if you try to omit a key that doesn't exist on the type.

**TF-64.** `Extract<T, U>` and `Exclude<T, U>` are complementary: for any union `T`, `Extract<T, U> | Exclude<T, U>` reconstructs `T`.

---

### Mapped Types, Conditional Types, Infer (TF-17 through TF-22, plus TF-65 through TF-80)

**TF-17.** Mapped types use the syntax `[K in keyof T]` to iterate over the keys of a type and produce a new type with transformed properties.

**TF-18.** `Partial`, `Required`, and `Readonly` are all implemented as mapped types internally.

**TF-19.** Conditional types (`T extends U ? X : Y`) are evaluated at runtime to choose between `X` and `Y`.

**TF-20.** When a conditional type is applied to a union type, it distributes over each member of the union individually.

**TF-21.** `Exclude<T, U>` removes from union `T` all members that are assignable to `U`.

**TF-22.** `Extract<T, U>` removes from union `T` all members that are assignable to `U`.

**TF-65.** Mapped types can add or remove `readonly` using `+readonly` or `-readonly` modifiers.

**TF-66.** Mapped types can add or remove optional (`?`) modifiers using `+?` or `-?`.

**TF-67.** A mapped type can remap keys using the `as` clause: `[K in keyof T as NewKey]: T[K]`.

**TF-68.** Key remapping with `as never` in a mapped type effectively filters out that key from the result.

**TF-69.** Conditional types can only be used at the top level of a type alias; they cannot be nested inside other types.

**TF-70.** Distributive conditional types distribute automatically when `T` is a naked type parameter applied to a union.

**TF-71.** Wrapping `T` in `[T]` prevents distribution in a conditional type: `[T] extends [U] ? X : Y` does not distribute over union members.

**TF-72.** The `infer` keyword in conditional types allows you to declare a type variable to be inferred from a pattern match.

**TF-73.** `T extends Array<infer U> ? U : never` extracts the element type of an array.

**TF-74.** `infer` can only be used in the `extends` clause of a conditional type, not in regular type positions.

**TF-75.** Conditional types are resolved entirely at compile time; they produce no runtime code.

**TF-76.** A mapped type `{ [K in "a" | "b"]: number }` produces `{ a: number; b: number }`, identical to `Record<"a" | "b", number>`.

**TF-77.** You can use template literal types in mapped type key remapping: `` [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K] ``.

**TF-78.** `Exclude<"a" | "b" | "c", "a" | "b">` produces `"c"`.

**TF-79.** `Extract<"a" | "b" | "c", "a" | "b">` produces `"a" | "b"`.

**TF-80.** Conditional types can be recursive: a conditional type can reference itself in its true or false branches.

---

### Satisfies, Discriminated Unions, Type Guards, Template Literal Types (TF-23 through TF-32, plus TF-81 through TF-96)

**TF-23.** The `satisfies` operator changes the type of the variable to the target type, widening it.

**TF-24.** `satisfies` validates that a value matches a type while preserving the narrower inferred type of the value.

**TF-25.** In a discriminated union, the discriminant property must be a literal type that is unique to each member of the union.

**TF-26.** TypeScript can narrow a discriminated union in a `switch` statement by switching on the discriminant property.

**TF-27.** The exhaustive check pattern (`const _: never = value` in a `default` branch) produces a compile-time error if a new variant is added to a union without being handled.

**TF-28.** A custom type guard function uses the syntax `value is Type` in its return type position to tell TypeScript to narrow the type when the function returns `true`.

**TF-29.** Template literal types allow you to construct string types using backtick syntax at the type level, such as `` type Route = `/api/${string}` ``.

**TF-30.** A generic class can reference its type parameter in static members.

**TF-31.** Generic default parameters (e.g., `<T = string>`) provide a fallback type when no type argument is provided and one cannot be inferred.

**TF-32.** The `infer` keyword in conditional types allows you to declare a type variable to be inferred from a pattern match, such as extracting the element type of an array.

**TF-81.** `satisfies` can be combined with `as const`: `const x = { a: 1 } as const satisfies Record<string, number>` both preserves literal types and validates the shape.

**TF-82.** `satisfies` performs the same type widening as a type annotation — the only difference is syntax.

**TF-83.** A discriminated union can have more than one discriminant property, though a single discriminant is most common.

**TF-84.** The discriminant property in a discriminated union must be a string literal type. Number literals and boolean literals are not valid discriminants.

**TF-85.** TypeScript narrows discriminated unions in both `switch` statements and `if/else` chains that check the discriminant.

**TF-86.** A custom type guard function can return `false` to narrow a type. If `isString(x)` returns `false`, TypeScript narrows `x` to exclude `string` in the `else` branch.

**TF-87.** An assertion function uses the syntax `asserts value is Type` as its return type. If the function returns normally (without throwing), TypeScript narrows the value.

**TF-88.** Template literal types can use the built-in `Uppercase`, `Lowercase`, `Capitalize`, and `Uncapitalize` intrinsic string manipulation types.

**TF-89.** Template literal types can create a union of all possible combinations when composed with union types: `` `${"a" | "b"}-${"x" | "y"}` `` produces `"a-x" | "a-y" | "b-x" | "b-y"`.

**TF-90.** `satisfies` can be used on any expression, including function arguments — not just variable declarations.

**TF-91.** A type guard function must perform an actual runtime check; the `is` return type does not add any runtime behavior by itself.

**TF-92.** If a type guard function is implemented incorrectly (e.g., always returns `true`), TypeScript will detect the mismatch and report an error.

**TF-93.** An exhaustive `switch` that handles all discriminated union members and has no `default` branch will cause TypeScript to infer the function's return type correctly without a `default: never` check.

**TF-94.** The `never` type in the exhaustive check pattern works because `never` is the bottom type — no value is assignable to it, so an unhandled case produces a type error.

**TF-95.** Discriminated unions are especially useful for modeling state machines (e.g., `{ status: "idle" } | { status: "loading" } | { status: "error"; error: string } | { status: "success"; data: T }`).

**TF-96.** `satisfies` was introduced in TypeScript 4.9 and solves the problem of wanting type validation without losing inferred literal types.

---

## Part B: Short Answer (24 Questions)

Answer in 1–4 sentences or a short code snippet. Write valid TypeScript where code is requested.

---

**SA-1.** Explain what a generic function is and why it is more useful than writing a function that accepts `any`.

---

**SA-2.** Write a generic function `first<T>` that takes an array of `T` and returns the first element (or `undefined` if the array is empty). Include the return type annotation.

---

**SA-3.** Explain what a generic constraint does. Write a function `getLength<T extends { length: number }>(item: T): number` and list three types that satisfy this constraint.

---

**SA-4.** What does `keyof` produce, and how does it relate to indexed access types? Given `type User = { name: string; age: number }`, what is `keyof User` and what is `User["name"]`?

---

**SA-5.** What is the difference between `Pick<T, K>` and `Omit<T, K>`? Given `type Full = { a: number; b: string; c: boolean }`, what are `Pick<Full, "a" | "c">` and `Omit<Full, "b">`?

---

**SA-6.** Write a `Record` type called `Scores` that maps student names (`"alice" | "bob" | "carol"`) to `number` values.

---

**SA-7.** Explain what a mapped type is. Write a mapped type `Nullable<T>` that takes an object type `T` and makes every property's type `T[K] | null`.

---

**SA-8.** What is the `satisfies` operator, and how does it differ from a type annotation? Give a concrete example where `satisfies` preserves a narrower type than an annotation would.

---

**SA-9.** What is a discriminated union? Write a type `Shape` that is a union of `{ kind: "circle"; radius: number }` and `{ kind: "rect"; width: number; height: number }`, then write a function `area(shape: Shape): number` that uses a `switch` on `kind` to calculate the area.

---

**SA-10.** Explain the exhaustive check pattern using `never`. Why does assigning an unhandled union member to `never` produce a compile error, and why is this useful?

---

**SA-11.** Write a custom type guard function `isString(value: unknown): value is string` and show how it narrows in the calling code.

---

**SA-12.** Explain in 2–3 sentences what conditional types are and when you might use them. You do not need to write complex conditional type syntax.

---

**SA-13.** What does the `typeof` type operator do in a type position? Write a short example showing how you extract a type from a value using `typeof`.

---

**SA-14.** What does `ReturnType<typeof fn>` produce? Write a function `fn` and show how `ReturnType` extracts its return type.

---

**SA-15.** What is the difference between `Exclude<T, U>` and `Extract<T, U>`? Given `type T = "a" | "b" | "c"`, what does `Exclude<T, "a">` produce? What does `Extract<T, "a" | "b">` produce?

---

**SA-16.** A colleague writes the following and finds that `config.endpoint` is typed as `string` instead of `"/api/v1"`. Explain what is wrong and how to fix it using `satisfies`.

```ts
const config: Record<string, string> = {
  endpoint: "/api/v1",
  env: "production",
};
// config.endpoint is string, not "/api/v1"
```

---

**SA-17.** Write a generic function `getProperty<T, K extends keyof T>(obj: T, key: K): T[K]` and demonstrate calling it so that the return type is correctly inferred. Explain why the constraint `K extends keyof T` is necessary.

---

**SA-18.** Write a mapped type `Getters<T>` that transforms each property of `T` into a getter function. For example, `Getters<{ name: string; age: number }>` should produce `{ name: () => string; age: () => number }`.

---

**SA-19.** Explain what distributive conditional types are. Given `type ToArray<T> = T extends any ? T[] : never`, what does `ToArray<string | number>` produce? Why?

---

**SA-20.** Write an assertion function `assertIsString(value: unknown): asserts value is string` that throws if the value is not a string. Show how the assertion narrows in the calling code.

---

**SA-21.** Explain the difference between `Partial<T>` and `Required<T>`. Give a scenario where each is useful.

---

**SA-22.** Write a conditional type `ElementType<T>` that extracts the element type if `T` is an array, and returns `T` otherwise. Use the `infer` keyword.

---

**SA-23.** Write a mapped type `ReadonlyExcept<T, K extends keyof T>` that makes all properties readonly EXCEPT those in `K`. (Hint: combine Pick, Omit, and Readonly.)

---

**SA-24.** A developer writes this discriminated union but forgets to handle all cases. Explain what happens at compile time and how to ensure all cases are always handled.

```ts
type Result =
  | { status: "ok"; data: string }
  | { status: "error"; message: string }
  | { status: "pending" };

function handleResult(r: Result): string {
  switch (r.status) {
    case "ok": return r.data;
    case "error": return r.message;
    // "pending" not handled
  }
}
```

---

## Part C: Multiple Choice (48 Questions)

Choose the single best answer.

---

### Generics (MC-1 through MC-16)

**MC-1.** What is the inferred return type of `identity("hello")`?

```ts
function identity<T>(value: T): T {
  return value;
}
const result = identity("hello");
```

(a) `string`
(b) `"hello"`
(c) `T`
(d) `any`

---

**MC-2.** Why does the following code produce an error?

```ts
function loggingIdentity<T>(arg: T): T {
  console.log(arg.length); // Error
  return arg;
}
```

(a) `T` could be any type, and not all types have a `length` property
(b) Generic functions cannot access properties
(c) `console.log` does not accept generic arguments
(d) `T` is always `never`

---

**MC-3.** Which version correctly constrains `T` so the function compiles?

(a) `function loggingIdentity<T extends object>(arg: T): T`
(b) `function loggingIdentity<T extends { length: number }>(arg: T): T`
(c) `function loggingIdentity<T = { length: number }>(arg: T): T`
(d) `function loggingIdentity<T extends any>(arg: T): T`

---

**MC-4.** What is the type of `result`?

```ts
type User = { name: string; age: number; email: string };
type Result = Omit<User, "email">;
```

(a) `{ name: string; age: number }`
(b) `{ email: string }`
(c) `{ name: string; age: number; email: string }`
(d) `{ name: string }`

---

**MC-5.** What does this mapped type produce?

```ts
type Flags<T> = {
  [K in keyof T]: boolean;
};
type Result = Flags<{ name: string; active: boolean }>;
```

(a) `{ name: boolean; active: boolean }`
(b) `{ name: string; active: boolean }`
(c) `boolean`
(d) `{ [key: string]: boolean }`

---

**MC-6.** What does the `satisfies` keyword do in this code?

```ts
const palette = {
  red: [255, 0, 0],
  green: "#00ff00",
} satisfies Record<string, string | number[]>;
```

(a) Changes the type of `palette` to `Record<string, string | number[]>`
(b) Validates the value matches the target type while keeping the narrower inferred type (so `palette.red` is `number[]`, not `string | number[]`)
(c) Makes `palette` immutable
(d) Is identical to using `as const`

---

**MC-7.** What is the type of `shape` inside `case "circle"`?

```ts
type Shape =
  | { kind: "circle"; radius: number }
  | { kind: "square"; side: number };

function describe(shape: Shape) {
  switch (shape.kind) {
    case "circle":
      // what is shape's type here?
  }
}
```

(a) `Shape`
(b) `{ kind: "circle"; radius: number }`
(c) `{ kind: "square"; side: number }`
(d) `never`

---

**MC-8.** If a third variant `{ kind: "triangle"; base: number; height: number }` is added to `Shape` but the `switch` is not updated, and the `default` branch contains `const _: never = shape`, what happens?

(a) No error; the default branch handles all remaining cases
(b) A runtime error when a triangle is passed
(c) A compile-time error because the triangle variant is not assignable to `never`
(d) TypeScript silently ignores the new variant

---

**MC-9.** What is `keyof { a: number; b: string; c: boolean }`?

(a) `string`
(b) `"a" | "b" | "c"`
(c) `number`
(d) `["a", "b", "c"]`

---

**MC-10.** What does the indexed access type `User["name"]` resolve to?

```ts
type User = { name: string; age: number };
```

(a) `"name"`
(b) `string`
(c) `User`
(d) `{ name: string }`

---

**MC-11.** What does this conditional type evaluate to?

```ts
type IsNumber<T> = T extends number ? "yes" : "no";
type A = IsNumber<42>;
type B = IsNumber<string>;
```

(a) `A` is `"yes"`, `B` is `"no"`
(b) `A` is `"no"`, `B` is `"yes"`
(c) Both are `"yes"`
(d) Both are `boolean`

---

**MC-12.** What does `Exclude<"a" | "b" | "c", "a" | "c">` produce?

(a) `"a" | "c"`
(b) `"b"`
(c) `"a" | "b" | "c"`
(d) `never`

---

**MC-13.** What does `Extract<"a" | "b" | "c", "a" | "c">` produce?

(a) `"b"`
(b) `"a" | "c"`
(c) `"a" | "b" | "c"`
(d) `never`

---

**MC-14.** What does this code produce for the type of `settings`?

```ts
const defaults = {
  theme: "dark",
  fontSize: 14,
  debug: false,
};
type Settings = typeof defaults;
```

(a) `{ theme: string; fontSize: number; debug: boolean }`
(b) `{ theme: "dark"; fontSize: 14; debug: false }`
(c) `object`
(d) `any`

---

**MC-15.** A type guard function has this signature: `function isFish(pet: Fish | Bird): pet is Fish`. What does `pet is Fish` mean?

(a) The function converts `pet` to `Fish` at runtime
(b) If the function returns `true`, TypeScript narrows `pet` to `Fish` in the calling scope
(c) The function throws if `pet` is not `Fish`
(d) `pet` is always `Fish` after calling this function, regardless of return value

---

**MC-16.** Why can't a generic class use its type parameter in `static` members?

```ts
class Box<T> {
  static defaultValue: T; // Error
}
```

(a) Static members belong to the class constructor, not instances, and there is only one copy shared across all instantiations — so `T` has no single resolved type
(b) TypeScript does not support static members
(c) Generic classes cannot have static members at all
(d) The `T` parameter must be explicitly provided for static members

---

### Generics and Utility Types In Depth (MC-17 through MC-32)

**MC-17.** What is the type of `result`?

```ts
function wrap<T>(value: T): { wrapped: T } {
  return { wrapped: value };
}
const result = wrap(42);
```

(a) `{ wrapped: number }`
(b) `{ wrapped: 42 }`
(c) `{ wrapped: any }`
(d) `object`

---

**MC-18.** What constraint would you add to this function so it compiles?

```ts
function merge<T, U>(a: T, b: U): T & U {
  return { ...a, ...b }; // Error without constraint
}
```

(a) `T extends object, U extends object`
(b) `T extends string, U extends string`
(c) `T extends any, U extends any`
(d) No constraint is needed

---

**MC-19.** What is `Partial<{ name: string; age: number }>`?

(a) `{ name: string; age: number }`
(b) `{ name?: string; age?: number }`
(c) `{ name: string | undefined; age: number | undefined }`
(d) `{}`

---

**MC-20.** What is `Required<{ name?: string; age?: number }>`?

(a) `{ name?: string; age?: number }`
(b) `{ name: string; age: number }`
(c) `{ name: string | undefined; age: number | undefined }`
(d) `{}`

---

**MC-21.** What is `Pick<{ a: number; b: string; c: boolean }, "a" | "b">`?

(a) `{ a: number; b: string; c: boolean }`
(b) `{ a: number; b: string }`
(c) `{ c: boolean }`
(d) `number | string`

---

**MC-22.** What is `Record<"x" | "y", number>`?

(a) `{ x: number } | { y: number }`
(b) `{ x: number; y: number }`
(c) `{ [key: string]: number }`
(d) `number[]`

---

**MC-23.** What does `ReturnType<(x: string) => number>` produce?

(a) `string`
(b) `number`
(c) `(x: string) => number`
(d) `void`

---

**MC-24.** What does `Parameters<(a: string, b: number) => void>` produce?

(a) `string | number`
(b) `[string, number]`
(c) `{ a: string; b: number }`
(d) `void`

---

**MC-25.** What does `NonNullable<string | null | undefined>` produce?

(a) `string | null | undefined`
(b) `string`
(c) `null | undefined`
(d) `never`

---

**MC-26.** What is the result of this mapped type?

```ts
type ReadonlyAll<T> = { readonly [K in keyof T]: T[K] };
type Result = ReadonlyAll<{ x: number; y: string }>;
```

(a) `{ x: number; y: string }`
(b) `{ readonly x: number; readonly y: string }`
(c) `{ x: readonly number; y: readonly string }`
(d) `never`

---

**MC-27.** What does this mapped type with key remapping produce?

```ts
type Getters<T> = {
  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];
};
type Result = Getters<{ name: string; age: number }>;
```

(a) `{ name: () => string; age: () => number }`
(b) `{ getName: () => string; getAge: () => number }`
(c) `{ get_name: () => string; get_age: () => number }`
(d) Compile error

---

**MC-28.** What does `Omit<{ a: number; b: string; c: boolean }, "b" | "c">` produce?

(a) `{ b: string; c: boolean }`
(b) `{ a: number }`
(c) `{ a: number; b: string; c: boolean }`
(d) `never`

---

**MC-29.** What is the type of `val` with this code?

```ts
const routes = {
  home: "/",
  about: "/about",
  contact: "/contact",
} satisfies Record<string, string>;

const val = routes.home;
```

(a) `string`
(b) `"/"`
(c) `Record<string, string>`
(d) `any`

---

**MC-30.** What does `Awaited<Promise<Promise<number>>>` resolve to?

(a) `Promise<number>`
(b) `Promise<Promise<number>>`
(c) `number`
(d) `never`

---

**MC-31.** What is the type of `result`?

```ts
function first<T>(arr: T[]): T | undefined {
  return arr[0];
}
const result = first([1, 2, 3]);
```

(a) `number`
(b) `number | undefined`
(c) `1`
(d) `any`

---

**MC-32.** What does this conditional type produce?

```ts
type Flatten<T> = T extends Array<infer U> ? U : T;
type A = Flatten<string[]>;
type B = Flatten<number>;
```

(a) `A` is `string[]`, `B` is `number`
(b) `A` is `string`, `B` is `number`
(c) `A` is `string`, `B` is `never`
(d) Both are `never`

---

### Discriminated Unions, Type Guards, Advanced Patterns (MC-33 through MC-48)

**MC-33.** Which property makes this a discriminated union?

```ts
type Result =
  | { success: true; data: string }
  | { success: false; error: Error };
```

(a) `data`
(b) `error`
(c) `success` — it has unique literal types (`true` / `false`) in each member
(d) None — this is not a discriminated union

---

**MC-34.** What is the type of `r.data` inside the `if` block?

```ts
type Result =
  | { success: true; data: string }
  | { success: false; error: Error };

function handle(r: Result) {
  if (r.success) {
    return r.data; // type?
  }
}
```

(a) `string | undefined`
(b) `string`
(c) `Error`
(d) `unknown`

---

**MC-35.** What does the following assertion function signature mean?

```ts
function assertDefined<T>(val: T | undefined): asserts val is T {
  if (val === undefined) throw new Error("undefined!");
}
```

(a) The function returns `T`
(b) After calling this function, TypeScript narrows `val` to `T` (removing `undefined`) if the function returns normally
(c) The function converts `undefined` to `T` at runtime
(d) The function always throws

---

**MC-36.** What does `ToArray<string | number>` produce?

```ts
type ToArray<T> = T extends any ? T[] : never;
```

(a) `(string | number)[]`
(b) `string[] | number[]`
(c) `never`
(d) `any[]`

---

**MC-37.** How do you prevent distribution in the conditional type above?

(a) `type ToArray<T> = [T] extends [any] ? T[] : never`
(b) `type ToArray<T> = T extends never ? T[] : never`
(c) You cannot prevent distribution
(d) Add `as const` to `T`

---

**MC-38.** What does this template literal type produce?

```ts
type Direction = "top" | "bottom";
type Side = "left" | "right";
type Margin = `margin-${Direction | Side}`;
```

(a) `"margin-top" | "margin-bottom" | "margin-left" | "margin-right"`
(b) `string`
(c) `"margin-Direction" | "margin-Side"`
(d) Compile error

---

**MC-39.** What does `Capitalize<"hello">` produce?

(a) `"HELLO"`
(b) `"Hello"`
(c) `"hello"`
(d) `string`

---

**MC-40.** What is the type of `x` after the type guard?

```ts
function isNonNull<T>(val: T | null): val is T {
  return val !== null;
}

const x: string | null = getInput();
if (isNonNull(x)) {
  // x is?
}
```

(a) `string | null`
(b) `string`
(c) `null`
(d) `unknown`

---

**MC-41.** What does `Readonly<{ items: string[] }>` produce?

(a) `{ readonly items: readonly string[] }`
(b) `{ readonly items: string[] }`
(c) `{ items: readonly string[] }`
(d) `{ items: string[] }`

---

**MC-42.** Why is answer (b) in MC-41 a potential surprise?

(a) It's not surprising; `Readonly` is deep
(b) `Readonly` is shallow — `items` is readonly (can't reassign) but the array itself can still be mutated (push, pop, etc.)
(c) `Readonly` doesn't work on arrays
(d) `Readonly` makes everything immutable

---

**MC-43.** What is the type of `result`?

```ts
type User = { name: string; age: number; email: string };
type NameAndEmail = Pick<User, "name" | "email">;
type RequiredNameAndEmail = Required<NameAndEmail>;
const result: RequiredNameAndEmail = { name: "Alice", email: "a@b.com" };
```

(a) `{ name?: string; email?: string }`
(b) `{ name: string; email: string }`
(c) `User`
(d) Error: cannot nest utility types

---

**MC-44.** What does the `as` keyword do in this mapped type?

```ts
type RemoveKind<T> = {
  [K in keyof T as Exclude<K, "kind">]: T[K];
};
```

(a) Asserts the key type
(b) Remaps keys, filtering out the `"kind"` property (because `Exclude` maps it to `never`, which removes it)
(c) Renames `kind` to something else
(d) Has no effect

---

**MC-45.** What does this conditional type with `infer` produce?

```ts
type UnwrapPromise<T> = T extends Promise<infer U> ? U : T;
type A = UnwrapPromise<Promise<string>>;
type B = UnwrapPromise<number>;
```

(a) `A` is `Promise<string>`, `B` is `number`
(b) `A` is `string`, `B` is `number`
(c) `A` is `string`, `B` is `never`
(d) Both are `string`

---

**MC-46.** A function is typed as returning `string` but the developer also wants to handle an error state. Which discriminated union approach is best?

(a) Return `string | Error`
(b) Return `{ ok: true; value: string } | { ok: false; error: Error }`
(c) Throw an exception and don't use a union
(d) Return `any`

---

**MC-47.** What does `keyof (A & B)` produce when `A = { x: number }` and `B = { y: string }`?

(a) `"x" | "y"`
(b) `"x"`
(c) `"y"`
(d) `never`

---

**MC-48.** What is the type of `config.port`?

```ts
const config = {
  host: "localhost",
  port: 3000,
} satisfies { host: string; port: number };
```

(a) `number`
(b) `3000`
(c) `string`
(d) `any`

---

---

## Answer Key

### Part A: True / False

| # | Answer | Explanation |
|---|---|---|
| TF-1 | **T** | Generics preserve type information across a function call, unlike `any` which discards it. |
| TF-2 | **F** | Generic type parameters are fully erased at compile time. There is no runtime representation. |
| TF-3 | **T** | TypeScript infers `T` from the argument: `identity("hello")` infers `T` as `"hello"`. |
| TF-4 | **T** | Explicit type arguments override inference: `identity<string>("hello")` forces `T` to `string`. |
| TF-5 | **F** | `T extends string` allows `string` and any subtype, including string literal types like `"hello"`. |
| TF-6 | **T** | Any type with a `length: number` property satisfies the constraint: strings, arrays, tuples, custom objects. |
| TF-7 | **T** | This is the standard pattern for type-safe property access: `<T, K extends keyof T>`. |
| TF-8 | **T** | `keyof { name: string; age: number }` produces `"name" | "age"`. |
| TF-9 | **T** | `User["name"]` resolves to `string` — the type of the `name` property on `User`. |
| TF-10 | **T** | `typeof x` in a type position extracts the compile-time type. The runtime `typeof` returns strings like `"string"`. |
| TF-33 | **F** | While `toString()` exists on all JS values, TypeScript does not assume anything about an unconstrained `T`. You'd get a type error because `T` could be `null` or `undefined` (under strict), or more precisely, TypeScript only allows operations known for all possible `T`. |
| TF-34 | **T** | Without explicit annotation, TypeScript infers the most specific type: the literal `"hello"`. |
| TF-35 | **T** | Multiple type parameters are common: `function pair<A, B>(a: A, b: B): [A, B]`. |
| TF-36 | **T** | The constraint allows `string`, `number`, and their literal subtypes like `"hello"` and `42`. |
| TF-37 | **T** | `keyof any` is `string | number | symbol` — all valid property key types in JavaScript. |
| TF-38 | **T** | `T["a" | "b"]` distributes to `T["a"] | T["b"]`, producing a union of the property types. |
| TF-39 | **T** | `keyof string[]` includes `number` (for indices) plus all array method names like `"push"`, `"map"`, `"length"`, etc. |
| TF-40 | **F** | Generic functions can have default type parameters: `function f<T = string>(x: T): T`. Defaults work on functions, types, interfaces, and classes. |
| TF-41 | **T** | Generic interfaces need type arguments when used unless they have defaults. `Box<string>` specifies `T = string`. |
| TF-42 | **T** | `class Box<T> { constructor(value: T) {} }` allows `new Box("hello")` to infer `T = "hello"`. |
| TF-43 | **T** | This is the standard `getProperty` pattern for type-safe object access. |
| TF-44 | **T** | `T[K]` is an indexed access type. If `T = { name: string }` and `K = "name"`, the return is `string`. |
| TF-45 | **T** | Defaults are used when inference fails and no explicit argument is provided. |
| TF-46 | **T** | `T extends (...args: any[]) => any` constrains `T` to function types. This is used by `ReturnType` and `Parameters`. |
| TF-47 | **F** | Static members belong to the class constructor, not instances. There is only one copy shared across all `Box<T>`, so `T` has no resolved type. |
| TF-48 | **T** | `Array<T>` and `T[]` are syntactically different but semantically identical. |
| TF-11 | **T** | `Partial<T>` uses a mapped type to add `?` to every property. |
| TF-12 | **F** | `Required<T>` makes every property required (removes `?`). It is the opposite of `Partial`. |
| TF-13 | **T** | `Pick<User, "name">` produces `{ name: string }`. |
| TF-14 | **T** | `Omit<User, "name">` produces `{ age: number; email: string }` (everything except `name`). |
| TF-15 | **T** | `Record<K, V>` maps each key in `K` to value type `V`. With a literal union for keys, you get an object with exactly those keys. |
| TF-16 | **T** | `ReturnType<typeof fn>` extracts the return type of `fn`. |
| TF-49 | **T** | `Partial` is literally defined as `type Partial<T> = { [P in keyof T]?: T[P] }`. |
| TF-50 | **T** | `-?` removes the optional modifier. `Required<T> = { [P in keyof T]-?: T[P] }`. |
| TF-51 | **T** | `Readonly<T> = { readonly [P in keyof T]: T[P] }`. |
| TF-52 | **T** | `Pick` selects only the specified keys. |
| TF-53 | **T** | `Omit<T, K> = Pick<T, Exclude<keyof T, K>>`. It excludes the keys first, then picks the rest. |
| TF-54 | **T** | `Record<string, unknown>` is a common, type-safe alternative to `object` for arbitrary objects. |
| TF-55 | **T** | `NonNullable` strips `null` and `undefined` using a conditional type. |
| TF-56 | **T** | `Parameters` uses `infer` to extract parameter types as a tuple. |
| TF-57 | **T** | `ReturnType` has a constraint `T extends (...args: any) => any`. Non-function types cause a compile error. |
| TF-58 | **T** | `Awaited` recursively unwraps `Promise` types. Nested promises are fully unwrapped. |
| TF-59 | **T** | Utility types are built-in. No imports needed. |
| TF-60 | **T** | `Partial<{ a: { b: number } }>` makes `a` optional, but `b` inside the nested object is still required. |
| TF-61 | **T** | Utility types compose freely. Nesting produces the expected combined effect. |
| TF-62 | **T** | `Record<K, V>` is defined as `{ [P in K]: V }`. |
| TF-63 | **F** | `Omit` does NOT error on non-existent keys. `Omit<{ a: number }, "z">` is valid and just returns `{ a: number }`. This is a common surprise. |
| TF-64 | **T** | Together they partition a union: `Extract` keeps the matching members, `Exclude` keeps the rest. |
| TF-17 | **T** | Mapped types iterate over keys with `in keyof` and produce new property types. |
| TF-18 | **T** | All three are defined as mapped types in TypeScript's `lib.es5.d.ts`. |
| TF-19 | **F** | Conditional types are resolved entirely at compile time within the type system. |
| TF-20 | **T** | Distributive conditional types apply the condition to each member of a union separately. |
| TF-21 | **T** | `Exclude<"a" | "b", "a">` produces `"b"`. |
| TF-22 | **F** | `Extract` keeps members assignable to `U` (the opposite of `Exclude`). `Extract<"a" | "b", "a">` produces `"a"`. |
| TF-65 | **T** | `+readonly` adds readonly, `-readonly` removes it. Similarly for `?`. |
| TF-66 | **T** | `+?` and `-?` are the modifier operators for optional properties in mapped types. |
| TF-67 | **T** | Key remapping with `as` was introduced in TypeScript 4.1 and allows renaming or filtering keys. |
| TF-68 | **T** | Mapping a key to `never` via `as` removes it from the output type. This is how you filter properties in mapped types. |
| TF-69 | **F** | Conditional types can appear anywhere a type is expected: inside other types, as generic arguments, in return types, etc. |
| TF-70 | **T** | Distribution occurs when the checked type is a naked (unwrapped) type parameter. Each union member is checked individually. |
| TF-71 | **T** | Wrapping in a tuple `[T]` prevents distribution because `T` is no longer "naked." |
| TF-72 | **T** | `infer` declares a type variable within the `extends` clause of a conditional type. |
| TF-73 | **T** | If `T` is an array type, `infer U` captures the element type. Otherwise, the result is `never`. |
| TF-74 | **T** | `infer` is only valid within the `extends` clause of a conditional type. |
| TF-75 | **T** | Conditional types are pure type-level computation. No runtime code is emitted. |
| TF-76 | **T** | Both produce `{ a: number; b: number }`. The mapped type iterates over the literal union. |
| TF-77 | **T** | Template literal types combined with mapped type key remapping can produce getter/setter patterns. |
| TF-78 | **T** | `Exclude` removes `"a"` and `"b"` from the union, leaving `"c"`. |
| TF-79 | **T** | `Extract` keeps `"a"` and `"b"` from the union. |
| TF-80 | **T** | Recursive conditional types are allowed (with some depth limits). They're used for deep operations like `DeepReadonly`. |
| TF-23 | **F** | `satisfies` does not change the type. It validates without widening. |
| TF-24 | **T** | This is the key benefit: validation plus narrow type preservation. |
| TF-25 | **T** | The discriminant must be a literal type unique to each union member for narrowing to work. |
| TF-26 | **T** | `switch (shape.kind)` narrows `shape` to the specific member in each `case`. |
| TF-27 | **T** | If an unhandled member reaches the `default` branch, it cannot be assigned to `never`, producing a compile error. |
| TF-28 | **T** | The `value is Type` syntax is a type predicate. When the function returns `true`, TypeScript narrows accordingly. |
| TF-29 | **T** | Template literal types use backtick syntax at the type level to construct string types. |
| TF-30 | **F** | Static members cannot reference instance type parameters. Same as TF-47. |
| TF-31 | **T** | `<T = string>` provides a default when no argument is given and inference has nothing to work with. |
| TF-32 | **T** | `infer` declares a type variable within a conditional type for pattern matching. |
| TF-81 | **T** | `as const satisfies Type` is a valid and useful combination. `as const` narrows literals; `satisfies` validates shape. |
| TF-82 | **F** | `satisfies` does NOT widen. That's the whole point. A type annotation widens; `satisfies` preserves the inferred type. |
| TF-83 | **T** | You can have multiple discriminants, though it's less common. TypeScript can narrow on any of them. |
| TF-84 | **F** | Number literals (`0`, `1`) and boolean literals (`true`, `false`) are also valid discriminants. |
| TF-85 | **T** | Both `switch` and `if/else` on the discriminant property narrow the union. |
| TF-86 | **T** | In the `else` branch after a type guard, TypeScript narrows to the complement. |
| TF-87 | **T** | Assertion functions narrow the type after the call site if they return normally (without throwing). |
| TF-88 | **T** | `Uppercase<"hello">` = `"HELLO"`, `Capitalize<"hello">` = `"Hello"`, etc. These are built-in intrinsic types. |
| TF-89 | **T** | Template literal types with union inputs produce the Cartesian product of all combinations. |
| TF-90 | **F** | `satisfies` can only be used on expressions in specific positions (variable initializers, return statements). It cannot be used on arbitrary function arguments directly. |
| TF-91 | **T** | The `is` type predicate only tells TypeScript what to narrow. The runtime check is the developer's responsibility. |
| TF-92 | **F** | TypeScript does NOT validate the implementation of type guard functions. If you always return `true`, TypeScript trusts you. Incorrect type guards lead to runtime errors. |
| TF-93 | **T** | If all cases return and the switch is exhaustive, TypeScript infers the return type correctly. The `never` check in `default` is an extra safety net but not strictly required if the return type is annotated or inferred. |
| TF-94 | **T** | `never` is the bottom type. No value is assignable to `never`, so an unhandled case produces a type error. |
| TF-95 | **T** | State machines are a classic use case for discriminated unions. Each state has its own associated data. |
| TF-96 | **T** | TypeScript 4.9 (November 2022) introduced `satisfies` for this exact purpose. |

---

### Part B: Short Answer

**SA-1.**
A generic function uses a type parameter (like `<T>`) to preserve type information across the call. Unlike `any`, which erases all type information and disables checking, a generic function maintains the relationship between input and output types. If you pass a `string`, the return type is `string` — not `any`.

---

**SA-2.**

```ts
function first<T>(arr: T[]): T | undefined {
  return arr[0];
}
```

The return type is `T | undefined` because the array could be empty.

---

**SA-3.**
A generic constraint restricts what types can be used as the type argument. `T extends { length: number }` means `T` must have at least a `length` property of type `number`. Three types that satisfy this: `string` (has `.length`), `number[]` (has `.length`), and `{ length: number; name: string }` (custom object with `.length`).

```ts
function getLength<T extends { length: number }>(item: T): number {
  return item.length;
}
```

---

**SA-4.**
`keyof` produces a union of the literal key names of a type. For `type User = { name: string; age: number }`, `keyof User` is `"name" | "age"`. Indexed access types use these keys to look up property types: `User["name"]` is `string`. Together they enable type-safe property access patterns like `<T, K extends keyof T>(obj: T, key: K): T[K]`.

---

**SA-5.**
`Pick<T, K>` creates a type with only the specified keys. `Omit<T, K>` creates a type with everything except the specified keys. They are complementary. For `type Full = { a: number; b: string; c: boolean }`:
- `Pick<Full, "a" | "c">` is `{ a: number; c: boolean }`
- `Omit<Full, "b">` is `{ a: number; c: boolean }` (same result in this case)

---

**SA-6.**

```ts
type Scores = Record<"alice" | "bob" | "carol", number>;
```

This produces `{ alice: number; bob: number; carol: number }`.

---

**SA-7.**
A mapped type iterates over the keys of a type using `[K in keyof T]` and produces a new type with transformed properties.

```ts
type Nullable<T> = {
  [K in keyof T]: T[K] | null;
};
```

Applied to `{ name: string; age: number }`, this produces `{ name: string | null; age: number | null }`.

---

**SA-8.**
`satisfies` validates that a value conforms to a target type without changing the variable's type. A type annotation (`const x: T = ...`) widens the type to `T`. With `satisfies`, the variable keeps its narrower inferred type.

```ts
// Annotation: routes.home is string
const routes: Record<string, string> = { home: "/", about: "/about" };

// satisfies: routes.home is "/"
const routes2 = { home: "/", about: "/about" } satisfies Record<string, string>;
```

---

**SA-9.**

```ts
type Shape =
  | { kind: "circle"; radius: number }
  | { kind: "rect"; width: number; height: number };

function area(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "rect":
      return shape.width * shape.height;
  }
}
```

A discriminated union is a union type where each member has a common property (the discriminant) with a unique literal type. TypeScript uses the discriminant to narrow the union in control flow.

---

**SA-10.**
`never` is the bottom type — no value is assignable to it. In a `default` branch after handling all union members, the remaining type is `never`. If a new variant is added to the union without updating the switch, that variant reaches the `default` branch, where it is not assignable to `never`, causing a compile error. This guarantees at compile time that all variants are handled.

---

**SA-11.**

```ts
function isString(value: unknown): value is string {
  return typeof value === "string";
}

function process(input: unknown) {
  if (isString(input)) {
    // input is narrowed to string here
    console.log(input.toUpperCase());
  }
}
```

The `value is string` return type is a type predicate that tells TypeScript to narrow `value` to `string` when the function returns `true`.

---

**SA-12.**
Conditional types use the syntax `T extends U ? X : Y` to select between two types based on whether `T` is assignable to `U`. They are resolved at compile time. You might use them to create utility types that behave differently for different inputs — for example, extracting the element type of an array or filtering members from a union.

---

**SA-13.**
The `typeof` type operator in a type position extracts the TypeScript type of a value-level variable.

```ts
const config = { debug: true, retries: 3 };
type Config = typeof config;
// Config is { debug: boolean; retries: number }
```

This is distinct from the runtime `typeof` which returns a string like `"object"`.

---

**SA-14.**

```ts
function add(a: number, b: number) {
  return a + b;
}
type AddReturn = ReturnType<typeof add>;
// AddReturn is number
```

`ReturnType<typeof fn>` first uses `typeof` to get the function's type, then `ReturnType` extracts its return type.

---

**SA-15.**
`Exclude<T, U>` removes from `T` all members assignable to `U`. `Extract<T, U>` keeps only the members assignable to `U`. They are complements.

- `Exclude<"a" | "b" | "c", "a">` produces `"b" | "c"`
- `Extract<"a" | "b" | "c", "a" | "b">` produces `"a" | "b"`

---

**SA-16.**
The type annotation `Record<string, string>` widens the type of `config` so that all property values are typed as `string` — the literal `"/api/v1"` is lost. Fix using `satisfies`:

```ts
const config = {
  endpoint: "/api/v1",
  env: "production",
} satisfies Record<string, string>;
// config.endpoint is now "/api/v1"
```

`satisfies` validates the shape without widening, preserving the literal types.

---

**SA-17.**

```ts
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const user = { name: "Alice", age: 30 };
const name = getProperty(user, "name"); // type is string
const age = getProperty(user, "age");   // type is number
// getProperty(user, "email"); // Error: "email" is not in keyof typeof user
```

The constraint `K extends keyof T` ensures `key` is a valid property name of `obj`. Without it, `K` could be any string, and `T[K]` would be invalid.

---

**SA-18.**

```ts
type Getters<T> = {
  [K in keyof T]: () => T[K];
};
// Getters<{ name: string; age: number }> = { name: () => string; age: () => number }
```

The mapped type iterates over each key `K` and transforms the property type from `T[K]` to a getter function `() => T[K]`.

---

**SA-19.**
Distributive conditional types distribute over union members when `T` is a naked type parameter. `ToArray<string | number>` distributes to `ToArray<string> | ToArray<number>` = `string[] | number[]` — NOT `(string | number)[]`. Each union member is processed individually and the results are unioned together.

---

**SA-20.**

```ts
function assertIsString(value: unknown): asserts value is string {
  if (typeof value !== "string") {
    throw new Error("Expected a string");
  }
}

function process(input: unknown) {
  assertIsString(input);
  // After this line, input is narrowed to string
  console.log(input.toUpperCase());
}
```

If `assertIsString` returns normally (doesn't throw), TypeScript narrows `input` to `string` after the call.

---

**SA-21.**
`Partial<T>` makes all properties optional — useful for update/patch functions where you only provide the fields being changed: `function updateUser(id: string, changes: Partial<User>)`. `Required<T>` makes all properties required — useful when you have a type with optional defaults and need to ensure all values are present after initialization: `type ResolvedConfig = Required<Config>`.

---

**SA-22.**

```ts
type ElementType<T> = T extends Array<infer U> ? U : T;

type A = ElementType<string[]>;   // string
type B = ElementType<number>;     // number
type C = ElementType<boolean[]>;  // boolean
```

If `T` matches `Array<infer U>`, the element type `U` is inferred and returned. Otherwise `T` is returned as-is.

---

**SA-23.**

```ts
type ReadonlyExcept<T, K extends keyof T> =
  Readonly<Omit<T, K>> & Pick<T, K>;
```

`Omit<T, K>` removes the mutable keys, `Readonly` makes the rest readonly, then `Pick<T, K>` adds back the mutable properties. For `ReadonlyExcept<{ a: number; b: string; c: boolean }, "b">`, the result is `{ readonly a: number; b: string; readonly c: boolean }`.

---

**SA-24.**
Without a `default` branch or exhaustive check, TypeScript infers the return type as `string | undefined` because the `"pending"` case falls through without returning. The function compiles but may return `undefined` unexpectedly. To ensure all cases are handled, add a `default` branch with the `never` check:

```ts
default: {
  const _exhaustive: never = r;
  return _exhaustive;
}
```

Now if `"pending"` is unhandled, `r` is `{ status: "pending" }` which is not assignable to `never`, producing a compile error. Alternatively, annotate the return type as `string` — TypeScript will error because not all code paths return a string.

---

### Part C: Multiple Choice

| # | Answer | Explanation |
|---|---|---|
| MC-1 | **(b)** | TypeScript infers `T` as the literal type `"hello"` from the argument, so the return type is `"hello"`. |
| MC-2 | **(a)** | `T` is unconstrained, so it could be `number`, `boolean`, or any type without `length`. TypeScript correctly rejects the property access. |
| MC-3 | **(b)** | `T extends { length: number }` constrains `T` to types that have `length`. Option (a) constrains to `object` but not all objects have `length`. Option (c) provides a default, not a constraint. Option (d) `extends any` is no constraint at all. |
| MC-4 | **(a)** | `Omit<User, "email">` removes `email`, leaving `{ name: string; age: number }`. |
| MC-5 | **(a)** | The mapped type replaces every property's type with `boolean`, producing `{ name: boolean; active: boolean }`. |
| MC-6 | **(b)** | `satisfies` validates structure without widening. `palette.red` keeps type `number[]` instead of becoming `string | number[]`. |
| MC-7 | **(b)** | The `switch` narrows on `kind`. In the `"circle"` case, `shape` is narrowed to `{ kind: "circle"; radius: number }`. |
| MC-8 | **(c)** | The triangle variant is not handled by any `case`, so it reaches `default` where it cannot be assigned to `never`. This is a compile-time error. |
| MC-9 | **(b)** | `keyof` produces the union of literal key names: `"a" | "b" | "c"`. |
| MC-10 | **(b)** | `User["name"]` is an indexed access type that resolves to the type of the `name` property: `string`. |
| MC-11 | **(a)** | `42 extends number` is true, so `A` is `"yes"`. `string extends number` is false, so `B` is `"no"`. |
| MC-12 | **(b)** | `Exclude` removes members assignable to the second argument. `"a"` and `"c"` are removed, leaving `"b"`. |
| MC-13 | **(b)** | `Extract` keeps members assignable to the second argument. `"a"` and `"c"` are kept. |
| MC-14 | **(a)** | `defaults` is declared with `const` but without `as const`, so properties are widened: `theme` is `string`, not `"dark"`. `typeof` extracts this widened type. |
| MC-15 | **(b)** | The `pet is Fish` return type is a type predicate. When the function returns `true`, TypeScript narrows `pet` to `Fish` in the calling scope. |
| MC-16 | **(a)** | Static members belong to the class constructor, not instances. There is only one `Box.defaultValue` slot shared across all `Box<T>` instantiations, so there is no single `T` to resolve to. |
| MC-17 | **(b)** | TypeScript infers `T` as `42` (literal type), so the return is `{ wrapped: 42 }`. |
| MC-18 | **(a)** | The spread operator works on objects. Constraining to `object` ensures `T` and `U` can be spread. |
| MC-19 | **(b)** | `Partial` adds `?` to every property: `{ name?: string; age?: number }`. |
| MC-20 | **(b)** | `Required` removes `?`: `{ name: string; age: number }`. |
| MC-21 | **(b)** | `Pick` keeps only the specified keys: `{ a: number; b: string }`. |
| MC-22 | **(b)** | `Record<"x" | "y", number>` produces `{ x: number; y: number }`. |
| MC-23 | **(b)** | `ReturnType` extracts the return type: `number`. |
| MC-24 | **(b)** | `Parameters` extracts parameter types as a tuple: `[string, number]`. |
| MC-25 | **(b)** | `NonNullable` removes `null` and `undefined`: `string`. |
| MC-26 | **(b)** | The mapped type adds `readonly` to every property. |
| MC-27 | **(b)** | Key remapping with `Capitalize` transforms `"name"` to `"Name"` and prepends `"get"`: `getName`, `getAge`. |
| MC-28 | **(b)** | `Omit` removes `"b"` and `"c"`, leaving `{ a: number }`. |
| MC-29 | **(b)** | `satisfies` validates without widening. `routes.home` retains the literal type `"/"`. |
| MC-30 | **(c)** | `Awaited` recursively unwraps nested `Promise` types down to the final resolved value: `number`. |
| MC-31 | **(b)** | `T` is inferred as `number`, return type is `number | undefined`. |
| MC-32 | **(b)** | `Flatten<string[]>` matches `Array<infer U>` with `U = string`. `Flatten<number>` doesn't match, returns `number`. |
| MC-33 | **(c)** | `success` has unique literal types (`true` / `false`) in each member, making it the discriminant. |
| MC-34 | **(b)** | `r.success` is `true` narrows to the first member, so `r.data` is `string`. |
| MC-35 | **(b)** | Assertion functions narrow after the call if they return normally. |
| MC-36 | **(b)** | Distributive: `ToArray<string> | ToArray<number>` = `string[] | number[]`. |
| MC-37 | **(a)** | Wrapping `T` in `[T]` prevents distribution. |
| MC-38 | **(a)** | Template literal types with unions produce the Cartesian product of all combinations. |
| MC-39 | **(b)** | `Capitalize` uppercases the first character: `"Hello"`. |
| MC-40 | **(b)** | The type guard narrows `x` from `string | null` to `string`. |
| MC-41 | **(b)** | `Readonly` is shallow: `items` property is readonly but the array inside is still mutable. |
| MC-42 | **(b)** | `Readonly` prevents reassigning `items` but `items.push(...)` still works. |
| MC-43 | **(b)** | `Pick` selects `name` and `email`, `Required` makes them required: `{ name: string; email: string }`. |
| MC-44 | **(b)** | `as Exclude<K, "kind">` remaps keys, and since `Exclude<"kind", "kind">` is `never`, the `kind` property is removed. |
| MC-45 | **(b)** | `UnwrapPromise<Promise<string>>` matches and infers `U = string`. `UnwrapPromise<number>` doesn't match, returns `number`. |
| MC-46 | **(b)** | A discriminated union with `ok: true/false` is type-safe, exhaustive, and self-documenting. |
| MC-47 | **(a)** | `keyof (A & B) = keyof A | keyof B = "x" | "y"`. |
| MC-48 | **(b)** | `satisfies` validates without widening. `port` retains the literal type `3000`. |