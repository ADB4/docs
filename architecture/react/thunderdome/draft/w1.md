# Week 1: TypeScript Fundamentals — Expanded Edition

**Scope:** The Basics, Everyday Types, Narrowing, More on Functions (through overloads), Object Types.

**Assigned Readings:**
- TS-HB: "The Basics"
- TS-HB: "Everyday Types"
- TS-HB: "Narrowing"
- TS-HB: "More on Functions" (through "Function Overloads")
- TS-HB: "Object Types"

**Scoring:** Wrong answers on T/F and multiple choice are subtracted from right answers. Do not guess. Short answer questions are graded on correctness and conciseness — do not write more than is asked for.

---

## Part A: True / False (96 Questions)

---

### The Basics and Everyday Types (TF-1 through TF-40)

**TF-1.** TypeScript is a statically typed superset of JavaScript: all valid JavaScript is valid TypeScript.

**TF-2.** TypeScript types are enforced at runtime by the compiled JavaScript.

**TF-3.** The primary purpose of TypeScript is to catch type errors before your code runs.

**TF-4.** Type annotations are always required in TypeScript; the compiler cannot determine types without them.

**TF-5.** `const x = 10` infers `x` as the literal type `10`, while `let x = 10` infers `x` as `number`.

**TF-6.** `string`, `number`, and `boolean` are the three most commonly used primitive types in TypeScript.

**TF-7.** `String` (uppercase) and `string` (lowercase) are interchangeable in type annotations.

**TF-8.** The type `any` disables type checking for the value it applies to and should be avoided in strict codebases.

**TF-9.** The type `unknown` is the type-safe counterpart of `any`: it accepts any value but requires narrowing before use.

**TF-10.** A function with return type `void` must not contain any `return` statement at all.

**TF-11.** The `never` type represents values that never occur, such as the return type of a function that always throws an exception.

**TF-12.** In TypeScript, `null` and `undefined` are the same type.

**TF-13.** With `strictNullChecks` enabled, `null` is not assignable to `string` unless the type explicitly includes `null` (e.g., `string | null`).

**TF-14.** A union type `string | number` means the value could be either a `string` or a `number` at any given point, and you must narrow before using type-specific operations.

**TF-15.** An intersection type `A & B` for two object types produces a type that has the properties of both `A` and `B`.

**TF-16.** Type aliases (declared with `type`) and interfaces (declared with `interface`) can both describe object shapes.

**TF-17.** Interfaces support declaration merging (declaring the same interface name twice to add properties), while type aliases do not.

**TF-18.** You can extend an interface from another interface using the `extends` keyword, but you cannot extend a type alias.

**TF-19.** Optional properties (e.g., `age?: number`) have the type `number | undefined`.

**TF-20.** The `readonly` modifier on a property prevents reassignment of that property but does not deeply freeze nested objects.

**TF-33.** The TypeScript compiler (`tsc`) outputs plain JavaScript. The type annotations are completely removed from the emitted code.

**TF-34.** TypeScript can infer the return type of a function from its `return` statements without an explicit annotation.

**TF-35.** The `downlevelIteration` compiler flag is needed to use `for...of` loops when targeting ES5 or earlier.

**TF-36.** Enabling `strict: true` in `tsconfig.json` turns on a family of strict checking flags, including `strictNullChecks` and `noImplicitAny`.

**TF-37.** With `noImplicitAny` enabled, TypeScript errors when it cannot infer a type and would default to `any`.

**TF-38.** `const arr = [1, 2, 3]` infers the type as the tuple `[1, 2, 3]`.

**TF-39.** A variable declared with `let` and initialized to a string literal (e.g., `let s = "hello"`) is inferred as the literal type `"hello"`.

**TF-40.** `bigint` and `symbol` are primitive types in TypeScript, in addition to `string`, `number`, `boolean`, `null`, and `undefined`.

**TF-41.** A union type `A | B` means the value has all the properties of both `A` and `B` simultaneously.

**TF-42.** You can only access properties that are common to all members of a union type without first narrowing.

**TF-43.** The type `object` (lowercase) refers to any non-primitive type — it includes arrays, functions, and plain objects but not `string`, `number`, or `boolean`.

**TF-44.** `Object` (uppercase) is the preferred type annotation for objects in TypeScript.

**TF-45.** A type alias can represent a union, intersection, primitive, tuple, or any other type — not just object shapes.

**TF-46.** An interface can represent a union type, such as `interface Foo = string | number`.

**TF-47.** When an interface and a type alias describe the same object shape, they are structurally identical and interchangeable in assignments.

**TF-48.** An interface can extend multiple other interfaces using a comma-separated list: `interface C extends A, B {}`.

**TF-49.** A type alias can combine multiple types using intersection: `type C = A & B`.

**TF-50.** `void` and `undefined` are interchangeable: a function that returns `void` and one that returns `undefined` are the same.

**TF-51.** A callback typed as `() => void` is allowed to return a value — TypeScript simply ignores the return value.

**TF-52.** The `never` type is a subtype of every other type, but no type is a subtype of `never` (except `never` itself).

**TF-53.** If a function has return type `never`, TypeScript knows that code after a call to that function is unreachable.

**TF-54.** Contextual typing means TypeScript can infer the type of a function parameter from the context in which it is used, such as an array method callback.

**TF-55.** In `[1, 2, 3].forEach((n) => { ... })`, TypeScript infers `n` as `number` through contextual typing.

**TF-56.** `null` and `undefined` are assignable to all types by default when `strictNullChecks` is disabled.

---

### Object Types (TF-21 through TF-32, plus TF-57 through TF-72)

**TF-21.** Index signatures (e.g., `[key: string]: number`) allow an object to accept any number of properties as long as they match the declared key and value types.

**TF-22.** TypeScript uses structural typing: if two types have the same shape, they are compatible regardless of their declared names.

**TF-23.** Excess property checking applies to all object assignments, not just object literals.

**TF-57.** An object type can have both named properties and an index signature, but the named properties' types must be assignable to the index signature's value type.

**TF-58.** `readonly` on an array type (e.g., `readonly number[]`) prevents calling mutation methods like `push` and `splice`.

**TF-59.** A `readonly` array can be assigned to a mutable array type without error.

**TF-60.** Tuple types (e.g., `[string, number]`) are fixed-length arrays where each position has a specific type.

**TF-61.** TypeScript infers `const pair = ["hello", 42]` as the tuple type `[string, number]`.

**TF-62.** Tuple types can have optional elements, denoted with `?`: `[string, number?]` allows a tuple of length 1 or 2.

**TF-63.** Tuple types can have rest elements: `[string, ...number[]]` allows a string followed by any number of numbers.

**TF-64.** An intersection of two object types with a conflicting property type (e.g., `{ x: string } & { x: number }`) produces `never` for that property.

**TF-65.** An empty object type `{}` matches any non-null, non-undefined value in TypeScript, not just objects with no properties.

**TF-66.** TypeScript allows extending an interface with a type alias using `extends`: `interface B extends SomeTypeAlias {}`.

**TF-67.** When two interfaces are merged via declaration merging, if they declare the same property name with different types, the result is an intersection of those types.

**TF-68.** A `readonly` property can be assigned in the object's initializer (object literal) even though it cannot be reassigned afterward.

**TF-69.** The `Readonly<T>` utility type makes all properties of `T` readonly.

**TF-70.** Nested objects inside a `Readonly<T>` are also deeply frozen and cannot be mutated.

**TF-71.** Index signatures support only `string` and `number` as key types (and `symbol` in recent versions).

**TF-72.** A numeric index signature `[index: number]: string` means that when you index with a number, the result is a `string`. JavaScript converts number keys to strings at runtime.

---

### Narrowing (TF-24 through TF-28, plus TF-73 through TF-84)

**TF-24.** `typeof` in a type position (e.g., `type T = typeof x`) extracts the TypeScript type of a variable, which is different from the JavaScript runtime `typeof` operator.

**TF-25.** Truthiness narrowing can eliminate `null` and `undefined` from a union type inside an `if (value)` block.

**TF-26.** The equality check `if (x === y)` can narrow the types of both `x` and `y` to their overlap.

**TF-27.** The `in` operator (e.g., `if ("swim" in animal)`) can narrow a union type based on whether a property exists.

**TF-28.** `instanceof` is only useful for narrowing class instances, not plain objects or interfaces.

**TF-73.** `typeof null` returns `"object"` at runtime, which means `typeof` narrowing alone cannot distinguish `null` from objects.

**TF-74.** A `typeof` guard for `"function"` narrows the type to `Function`.

**TF-75.** Truthiness narrowing with `if (value)` eliminates `0` and `""` (empty string) in addition to `null` and `undefined`.

**TF-76.** The double-negation pattern `if (!!value)` narrows differently than `if (value)`.

**TF-77.** After an `if (typeof x === "string")` check, in the `else` branch, `x` has `string` removed from its type.

**TF-78.** Equality narrowing with `==` (loose equality) treats `null` and `undefined` as equal, so `if (x == null)` catches both.

**TF-79.** TypeScript's control flow analysis can narrow variables across `if/else`, `switch`, ternary expressions, and `while` loops.

**TF-80.** Assigning a new value to a variable can widen or change its narrowed type — TypeScript re-analyzes the type after each assignment.

**TF-81.** A custom type guard function uses the return type `value is Type` to inform TypeScript of narrowing when the function returns `true`.

**TF-82.** The `in` operator can be used to narrow between two types that both have the checked property, as long as the property types differ.

**TF-83.** TypeScript narrows the type to `never` when all possibilities in a union have been eliminated by control flow.

**TF-84.** A `switch (true)` statement with `typeof` checks in each `case` can narrow a union type.

---

### Functions (TF-29 through TF-32, plus TF-85 through TF-96)

**TF-29.** Function overload signatures in TypeScript create multiple runtime implementations of the same function.

**TF-30.** A function's rest parameter must be the last parameter in the parameter list and is typed as an array.

**TF-31.** Type assertions (`value as Type`) perform a runtime conversion of the value to the target type.

**TF-32.** The non-null assertion operator (`value!`) tells TypeScript to treat the value as non-null and non-undefined, without any runtime check.

**TF-85.** TypeScript infers the return type of a function from its `return` statements. You do not need an explicit return type annotation, though one can be added for clarity or documentation.

**TF-86.** An optional parameter (e.g., `greeting?: string`) and a parameter with a default value (e.g., `greeting: string = "Hi"`) are both optional from the caller's perspective, but only the default-value form provides a value when omitted.

**TF-87.** A function typed as `(a: string, b: number) => void` can be called with `(a: string) => void` — that is, fewer parameters is acceptable.

**TF-88.** In TypeScript, functions with fewer parameters are assignable to functions with more parameters (of compatible types). This is called parameter-count compatibility.

**TF-89.** The implementation signature of overloaded functions is directly callable by external code.

**TF-90.** In function overloads, the implementation signature must be compatible with all overload signatures.

**TF-91.** A rest parameter can appear in the middle of a parameter list in TypeScript.

**TF-92.** Destructured function parameters can be typed using an inline object type: `function f({ x, y }: { x: number; y: number }) {}`.

**TF-93.** `void` as a return type in a type alias (e.g., `type Fn = () => void`) means the function is forbidden from returning a value.

**TF-94.** A type assertion can assert to any type, even an unrelated one, as long as you first assert to `unknown`: `value as unknown as TargetType`.

**TF-95.** The `as const` assertion on a value makes all its properties `readonly` and infers literal types instead of widened types.

**TF-96.** A function that has an explicit return type of `never` but does not always throw or loop infinitely will produce a compile error.

---

## Part B: Short Answer (24 Questions)

Answer each question in 1–4 sentences or a short code snippet as appropriate. Conciseness matters — do not write an essay. If the question asks for code, pseudocode is not acceptable; write valid TypeScript.

---

**SA-1.** What is type inference, and why does it mean you don't need to annotate every variable in TypeScript?

---

**SA-2.** Explain the difference in inferred type between these two declarations. What is the type of each?

```ts
const a = "hello";
let b = "hello";
```

---

**SA-3.** What is the difference between `any` and `unknown`? When would you use `unknown` instead of `any`?

---

**SA-4.** Write a type alias `StringOrNumber` that represents a value that can be either a `string` or a `number`.

---

**SA-5.** Given the following union type, write the body of the function so that TypeScript narrows correctly and no type error occurs:

```ts
function describe(value: string | number): string {
  // your code here
}
```

The function should return `"string: <value>"` if value is a string, and `"number: <value>"` if value is a number.

---

**SA-6.** Explain what excess property checking is. Why does TypeScript error on the first assignment below but not the second?

```ts
type Config = { debug: boolean };

const a: Config = { debug: true, verbose: true };  // Error
const temp = { debug: true, verbose: true };
const b: Config = temp;                             // No error
```

---

**SA-7.** Write an interface `User` with the following properties: `name` (required string), `email` (required string), and `age` (optional number).

---

**SA-8.** What is declaration merging? Write a short example showing how it works with interfaces.

---

**SA-9.** Write a function signature (no body needed) called `greet` that takes a required `name: string` parameter and an optional `greeting: string` parameter, and returns `string`.

---

**SA-10.** Explain in 2–3 sentences why `readonly` is considered shallow. What does it prevent, and what does it not prevent?

---

**SA-11.** Write an index signature type `Dictionary` that represents an object with any number of string keys, where each value is a `number`.

---

**SA-12.** What are the four narrowing techniques covered in the "Narrowing" chapter, and what kinds of types does each one narrow? (A one-phrase description for each is sufficient.)

---

**SA-13.** Given this code, what is the type of `pet` inside the `if` block, and why?

```ts
type Fish = { swim: () => void };
type Bird = { fly: () => void };

function move(pet: Fish | Bird) {
  if ("swim" in pet) {
    // what is pet's type here?
  }
}
```

---

**SA-14.** Explain the difference between `void` and `never` as function return types. Give a one-line example of each.

---

**SA-15.** What are function overloads in TypeScript? Write a minimal example of a function with two overload signatures and one implementation signature.

---

**SA-16.** The TypeScript Handbook says "types are not always what they appear to be at the type level" when discussing structural typing. In 2–3 sentences, explain what structural typing means and how it differs from nominal typing.

---

**SA-17.** What is contextual typing? Write an example where TypeScript infers the type of a callback parameter without an explicit annotation.

---

**SA-18.** Explain the difference between a type assertion (`value as Type`) and a type declaration (`const value: Type = ...`). When is an assertion dangerous?

---

**SA-19.** Write a tuple type `Coordinate` that represents a `[number, number]` pair. Then write a function `distance(a: Coordinate, b: Coordinate): number` that computes Euclidean distance.

---

**SA-20.** A colleague writes the following and claims `typeof null === "null"` at runtime. Explain why this is wrong and what it actually returns. How does this affect TypeScript narrowing?

```ts
function check(val: string | null) {
  if (typeof val === "object") {
    // Is val narrowed to null here?
  }
}
```

---

**SA-21.** Explain the difference between `==` and `===` for narrowing `null` and `undefined`. Write a short example showing how `== null` narrows differently from `=== null`.

---

**SA-22.** Write a function `assertNonNull<T>(value: T | null | undefined, message: string): T` that throws if the value is null or undefined, and returns the value otherwise. This is a safer alternative to the non-null assertion operator.

---

**SA-23.** Write an interface `ReadonlyPoint` with `readonly x: number` and `readonly y: number`. Then demonstrate that a mutable `Point` (with the same shape but without `readonly`) can be assigned to `ReadonlyPoint` without error. Explain why.

---

**SA-24.** Write a function with destructured parameters: it takes an object `{ name: string; scores: number[] }` and returns the average score. Show the full type annotation on the parameter.

---

## Part C: Multiple Choice (48 Questions)

Choose the single best answer.

---

### The Basics and Everyday Types (MC-1 through MC-16)

**MC-1.** What is the inferred type of `value`?

```ts
let value = [1, 2, 3];
```

(a) `[number, number, number]`
(b) `number[]`
(c) `(1 | 2 | 3)[]`
(d) `any[]`

---

**MC-2.** What error does TypeScript report?

```ts
function double(x: number): number {
  return x * 2;
}
const result = double("five");
```

(a) `"five"` is not assignable to parameter of type `number`
(b) Function `double` cannot return `number`
(c) `result` is implicitly typed as `any`
(d) No error

---

**MC-3.** What is the return type of this function as inferred by TypeScript?

```ts
function parse(input: string) {
  const n = parseInt(input);
  if (isNaN(n)) {
    return null;
  }
  return n;
}
```

(a) `number`
(b) `number | null`
(c) `number | undefined`
(d) `any`

---

**MC-4.** What is the type of `x` inside the `else` block?

```ts
function example(x: string | number | null) {
  if (x === null) {
    // ...
  } else if (typeof x === "string") {
    // ...
  } else {
    // what is x here?
  }
}
```

(a) `string | number | null`
(b) `string`
(c) `number`
(d) `never`

---

**MC-5.** Which of the following is NOT a valid way to narrow a union type in TypeScript?

(a) `typeof x === "string"` in an `if` condition
(b) `"property" in x` in an `if` condition
(c) `x instanceof SomeClass` in an `if` condition
(d) `x is string` used directly as a condition in an `if` statement

---

**MC-6.** What happens when you try to assign to a `readonly` property outside the object's initialization?

```ts
type Point = {
  readonly x: number;
  readonly y: number;
};

const p: Point = { x: 10, y: 20 };
p.x = 30;
```

(a) TypeScript reports a compile-time error
(b) The assignment is silently ignored at runtime
(c) The value changes at runtime but TypeScript warns
(d) No error at compile time or runtime

---

**MC-7.** Which statement about interfaces and type aliases is FALSE?

(a) Both can describe the shape of an object
(b) Both can be extended (interfaces with `extends`, type aliases with intersections)
(c) Both support declaration merging
(d) Both support generic parameters

---

**MC-8.** What does the `?` signify in this property declaration?

```ts
interface Config {
  debug?: boolean;
}
```

(a) The property's value must be `boolean | null`
(b) The property may be absent from the object entirely, and if present its value is `boolean`
(c) The property is readonly
(d) The property must be provided but can be `false`

---

**MC-9.** What is the type of `obj[key]` given this index signature?

```ts
interface NumberMap {
  [key: string]: number;
}

const obj: NumberMap = { a: 1, b: 2 };
const val = obj["c"];
```

(a) `number` (without `noUncheckedIndexedAccess`)
(b) `number | undefined`
(c) `any`
(d) `string`

---

**MC-10.** What does this intersection type produce?

```ts
type A = { name: string };
type B = { age: number };
type C = A & B;
```

(a) A type with either `name` or `age`, but not both
(b) A type with both `name: string` and `age: number`
(c) A union type `string | number`
(d) The type `never`

---

**MC-11.** What is the inferred type of `items`?

```ts
const items = [1, "two", true];
```

(a) `[number, string, boolean]`
(b) `(number | string | boolean)[]`
(c) `any[]`
(d) `object[]`

---

**MC-12.** What does truthiness narrowing eliminate in this code?

```ts
function printLength(value: string | null | undefined) {
  if (value) {
    // what types has narrowing removed here?
    console.log(value.length);
  }
}
```

(a) Only `null`
(b) Only `undefined`
(c) Both `null` and `undefined` (and also empty string, which is falsy)
(d) Nothing; `value` is still `string | null | undefined`

---

**MC-13.** What does a type assertion do?

```ts
const canvas = document.getElementById("main") as HTMLCanvasElement;
```

(a) Converts the DOM element to an `HTMLCanvasElement` at runtime
(b) Tells TypeScript to treat the value as `HTMLCanvasElement` without any runtime effect
(c) Creates a new `HTMLCanvasElement` instance
(d) Throws an error if the element is not a canvas

---

**MC-14.** What is the purpose of the non-null assertion operator `!`?

```ts
function process(value: string | null) {
  console.log(value!.length);
}
```

(a) It converts `null` to an empty string at runtime
(b) It tells TypeScript to remove `null` and `undefined` from the type, with no runtime check
(c) It throws a runtime error if `value` is `null`
(d) It is equivalent to `value ?? ""`

---

**MC-15.** Which of the following correctly describes function overloads in TypeScript?

(a) Each overload signature generates a separate JavaScript function
(b) Overload signatures define the callable shapes; only the implementation signature contains the function body, and the implementation signature is not directly callable
(c) Overload signatures are only for documentation and are ignored by the type checker
(d) You can have multiple implementation signatures for the same function

---

**MC-16.** What is the inferred type of `pair`?

```ts
function makePair(a: number, b: string) {
  return { first: a, second: b };
}
const pair = makePair(1, "hello");
```

(a) `any`
(b) `{ first: number; second: string }`
(c) `[number, string]`
(d) `object`

---

### Inference and Widening (MC-17 through MC-24)

**MC-17.** What is the inferred type of `x`?

```ts
const x = "hello";
```

(a) `string`
(b) `"hello"`
(c) `any`
(d) `String`

---

**MC-18.** What is the inferred type of `y`?

```ts
let y = "hello";
```

(a) `string`
(b) `"hello"`
(c) `any`
(d) `string | undefined`

---

**MC-19.** What is the type of `z`?

```ts
const z = [1, "two"] as const;
```

(a) `(string | number)[]`
(b) `readonly [1, "two"]`
(c) `[number, string]`
(d) `readonly (string | number)[]`

---

**MC-20.** What does `const obj = { x: 10, y: 20 }` infer for the type of `obj`?

(a) `{ readonly x: 10; readonly y: 20 }`
(b) `{ x: number; y: number }`
(c) `{ x: 10; y: 20 }`
(d) `object`

---

**MC-21.** What is the inferred return type of this function?

```ts
function getResult(flag: boolean) {
  if (flag) {
    return "yes";
  }
  return 42;
}
```

(a) `string`
(b) `number`
(c) `string | number`
(d) `"yes" | 42`

---

**MC-22.** What is the type of `cb`'s parameter `n` in this code?

```ts
const nums = [1, 2, 3];
nums.forEach((n) => {
  console.log(n.toFixed(2));
});
```

(a) `any`
(b) `number`
(c) `unknown`
(d) `string | number`

---

**MC-23.** A function parameter has no type annotation and `noImplicitAny` is enabled. What happens?

(a) The parameter is inferred as `any` silently
(b) TypeScript reports an error because the parameter has an implicit `any` type
(c) The parameter is inferred as `unknown`
(d) The parameter is inferred as `never`

---

**MC-24.** What is the type of `result`?

```ts
const result = Math.random() > 0.5 ? "yes" : 0;
```

(a) `string | number`
(b) `"yes" | 0`
(c) `any`
(d) `boolean`

---

### Narrowing In Depth (MC-25 through MC-36)

**MC-25.** What is the type of `x` inside the `if` block?

```ts
function f(x: string | number | boolean) {
  if (typeof x === "number") {
    // x is?
  }
}
```

(a) `string | number | boolean`
(b) `number`
(c) `string | boolean`
(d) `never`

---

**MC-26.** What is the type of `x` in the `else` branch?

```ts
function f(x: string | number | boolean) {
  if (typeof x === "number") {
    // ...
  } else {
    // x is?
  }
}
```

(a) `string | number | boolean`
(b) `number`
(c) `string | boolean`
(d) `never`

---

**MC-27.** What does `typeof null` return at runtime in JavaScript?

(a) `"null"`
(b) `"object"`
(c) `"undefined"`
(d) `"number"`

---

**MC-28.** In this code, what is the type of `x` inside the `if` block?

```ts
function f(x: object | null) {
  if (typeof x === "object") {
    // x is?
  }
}
```

(a) `object`
(b) `null`
(c) `object | null`
(d) `never`

---

**MC-29.** What does `x == null` check for?

(a) Only `null`
(b) Only `undefined`
(c) Both `null` and `undefined`
(d) All falsy values

---

**MC-30.** After this check, what is the type of `val`?

```ts
function f(val: string | number | undefined) {
  if (val != null) {
    // val is?
  }
}
```

(a) `string | number | undefined`
(b) `string | number`
(c) `string`
(d) `undefined`

---

**MC-31.** What is the type of `pet` inside the `else` block?

```ts
type Fish = { swim: () => void; name: string };
type Bird = { fly: () => void; name: string };

function move(pet: Fish | Bird) {
  if ("swim" in pet) {
    // pet is Fish
  } else {
    // pet is?
  }
}
```

(a) `Fish`
(b) `Bird`
(c) `Fish | Bird`
(d) `never`

---

**MC-32.** What is the problem with using truthiness narrowing on `value: number | null`?

```ts
function f(value: number | null) {
  if (value) {
    console.log(value.toFixed(2));
  }
}
```

(a) Nothing — this is correct
(b) The `if (value)` check also excludes `0`, which is a valid `number` but is falsy
(c) `null` is not eliminated by truthiness checks
(d) `toFixed` does not exist on `number`

---

**MC-33.** What is the type of `value` after the assertion?

```ts
function f(value: unknown) {
  if (typeof value === "string") {
    // value is?
  }
}
```

(a) `unknown`
(b) `string`
(c) `any`
(d) `never`

---

**MC-34.** What happens when control flow analysis determines all union members have been handled?

```ts
function f(x: "a" | "b") {
  if (x === "a") {
    // ...
  } else if (x === "b") {
    // ...
  } else {
    // x is?
  }
}
```

(a) `x` is `string`
(b) `x` is `"a" | "b"`
(c) `x` is `never`
(d) TypeScript reports an error before the else block

---

**MC-35.** Which narrowing technique eliminates `null | undefined` from `string | null | undefined` in a single check?

(a) `typeof x === "string"` — narrows to `string` but leaves `null | undefined` unhandled
(b) `if (x != null)` — eliminates both `null` and `undefined` via loose equality
(c) `if (x !== null)` — eliminates only `null`, leaves `undefined`
(d) Both (a) and (b) eliminate both `null` and `undefined`

---

**MC-36.** What does TypeScript infer for `x` in the `default` case?

```ts
function f(x: "a" | "b" | "c") {
  switch (x) {
    case "a": return 1;
    case "b": return 2;
    default:
      // x is?
  }
}
```

(a) `"a" | "b" | "c"`
(b) `"c"`
(c) `never`
(d) `string`

---

### Object Types and Functions In Depth (MC-37 through MC-48)

**MC-37.** What does this code produce?

```ts
interface Dog {
  name: string;
}
interface Dog {
  breed: string;
}
const d: Dog = { name: "Rex", breed: "Lab" };
```

(a) Error: cannot declare `Dog` twice
(b) The two declarations merge: `Dog` has both `name` and `breed`
(c) The second declaration overwrites the first
(d) `d` only needs `breed`

---

**MC-38.** What happens here?

```ts
type A = { x: number };
type B = A & { y: number };
const b: B = { x: 1, y: 2 };
```

(a) Error: type aliases cannot be extended
(b) `B` has both `x: number` and `y: number` via intersection
(c) `B` only has `y: number`
(d) `B` is `never`

---

**MC-39.** What is the type of `arr`?

```ts
const arr: readonly number[] = [1, 2, 3];
arr.push(4);
```

(a) `number[]` — `push` succeeds
(b) `readonly number[]` — `push` is a compile-time error
(c) `readonly number[]` — `push` succeeds at runtime but TypeScript warns
(d) `[1, 2, 3]` — a tuple

---

**MC-40.** What is the type of `entry`?

```ts
const tuple: [string, number, boolean] = ["a", 1, true];
const entry = tuple[0];
```

(a) `string | number | boolean`
(b) `string`
(c) `any`
(d) `"a"`

---

**MC-41.** An object type has `[key: string]: number` and also `name: string`. What happens?

(a) This is allowed — TypeScript permits it
(b) Error: `name: string` is not assignable to the index signature's `number` value type
(c) The index signature overrides `name`
(d) `name` becomes `number`

---

**MC-42.** What is the type of `val`?

```ts
type Config = { debug: boolean; verbose: boolean };
type Partial_Config = { [K in keyof Config]?: Config[K] };
const val: Partial_Config = { debug: true };
```

(a) Error: `verbose` is missing
(b) Valid — `Partial_Config` makes all properties optional
(c) `val` has type `{ debug: boolean }`
(d) `Partial_Config` is identical to `Config`

---

**MC-43.** A function has a default parameter: `function greet(name: string, greeting = "Hello")`. What is the type of `greeting`?

(a) `string | undefined`
(b) `string` — the default ensures it always has a value inside the function body
(c) `"Hello"`
(d) `any`

---

**MC-44.** What is the type of `args` inside the function?

```ts
function sum(...args: number[]) {
  return args.reduce((a, b) => a + b, 0);
}
```

(a) `number`
(b) `number[]`
(c) `...number`
(d) `[number]`

---

**MC-45.** A function has three overload signatures and one implementation. A caller tries to call the implementation signature directly (which is wider than any overload). What happens?

(a) The call succeeds
(b) TypeScript rejects the call — the implementation signature is not visible to callers
(c) TypeScript issues a warning but allows it
(d) The call succeeds only in strict mode

---

**MC-46.** What is the type of `p`?

```ts
type Point = { x: number; y: number };
type ReadonlyPoint = Readonly<Point>;
const p: ReadonlyPoint = { x: 1, y: 2 };
p.x = 10;
```

(a) `{ x: number; y: number }` — assignment succeeds
(b) `{ readonly x: number; readonly y: number }` — assignment is a compile error
(c) `{ x: 10; y: 2 }` — literal types
(d) `never`

---

**MC-47.** What is the type of `value`?

```ts
const config = {
  host: "localhost",
  port: 3000,
} as const;
type Host = typeof config.host;
```

(a) `string`
(b) `"localhost"`
(c) `any`
(d) `readonly string`

---

**MC-48.** What does this function's parameter destructuring type?

```ts
function draw({ x, y, color = "red" }: { x: number; y: number; color?: string }) {
  // ...
}
```

(a) `x` is `number`, `y` is `number`, `color` is `string | undefined`
(b) `x` is `number`, `y` is `number`, `color` is `string` (the default ensures it is never `undefined` inside the body)
(c) All three are `any`
(d) Error: destructuring cannot be typed

---

---

## Answer Key

### Part A: True / False

| # | Answer | Explanation |
|---|---|---|
| TF-1 | **T** | TypeScript is a strict superset of JavaScript. Any valid JS file is valid TS (though it may produce type errors under strict settings). |
| TF-2 | **F** | All types are erased at compile time. The JavaScript output has no type information and no runtime type enforcement. |
| TF-3 | **T** | TypeScript is a static type checker. Its purpose is to find errors before execution. |
| TF-4 | **F** | TypeScript has powerful type inference. Many variables, return types, and expressions are inferred without explicit annotations. |
| TF-5 | **T** | `const` prevents reassignment, so TypeScript infers the narrowest literal type. `let` allows reassignment, so it widens to the base type. |
| TF-6 | **T** | These are the three primitive types you'll use most. TypeScript also has `bigint`, `symbol`, `null`, `undefined`, and others. |
| TF-7 | **F** | `String` is the wrapper object type. `string` is the primitive type. The Handbook explicitly says to always use the lowercase versions. |
| TF-8 | **T** | `any` opts out of type checking entirely. It defeats the purpose of TypeScript and should be avoided or explicitly justified. |
| TF-9 | **T** | `unknown` is the top type that accepts any value, but you must narrow it (via `typeof`, `instanceof`, etc.) before performing operations. |
| TF-10 | **F** | A `void` function can have `return` statements (including `return undefined` or bare `return`). `void` means the return value should not be used, not that `return` is prohibited. |
| TF-11 | **T** | `never` is the bottom type. Functions that always throw or have infinite loops return `never`. |
| TF-12 | **F** | `null` and `undefined` are distinct types in TypeScript. With `strictNullChecks`, they are not interchangeable. |
| TF-13 | **T** | Under `strictNullChecks`, `null` must be explicitly included in the type via a union. `string` alone does not accept `null`. |
| TF-14 | **T** | A union type means "one of these." You must narrow (via `typeof`, `in`, etc.) before accessing members specific to one branch. |
| TF-15 | **T** | For object types, intersection combines all properties into a single type with everything from both. |
| TF-16 | **T** | Both `type Foo = { x: number }` and `interface Foo { x: number }` describe the same object shape. |
| TF-17 | **T** | If you declare `interface Window { myProp: string }`, it merges with the existing `Window` interface. Declaring `type Window = ...` twice is a compile error. |
| TF-18 | **F** | Type aliases can be "extended" using intersection types: `type B = A & { extra: string }`. The syntax differs from `extends`, but the effect is similar. |
| TF-19 | **T** | An optional property `age?: number` means the property may be absent, and if present its value is `number`. The type includes `undefined` because absence and `undefined` are treated the same (without `exactOptionalPropertyTypes`). |
| TF-20 | **T** | `readonly` is shallow. It prevents `obj.prop = newValue` but does not prevent `obj.prop.nested = newValue`. |
| TF-33 | **T** | TypeScript compiles to JavaScript by stripping all type annotations and type-only constructs. |
| TF-34 | **T** | TypeScript infers return types from `return` statements. Explicit annotations are optional but useful for documentation. |
| TF-35 | **T** | `downlevelIteration` emits helper code to properly support iteration protocols when targeting older JS versions. |
| TF-36 | **T** | `strict: true` enables `strictNullChecks`, `noImplicitAny`, `strictFunctionTypes`, `strictBindCallApply`, `strictPropertyInitialization`, `noImplicitThis`, `alwaysStrict`, and `useUnknownInCatchVariables`. |
| TF-37 | **T** | `noImplicitAny` catches cases where TypeScript would silently assign `any`, such as untyped function parameters. |
| TF-38 | **F** | `const arr = [1, 2, 3]` infers `number[]`, not a tuple. A tuple requires `as const` or an explicit tuple annotation. |
| TF-39 | **F** | `let` widens to `string`. Only `const` would infer the literal type `"hello"`. |
| TF-40 | **T** | `bigint` and `symbol` are primitive types in both JavaScript and TypeScript. |
| TF-41 | **F** | A union `A | B` means the value is one of the types, not all simultaneously. That describes intersection (`A & B`). |
| TF-42 | **T** | Without narrowing, only shared properties are accessible. TypeScript cannot know which member you have. |
| TF-43 | **T** | The lowercase `object` excludes all primitives. It includes arrays, functions, and plain objects. |
| TF-44 | **F** | `Object` (uppercase) is the JavaScript wrapper type and is too broad. Use specific types, `object`, or `Record`. |
| TF-45 | **T** | Type aliases are versatile: `type X = string | number`, `type Y = [string, number]`, `type Z = { a: number }`, etc. |
| TF-46 | **F** | Interfaces can only describe object shapes (with call/construct signatures). They cannot be unions or primitives. |
| TF-47 | **T** | Structural typing means shape is what matters. An interface `{ x: number }` and a type alias `{ x: number }` are interchangeable. |
| TF-48 | **T** | Interfaces support multiple inheritance: `interface C extends A, B {}` combines properties from both. |
| TF-49 | **T** | Intersection is how type aliases "extend": `type C = A & B`. |
| TF-50 | **F** | `void` and `undefined` behave differently. A `void` return type allows the return value to be ignored. Contextual typing with `void` callbacks permits returning values that are then discarded. `undefined` as a return type requires an explicit `return undefined` or no return. |
| TF-51 | **T** | This is an important rule. A callback typed as `() => void` permits any return value — TypeScript simply doesn't use it. This is why `Array.prototype.push` can be used in `forEach` callbacks despite returning a number. |
| TF-52 | **T** | `never` is the bottom type. Every type is assignable from `never`, but nothing is assignable to `never`. |
| TF-53 | **T** | If a function returns `never`, code after the call is unreachable. TypeScript uses this for exhaustiveness checking. |
| TF-54 | **T** | Contextual typing infers types from the surrounding context, such as callback parameter types in array methods. |
| TF-55 | **T** | `forEach`'s callback signature tells TypeScript that the parameter is the array element type. |
| TF-56 | **T** | Without `strictNullChecks`, `null` and `undefined` are assignable to every type. This is the pre-strict behavior. |
| TF-21 | **T** | Index signatures allow open-ended objects. `[key: string]: number` means any string-keyed property must have a `number` value. |
| TF-22 | **T** | TypeScript uses structural (duck) typing. If two types have the same properties and types, they are compatible. |
| TF-23 | **F** | Excess property checking applies only when assigning object literals directly to a typed target. Assigning a pre-existing variable with extra properties does not trigger it. |
| TF-57 | **T** | Named properties must be compatible with the index signature. `{ [key: string]: number; name: string }` is an error because `string` is not `number`. |
| TF-58 | **T** | `readonly number[]` (equivalent to `ReadonlyArray<number>`) removes mutation methods from the type. |
| TF-59 | **F** | A `readonly` array cannot be assigned to a mutable array type. This would allow the mutable reference to call `push`, violating `readonly`. TypeScript prevents this. |
| TF-60 | **T** | Tuples have a fixed length with known types at each position. |
| TF-61 | **F** | Without `as const`, TypeScript infers `(string | number)[]` — a union array, not a tuple. |
| TF-62 | **T** | Optional tuple elements use `?` and allow shorter tuples. |
| TF-63 | **T** | Rest elements in tuples allow variable length after fixed positions. |
| TF-64 | **T** | `string & number` is an impossible intersection, which resolves to `never`. The property's type becomes `never`. |
| TF-65 | **T** | `{}` means "any value that is not `null` or `undefined`." It matches strings, numbers, objects, etc. This is a common source of confusion. |
| TF-66 | **T** | Interfaces can extend type aliases as long as the alias describes an object shape. |
| TF-67 | **F** | Declaration merging with conflicting property types for non-function members is a compile error. Only function members can have merge-compatible overloads. |
| TF-68 | **T** | `readonly` prevents reassignment after initialization. The initializer is allowed. |
| TF-69 | **T** | `Readonly<T>` is a mapped type that adds `readonly` to every property. |
| TF-70 | **F** | `Readonly<T>` is shallow. Nested objects are not made readonly. |
| TF-71 | **T** | Index signatures use `string`, `number`, or `symbol` keys. |
| TF-72 | **T** | JavaScript converts numeric keys to strings. A numeric index signature works because JS handles the conversion. |
| TF-24 | **T** | `typeof` in a type position extracts the compile-time type from a value. The runtime `typeof` operator returns a string like `"string"` or `"number"`. |
| TF-25 | **T** | Truthiness checking (`if (value)`) removes `null`, `undefined`, `0`, `""`, `false`, and `NaN`. This is useful but imprecise — it also eliminates empty strings and zero. |
| TF-26 | **T** | Equality narrowing works on both sides. If `x === y` and `x` is `string | number` and `y` is `string | boolean`, both narrow to `string` inside the block. |
| TF-27 | **T** | The `in` operator checks property existence and narrows the union to whichever member(s) have that property. |
| TF-28 | **T** | `instanceof` checks the prototype chain, which only exists for class instances. It cannot narrow plain object types or interfaces. |
| TF-73 | **T** | `typeof null === "object"` is a JavaScript quirk. This means `typeof` alone cannot distinguish `null` from objects; you need an explicit `=== null` check. |
| TF-74 | **T** | `typeof x === "function"` narrows `x` to `Function`. This works for any callable value. |
| TF-75 | **T** | All falsy values are excluded: `null`, `undefined`, `0`, `NaN`, `""`, `false`. This can be a pitfall if `0` or `""` are valid inputs. |
| TF-76 | **F** | `!!value` and `value` have identical truthiness. The double negation coerces to boolean but does not change what TypeScript narrows. |
| TF-77 | **T** | In the `else` branch, TypeScript removes the narrowed type. If `typeof x === "string"` was true in the `if`, then `string` is excluded in the `else`. |
| TF-78 | **T** | `==` (loose equality) treats `null` and `undefined` as equal. `x == null` is true when `x` is `null` or `undefined`. TypeScript narrows accordingly. |
| TF-79 | **T** | Control flow analysis tracks variable types through all branching constructs. |
| TF-80 | **T** | TypeScript re-analyzes the type after assignment. If you assign a `string` to a `string | number` variable, the type narrows to `string` afterward. |
| TF-81 | **T** | Type predicates use `value is Type` as the return type of a function to enable custom narrowing. |
| TF-82 | **F** | The `in` operator narrows by checking whether a property exists. If both union members have the same property, `in` cannot distinguish them (it narrows to whichever members include the property, which could be both). |
| TF-83 | **T** | When all union members are eliminated by narrowing, the remaining type is `never`. |
| TF-84 | **T** | `switch (true)` with `typeof` in each `case` is a valid narrowing pattern, though less common than `if/else`. |
| TF-29 | **F** | Overload signatures are a compile-time feature. There is only one implementation at runtime. The overload signatures define the type-level contract; the implementation body handles all cases. |
| TF-30 | **T** | Rest parameters must come last and are typed as arrays: `function sum(...nums: number[])`. |
| TF-31 | **F** | Type assertions (`as Type`) are compile-time only. They tell TypeScript to treat the value as a different type but produce no runtime code. |
| TF-32 | **T** | The `!` operator removes `null | undefined` from the type with no runtime check. If the value is actually null, you get a runtime error. Use it only when you are certain the value is not null. |
| TF-85 | **T** | TypeScript infers return types. Explicit annotations help with documentation, public APIs, and catching accidental return type changes. |
| TF-86 | **T** | Both are optional to the caller. With `?`, the value is `T | undefined` inside the body. With a default, the value is `T` inside the body because the default fills in. |
| TF-87 | **F** | The statement is backwards. A function with fewer parameters can be passed where more are expected (compatible), but you cannot call a 2-param function with only 1 argument unless the second is optional. |
| TF-88 | **T** | TypeScript permits passing a callback with fewer parameters. `[1,2,3].forEach((x) => ...)` works even though `forEach`'s callback has 3 parameters (value, index, array). |
| TF-89 | **F** | The implementation signature is hidden from callers. Only the overload signatures are callable. |
| TF-90 | **T** | The implementation must handle all overloads. If an overload accepts `string` and another accepts `number`, the implementation must accept `string | number`. |
| TF-91 | **F** | Rest parameters must be the last parameter. They cannot appear in the middle. |
| TF-92 | **T** | Destructured parameters are typed with an inline object type after the destructuring pattern. |
| TF-93 | **F** | In a contextual type position (like a type alias callback), `void` permits the function to return any value — the return is simply discarded. This is distinct from a direct `void` annotation on a function declaration. |
| TF-94 | **T** | The double assertion `value as unknown as T` bypasses TypeScript's assignability check via `unknown`, which is the top type. This is dangerous and should be used extremely rarely. |
| TF-95 | **T** | `as const` makes literals readonly and preserves literal types: `{ x: 10 } as const` produces `{ readonly x: 10 }`. |
| TF-96 | **T** | If a function annotated with `never` has a code path that completes normally, TypeScript reports an error because the function could return `undefined`. |

---

### Part B: Short Answer

**SA-1.**
Type inference is TypeScript's ability to determine the type of a variable, return value, or expression from its context without an explicit annotation. When you write `const x = 5`, TypeScript infers `x` as `number` (or the literal `5` for `const`) from the assigned value. This means you only need annotations where inference is insufficient — such as function parameters, which TypeScript cannot infer from usage.

---

**SA-2.**
`a` has type `"hello"` (the string literal type). `b` has type `string`. `const` prevents reassignment, so TypeScript infers the narrowest literal type. `let` allows reassignment, so TypeScript widens to the base type.

---

**SA-3.**
`any` disables type checking entirely — you can perform any operation on an `any` value without error. `unknown` accepts any value but requires you to narrow it (with `typeof`, `instanceof`, a type guard, etc.) before performing operations. Use `unknown` when you genuinely don't know the type but still want type safety — for example, when parsing JSON or handling `catch` blocks.

---

**SA-4.**

```ts
type StringOrNumber = string | number;
```

---

**SA-5.**

```ts
function describe(value: string | number): string {
  if (typeof value === "string") {
    return "string: " + value;
  }
  return "number: " + value;
}
```

The `typeof` check narrows `value` to `string` in the `if` block and to `number` in the `else` branch.

---

**SA-6.**
Excess property checking is a special check that TypeScript performs when you assign an object literal directly to a typed variable. It catches properties that don't exist in the target type. It only triggers on direct object literal assignments, not when assigning a pre-existing variable. In the first case, `{ debug: true, verbose: true }` is a literal assigned to `Config`, so `verbose` is flagged. In the second case, `temp` is already a variable with an inferred type that is structurally compatible with `Config`, so the extra `verbose` property is permitted.

---

**SA-7.**

```ts
interface User {
  name: string;
  email: string;
  age?: number;
}
```

---

**SA-8.**
Declaration merging allows you to declare the same interface name more than once, and TypeScript combines the declarations into a single interface with all properties. Example:

```ts
interface Box {
  width: number;
}
interface Box {
  height: number;
}
// Box now has both width and height
const b: Box = { width: 10, height: 20 };
```

This is not possible with `type` aliases — declaring the same `type` twice is a compile error.

---

**SA-9.**

```ts
function greet(name: string, greeting?: string): string;
```

(A full implementation is also acceptable as long as the signature matches.)

---

**SA-10.**
`readonly` prevents reassigning the property itself (e.g., `point.x = 5` is an error). However, it is shallow: if a `readonly` property holds an object or array, the contents of that nested object can still be mutated. To get deep immutability, you would need `Readonly<T>` applied recursively, or a runtime mechanism like `Object.freeze`.

---

**SA-11.**

```ts
type Dictionary = {
  [key: string]: number;
};
```

(Using an interface with an index signature is also correct.)

---

**SA-12.**
The four main narrowing techniques are:

1. **`typeof` guards** — narrow primitive types (`string`, `number`, `boolean`, etc.)
2. **Truthiness narrowing** — eliminates `null`, `undefined`, and other falsy values in `if (value)` checks
3. **Equality narrowing** — uses `===`, `!==`, `==`, `!=` to narrow by comparing values, including narrowing both sides to their overlap
4. **`in` operator narrowing** — narrows union types based on whether a property exists on the value

(`instanceof` is also covered in the chapter and is an acceptable fifth answer.)

---

**SA-13.**
Inside the `if ("swim" in pet)` block, `pet` is narrowed to `Fish`. The `in` operator checks whether the `"swim"` property exists on `pet`. Since only `Fish` has `swim`, TypeScript narrows the union to `Fish`.

---

**SA-14.**
`void` means the function completes normally but its return value should not be used. `never` means the function never completes — it either always throws or has an infinite loop.

```ts
function log(msg: string): void { console.log(msg); }
function fail(msg: string): never { throw new Error(msg); }
```

---

**SA-15.**
Function overloads let you define multiple type-level signatures for a function that accepts different argument types/counts. Only one implementation body exists, and it must handle all overload cases. The overload signatures are visible to callers; the implementation signature is not directly callable.

```ts
function format(value: string): string;
function format(value: number): string;
function format(value: string | number): string {
  return String(value);
}
```

---

**SA-16.**
Structural typing means TypeScript checks type compatibility based on the shape (properties and their types) of a value, not its declared name. If type `A` has `{ name: string }` and type `B` has `{ name: string }`, they are compatible even though they are different names. This contrasts with nominal typing (used in languages like Java or C#), where two types with identical structures are incompatible unless they share a declared relationship (e.g., inheritance).

---

**SA-17.**
Contextual typing is when TypeScript infers types from the surrounding context. Example:

```ts
const names = ["Alice", "Bob"];
names.forEach((name) => {
  console.log(name.toUpperCase()); // name is inferred as string
});
```

TypeScript knows `names` is `string[]`, so `forEach`'s callback parameter is inferred as `string`. No annotation on `name` is needed.

---

**SA-18.**
A type declaration (`const x: Type = ...`) checks that the assigned value matches `Type` — if it doesn't, TypeScript errors. A type assertion (`value as Type`) overrides TypeScript's inference and tells it to treat the value as `Type` without verifying compatibility. Assertions are dangerous because they can silence legitimate type errors: if you write `"hello" as unknown as number`, TypeScript trusts you, but you'll get a runtime error when you try to do arithmetic on a string.

---

**SA-19.**

```ts
type Coordinate = [number, number];

function distance(a: Coordinate, b: Coordinate): number {
  return Math.sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2);
}
```

---

**SA-20.**
`typeof null` returns `"object"` at runtime — this is a well-known JavaScript bug dating back to the first version of the language. It does NOT return `"null"`. In the code shown, `typeof val === "object"` is true for both actual objects and `null`, so inside the `if` block, `val` is narrowed to `string | null` becoming `null` (since `string` is excluded by `typeof`). Wait — more precisely: `val` is `string | null`. `typeof val === "object"` excludes `string` but includes `null`, so `val` is narrowed to `null` inside the block. To narrow properly, add an explicit null check: `if (val !== null && typeof val === "object")`.

---

**SA-21.**
`=== null` narrows out only `null`. `== null` narrows out both `null` and `undefined` because loose equality treats them as equal.

```ts
function f(val: string | null | undefined) {
  if (val === null) {
    // val is null
  }
  if (val == null) {
    // val is null | undefined
  }
  if (val != null) {
    // val is string (both null and undefined eliminated)
  }
}
```

---

**SA-22.**

```ts
function assertNonNull<T>(value: T | null | undefined, message: string): T {
  if (value === null || value === undefined) {
    throw new Error(message);
  }
  return value;
}
```

After the `throw`, TypeScript knows the function returns only `T`. This is safer than `!` because it actually checks at runtime.

---

**SA-23.**

```ts
interface ReadonlyPoint {
  readonly x: number;
  readonly y: number;
}

interface Point {
  x: number;
  y: number;
}

const p: Point = { x: 1, y: 2 };
const rp: ReadonlyPoint = p; // No error
```

This works because `readonly` is a compile-time constraint, and TypeScript uses structural typing. `Point` has `x: number` and `y: number`, which satisfies `ReadonlyPoint`'s shape. The `readonly` modifier adds restrictions to the target type, but the source is still structurally compatible. (The reverse — assigning `ReadonlyPoint` to `Point` — is also allowed, which means mutations via the mutable alias are not caught.)

---

**SA-24.**

```ts
function averageScore({ name, scores }: { name: string; scores: number[] }): number {
  return scores.reduce((sum, s) => sum + s, 0) / scores.length;
}
```

The inline object type `{ name: string; scores: number[] }` annotates the destructured parameter.

---

### Part C: Multiple Choice

| # | Answer | Explanation |
|---|---|---|
| MC-1 | **(b)** | `let` with an array literal infers a general array type: `number[]`. A tuple would require `as const` or an explicit annotation. |
| MC-2 | **(a)** | `"five"` is a `string`, which is not assignable to the `number` parameter. TypeScript catches this at compile time. |
| MC-3 | **(b)** | The function returns either `null` or a `number`, so TypeScript infers `number | null`. |
| MC-4 | **(c)** | After excluding `null` (first branch) and `string` (second branch), only `number` remains. |
| MC-5 | **(d)** | `x is string` is a type predicate used in a function return type, not as a standalone condition. You cannot write `if (x is string)` directly. |
| MC-6 | **(a)** | `readonly` properties produce a compile-time error on reassignment. The check is enforced by TypeScript, not at runtime. |
| MC-7 | **(c)** | Only interfaces support declaration merging. Declaring the same `type` alias twice is a compile error. |
| MC-8 | **(b)** | The `?` makes the property optional: it may be missing from the object entirely. If present, its value is `boolean`. |
| MC-9 | **(a)** | Without `noUncheckedIndexedAccess`, TypeScript trusts the index signature and types the result as `number`. With that flag enabled, it would be `number | undefined`. |
| MC-10 | **(b)** | Intersection of two object types combines all properties. The result has both `name: string` and `age: number`. |
| MC-11 | **(b)** | Mixed-element arrays are inferred as union arrays: `(number | string | boolean)[]`. |
| MC-12 | **(c)** | Truthiness narrowing removes all falsy values: `null`, `undefined`, `""`, `0`, `false`, `NaN`. This means empty strings are also eliminated, which can be a pitfall if empty strings are valid input. |
| MC-13 | **(b)** | Type assertions are compile-time instructions to TypeScript. They produce no runtime code. If the element is not actually a canvas, you'll get a runtime error later. |
| MC-14 | **(b)** | The `!` postfix operator removes `null | undefined` from the type. There is no runtime check. It is a promise to the compiler that you know the value is not null. |
| MC-15 | **(b)** | Overload signatures define the public-facing type contracts. The implementation signature handles all cases in one body. Callers cannot call the implementation signature directly — only the overloads are visible. |
| MC-16 | **(b)** | TypeScript infers the return type from the returned object literal: `{ first: number; second: string }`. |
| MC-17 | **(b)** | `const` infers the literal type `"hello"`. |
| MC-18 | **(a)** | `let` widens to `string` because the variable can be reassigned. |
| MC-19 | **(b)** | `as const` produces `readonly [1, "two"]` — a readonly tuple with literal types. |
| MC-20 | **(b)** | `const` on the binding prevents reassignment of `obj`, but the properties are inferred as `number` (not literals), because object contents are still mutable. |
| MC-21 | **(c)** | The function can return `"yes"` (string) or `42` (number). TypeScript infers the union `string | number`. With `let`, literal types widen. |
| MC-22 | **(b)** | Contextual typing: `nums` is `number[]`, so the `forEach` callback parameter is `number`. |
| MC-23 | **(b)** | `noImplicitAny` reports an error when TypeScript would infer `any` implicitly. |
| MC-24 | **(a)** | Ternary with `let`-like widening: `"yes"` widens to `string` and `0` widens to `number`, producing `string | number`. |
| MC-25 | **(b)** | `typeof x === "number"` narrows `x` to `number` inside the block. |
| MC-26 | **(c)** | The `else` branch excludes `number`, leaving `string | boolean`. |
| MC-27 | **(b)** | `typeof null` returns `"object"` — a long-standing JavaScript quirk. |
| MC-28 | **(c)** | Because `typeof null === "object"`, `typeof x === "object"` does not exclude `null`. The type remains `object | null`. |
| MC-29 | **(c)** | Loose equality `== null` matches both `null` and `undefined`. |
| MC-30 | **(b)** | `!= null` eliminates both `null` and `undefined`, leaving `string | number`. |
| MC-31 | **(b)** | In the `else` branch, `"swim"` is not in `pet`, so `Fish` is excluded, leaving `Bird`. |
| MC-32 | **(b)** | `0` is a valid number but is falsy. The truthiness check `if (value)` excludes it, which is a bug if `0` is a meaningful input. |
| MC-33 | **(b)** | `typeof value === "string"` narrows `unknown` to `string`. |
| MC-34 | **(c)** | After `"a"` and `"b"` are handled, no members remain. The type is `never`. |
| MC-35 | **(b)** | `x != null` (loose inequality) eliminates both `null` and `undefined` in one check. Option (a) narrows to `string` only. Option (c) only eliminates `null`. |
| MC-36 | **(b)** | Cases `"a"` and `"b"` are handled. Only `"c"` remains in the `default`. |
| MC-37 | **(b)** | Interfaces merge. Both declarations combine into a single `Dog` with `name` and `breed`. |
| MC-38 | **(b)** | Intersection with type aliases works the same as interface `extends`. `B` has both properties. |
| MC-39 | **(b)** | `readonly number[]` removes mutation methods. `push` is a compile-time error. |
| MC-40 | **(b)** | Tuple element 0 is typed as `string`. TypeScript knows the exact type at each index. |
| MC-41 | **(b)** | Named properties must be compatible with the index signature's value type. `name: string` is not `number`, so it's an error. |
| MC-42 | **(b)** | The mapped type makes both properties optional, so omitting `verbose` is allowed. |
| MC-43 | **(b)** | Inside the function body, the default ensures `greeting` is always `string`. From the caller's perspective, the parameter is optional. |
| MC-44 | **(b)** | Rest parameters are typed as arrays: `args` is `number[]`. |
| MC-45 | **(b)** | The implementation signature is not directly callable. Only overload signatures are visible to callers. |
| MC-46 | **(b)** | `Readonly<Point>` adds `readonly` to both properties. Assigning `p.x = 10` is a compile error. |
| MC-47 | **(b)** | `as const` makes `host` the literal type `"localhost"`. `typeof config.host` is `"localhost"`. |
| MC-48 | **(b)** | The default value `"red"` ensures `color` is always `string` inside the body. TypeScript narrows the `string | undefined` to `string` because the default covers the `undefined` case. |