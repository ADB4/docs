# Module 1: TypeScript Foundations — Question Bank v2

**Covers Weeks 1–4:** TypeScript fundamentals, advanced TypeScript, TypeScript in React, TypeScript project configuration.

**Scoring (EECS 381 style):** Wrong answers are subtracted from right answers. Do not guess. If you are not confident in an answer, leave it blank.

**How to use this:** Take the exam in one sitting without referencing documentation. Afterward, score yourself, then review every question you got wrong or skipped by looking up the relevant concept in the TypeScript Handbook or React docs. The goal is to surface gaps, not to get a high score on the first attempt.

---

## Part A: Multiple Choice (48 Questions)

Choose the single best answer.

---

### Week 1 Coverage: TypeScript Fundamentals

**MC-1.** What is the inferred type of `x`?

```ts
const x = "hello";
```

(a) `string`
(b) `"hello"`
(c) `any`
(d) `String`

---

**MC-2.** What is the inferred type of `y`?

```ts
let y = "hello";
```

(a) `string`
(b) `"hello"`
(c) `any`
(d) `String`

---

**MC-3.** What is the type of `result`?

```ts
function add(a: number, b: number) {
  return a + b;
}
const result = add(3, 4);
```

(a) `any`
(b) `number`
(c) `number | string`
(d) `7`

---

**MC-4.** What error does TypeScript report on the last line?

```ts
type User = { name: string; age: number };
const user: User = { name: "Alice", age: 30, email: "a@b.com" };
```

(a) `name` is not assignable to type `string`
(b) Object literal may only specify known properties, and `email` does not exist in type `User`
(c) Type `User` is missing property `email`
(d) No error; extra properties are silently ignored

---

**MC-5.** In which of the following situations does TypeScript NOT perform excess property checking?

```ts
type Config = { debug: boolean };

const a: Config = { debug: true, verbose: true };  // Case 1
const obj = { debug: true, verbose: true };
const b: Config = obj;                              // Case 2
```

(a) Case 1 only
(b) Case 2 only
(c) Both cases
(d) Neither case

---

**MC-6.** What is the type of `value` inside the `else` branch?

```ts
function process(value: string | number | boolean) {
  if (typeof value === "string") {
    // ...
  } else if (typeof value === "number") {
    // ...
  } else {
    // what is the type of value here?
  }
}
```

(a) `string | number | boolean`
(b) `never`
(c) `boolean`
(d) `unknown`

---

**MC-7.** What does TypeScript infer for the return type of this function?

```ts
function maybeNumber(x: number) {
  if (x > 0) {
    return x;
  }
  return null;
}
```

(a) `number`
(b) `number | null`
(c) `number | undefined`
(d) `any`

---

**MC-8.** Which statement about `interface` vs. `type` is correct?

(a) Only interfaces can use generic type parameters.
(b) Only type aliases can represent union types; interfaces cannot.
(c) Type aliases support declaration merging; interfaces do not.
(d) Interfaces are preserved at runtime; type aliases are erased.

---

**MC-9.** What does declaration merging allow you to do with interfaces?

```ts
interface Window {
  myCustomProperty: string;
}
```

(a) Override the built-in `Window` type entirely
(b) Add new properties to an existing interface of the same name
(c) Create a new type alias called `Window`
(d) Nothing; this is a compile error because `Window` already exists

---

**MC-10.** What is the type of `arr`?

```ts
const arr = [1, "two", true];
```

(a) `[number, string, boolean]`
(b) `(number | string | boolean)[]`
(c) `any[]`
(d) `Array<number>`

---

**MC-11.** What does `readonly` mean on this function parameter?

```ts
function printIds(ids: readonly number[]) {
  // ...
}
```

(a) The array cannot be passed to the function
(b) The array elements cannot be read
(c) Inside the function, mutating methods like `push` and `splice` are not allowed on `ids`
(d) The function cannot return `ids`

---

**MC-12.** Which of the following is a valid way to narrow a union type?

(a) Using `typeof` in an `if` condition
(b) Using `in` to check for a property
(c) Using a custom type predicate function (`x is T`)
(d) All of the above

---

---

### Week 2 Coverage: Advanced TypeScript

**MC-13.** What does `keyof` produce?

```ts
type User = { name: string; age: number; email: string };
type UserKeys = keyof User;
```

(a) `string`
(b) `"name" | "age" | "email"`
(c) `string[]`
(d) `["name", "age", "email"]`

---

**MC-14.** What is the type of `value` in this generic function?

```ts
function identity<T>(value: T): T {
  return value;
}
const result = identity("hello");
```

(a) `T`
(b) `string`
(c) `"hello"`
(d) `any`

---

**MC-15.** Why does the following code produce an error?

```ts
function getProperty<T>(obj: T, key: string) {
  return obj[key]; // Error
}
```

(a) `T` is not constrained to be an object, so indexing with `string` is not safe
(b) `key` should be typed as `number`
(c) Generic functions cannot access properties
(d) `obj` needs a type assertion to `any`

---

**MC-16.** Which version correctly constrains the key parameter?

(a) `function getProperty<T>(obj: T, key: string): T[string]`
(b) `function getProperty<T, K extends keyof T>(obj: T, key: K): T[K]`
(c) `function getProperty<T>(obj: T, key: keyof any): T`
(d) `function getProperty<T extends object>(obj: T, key: string): unknown`

---

**MC-17.** What does `Omit<T, K>` do?

(a) Creates a new type with only the properties in `K`
(b) Creates a new type with all properties of `T` except those in `K`
(c) Removes properties from `T` at runtime
(d) Makes the properties in `K` optional

---

**MC-18.** What is the resulting type?

```ts
type Original = { a: number; b: string; c: boolean };
type Result = Pick<Original, "a" | "c">;
```

(a) `{ a: number; c: boolean }`
(b) `{ b: string }`
(c) `{ a: number; b: string; c: boolean }`
(d) `{ a: number } | { c: boolean }`

---

**MC-19.** What type does `Record<"admin" | "user", { permissions: string[] }>` describe?

(a) An array with two elements
(b) An object with exactly two keys (`admin` and `user`), each mapped to `{ permissions: string[] }`
(c) A union of `"admin"` and `"user"`
(d) A generic class with two type parameters

---

**MC-20.** What does `satisfies` accomplish that a plain type annotation does not?

```ts
const routes = {
  home: "/",
  about: "/about",
  user: "/user/:id",
} satisfies Record<string, string>;
```

(a) It widens `routes` to `Record<string, string>`, losing the specific keys
(b) It validates the structure while preserving the narrower inferred type, so `routes.home` is typed as `"/"` rather than `string`
(c) It creates a frozen object at runtime
(d) It is identical to `as const`

---

**MC-21.** What is the purpose of the discriminant property in a discriminated union?

```ts
type Shape =
  | { kind: "circle"; radius: number }
  | { kind: "square"; side: number };
```

(a) It adds a runtime check that prevents invalid shapes from being created
(b) It provides a common literal property that TypeScript uses to narrow the union in control flow
(c) It creates a new class hierarchy at runtime
(d) It makes the union type equivalent to an enum

---

**MC-22.** What is the type of `shape` inside the `default` branch?

```ts
type Shape =
  | { kind: "circle"; radius: number }
  | { kind: "square"; side: number };

function area(shape: Shape) {
  switch (shape.kind) {
    case "circle": return Math.PI * shape.radius ** 2;
    case "square": return shape.side ** 2;
    default:
      const _exhaustive: never = shape;
      return _exhaustive;
  }
}
```

(a) `Shape`
(b) `{ kind: "circle"; radius: number } | { kind: "square"; side: number }`
(c) `never`
(d) `unknown`

---

**MC-23.** If a new variant `{ kind: "triangle"; base: number; height: number }` is added to `Shape` in the previous question without updating the `switch`, what happens?

(a) No error; the default branch handles it
(b) A runtime error is thrown
(c) A compile-time error, because the `triangle` variant is not assignable to `never`
(d) TypeScript silently ignores the new variant

---

**MC-24.** What is the return type of this function?

```ts
function assertNever(x: never): never {
  throw new Error("Unexpected value: " + x);
}
```

(a) `void`
(b) `never`
(c) `undefined`
(d) `Error`

---

**MC-25.** What does this mapped type produce?

```ts
type Flags<T> = {
  [K in keyof T]: boolean;
};
type UserFlags = Flags<{ name: string; age: number }>;
```

(a) `{ name: boolean; age: boolean }`
(b) `{ name: string; age: number }`
(c) `boolean[]`
(d) `{ [key: string]: boolean }`

---

**MC-26.** What does a conditional type evaluate to here?

```ts
type IsString<T> = T extends string ? "yes" : "no";
type A = IsString<string>;
type B = IsString<number>;
```

(a) `A` is `"yes"`, `B` is `"no"`
(b) `A` is `true`, `B` is `false`
(c) Both are `"yes"`
(d) Both are `string`

---

**MC-27.** What is the type of `x.value`?

```ts
type Box<T> = { value: T };
const x: Box<number> = { value: 42 };
```

(a) `42`
(b) `number`
(c) `any`
(d) `Box<number>`

---

**MC-28.** What does this type guard function signature mean?

```ts
function isString(value: unknown): value is string {
  return typeof value === "string";
}
```

(a) The function converts `value` to a `string` at runtime
(b) If the function returns `true`, TypeScript narrows `value` to `string` in the calling scope
(c) The function throws if `value` is not a `string`
(d) It creates a new string variable called `value`

---

---

### Week 3 Coverage: TypeScript in React

**MC-29.** Why does the syllabus prefer plain function declarations over `React.FC`?

(a) `React.FC` does not work with TypeScript at all
(b) `React.FC` historically included implicit `children`, obscured return types, and prevented generic components
(c) Plain function declarations are faster at runtime
(d) `React.FC` is only available for class components

---

**MC-30.** What is the inferred type of `count`?

```ts
const [count, setCount] = useState(0);
```

(a) `any`
(b) `number`
(c) `number | undefined`
(d) `0`

---

**MC-31.** When should you provide an explicit type argument to `useState`?

```ts
const [user, setUser] = useState<User | null>(null);
```

(a) Always, for every `useState` call
(b) Never; inference is always sufficient
(c) When the initial value is narrower than the full range of possible states
(d) Only when using class components

---

**MC-32.** What is wrong with this component typing?

```ts
const Button: React.FC<{ label: string }> = ({ label }) => {
  return <button>{label}</button>;
};
```

(a) It will not compile
(b) It works but is not the preferred pattern; a plain function declaration with typed props is recommended
(c) `React.FC` is only for class components
(d) The `label` prop should be typed as `any`

---

**MC-33.** How should you type the `children` prop when a component accepts any renderable React content?

(a) `children: string`
(b) `children: JSX.Element`
(c) `children: React.ReactNode`
(d) `children: React.FC`

---

**MC-34.** What is the problem with this custom hook?

```ts
function useToggle(initial: boolean) {
  const [value, setValue] = useState(initial);
  const toggle = () => setValue((v) => !v);
  return [value, toggle];
}
```

(a) It will not compile
(b) The return type is inferred as `(boolean | (() => void))[]`, losing the tuple structure; callers cannot distinguish the elements by position
(c) `useState` cannot accept a `boolean` parameter
(d) Custom hooks cannot return arrays

---

**MC-35.** Which fix correctly preserves the tuple type for the previous question?

(a) `return [value, toggle] as [boolean, () => void]`
(b) `return [value, toggle] as const`
(c) Both (a) and (b) work
(d) Neither works; you must return an object instead

---

**MC-36.** How do you type a generic React component?

```ts
function List<T>(props: { items: T[]; renderItem: (item: T) => React.ReactNode }) {
  return <ul>{props.items.map(props.renderItem)}</ul>;
}
```

(a) This is invalid; React components cannot be generic
(b) This is valid; the generic parameter `T` is inferred from the `items` prop at each call site
(c) This only works with `React.FC`
(d) You must specify `T` explicitly at every call site

---

**MC-37.** What type should an event handler prop use for a button click?

(a) `onClick: () => void`
(b) `onClick: (e: React.MouseEvent<HTMLButtonElement>) => void`
(c) `onClick: (e: Event) => void`
(d) Either (a) or (b) depending on whether you need the event object

---

**MC-38.** What does `useRef<HTMLInputElement>(null)` return?

(a) `HTMLInputElement`
(b) `{ current: HTMLInputElement | null }`
(c) `React.MutableRefObject<HTMLInputElement>`
(d) `null`

---

---

### Week 4 Coverage: TypeScript Project Configuration

**MC-39.** What does `"strict": true` in tsconfig enable?

(a) Only `strictNullChecks`
(b) A collection of stricter type-checking flags including `strictNullChecks`, `noImplicitAny`, `strictFunctionTypes`, and others
(c) Runtime type checking
(d) It prevents any use of the `any` type

---

**MC-40.** Which flag is NOT enabled by `"strict": true`?

(a) `strictNullChecks`
(b) `noImplicitAny`
(c) `noUncheckedIndexedAccess`
(d) `strictBindCallApply`

---

**MC-41.** What does `noUncheckedIndexedAccess` do?

```ts
const arr = [1, 2, 3];
const val = arr[5]; // What is val's type?
```

(a) Prevents indexing arrays entirely
(b) Makes `val` typed as `number | undefined`, forcing you to handle the possibly-missing case
(c) Throws a runtime error when accessing out-of-bounds indices
(d) Makes `val` typed as `number` with no additional checks

---

**MC-42.** What does `as const` do to this object?

```ts
const config = {
  endpoint: "/api",
  retries: 3,
} as const;
```

(a) Makes `config.endpoint` typed as `string` and `config.retries` as `number`
(b) Makes `config.endpoint` typed as `"/api"`, `config.retries` as `3`, and the entire object `readonly`
(c) Freezes the object at runtime (equivalent to `Object.freeze`)
(d) Converts the object to a class instance

---

**MC-43.** What is a branded type?

```ts
type UserId = string & { readonly __brand: unique symbol };
type PostId = string & { readonly __brand: unique symbol };
```

(a) A type that adds a hidden property to the runtime JavaScript object
(b) A compile-time technique that makes structurally identical types (like two strings) incompatible with each other
(c) A type that is only available in branded npm packages
(d) A type that is enforced at runtime using `Symbol`

---

**MC-44.** What does `import type` do differently from a regular `import`?

```ts
import type { User } from "./types";
```

(a) It is identical to a regular import
(b) It imports only type information, is completely erased in JavaScript output, and signals to bundlers the import has no runtime side effects
(c) It imports the value but restricts it to type-only usage, still appearing in the JS output
(d) It is deprecated in favor of inline `type` keyword

---

**MC-45.** What is the purpose of `"moduleResolution": "bundler"` in tsconfig?

(a) It resolves modules using Node.js's CommonJS algorithm
(b) It aligns module resolution with how modern bundlers like Vite and esbuild actually resolve imports
(c) It bundles all modules into a single file
(d) It disables module resolution entirely

---

**MC-46.** How does Vite handle TypeScript during development?

(a) It runs `tsc` for both type checking and transpilation on every change
(b) It uses esbuild to strip types for fast transpilation but does not perform type checking
(c) It uses Babel with the TypeScript preset
(d) It compiles TypeScript to WebAssembly

---

**MC-47.** What does this template literal type represent?

```ts
type ApiRoute = `/api/${string}`;
```

(a) Any string
(b) Any string that starts with `/api/`
(c) The literal string `"/api/${string}"`
(d) An array of API routes

---

**MC-48.** What is the correct way to install types for a library that does not bundle its own?

(a) `npm install --save-dev @types/library-name`
(b) `npm install --save types-library-name`
(c) `npm install library-name --with-types`
(d) Types are always bundled; separate installation is never needed

---

---

## Part B: True / False (64 Questions)

Wrong answers are subtracted from right answers. Do not guess.

---

### Week 1: TypeScript Fundamentals

**TF-1.** TypeScript's type system is structural: two types are compatible if their structures match, regardless of their names.

**TF-2.** `any` and `unknown` are interchangeable because both accept any value.

**TF-3.** A variable typed as `unknown` requires narrowing (such as `typeof` checks) before any operations can be performed on it.

**TF-4.** `let x = 5` infers `x` as type `number`, while `const x = 5` infers `x` as the literal type `5`.

**TF-5.** `string` (lowercase) and `String` (uppercase) refer to the same type and can be used interchangeably in annotations.

**TF-6.** A union type `A | B` means the value is one of the types at any given time, not both simultaneously.

**TF-7.** An intersection type `A & B` produces a type that has all properties of both `A` and `B`.

**TF-8.** TypeScript reports an error when you assign an object literal with extra properties directly to a typed variable, but not when you assign a pre-existing variable with extra properties.

**TF-9.** When a function has no explicit return type annotation, TypeScript infers the return type from all `return` statements in the function body.

**TF-10.** The `void` return type means the function returns `undefined`, and TypeScript will error if you try to use the return value.

**TF-11.** `readonly` on a property prevents reassignment but does not deeply freeze nested objects or arrays.

**TF-12.** An optional property `name?: string` has the type `string | undefined`.

**TF-13.** The `typeof` operator in a type position (`type T = typeof x`) and the `typeof` operator in a value position (`if (typeof x === "string")`) serve different purposes.

**TF-14.** `null` and `undefined` are distinct types in TypeScript when `strictNullChecks` is enabled.

**TF-15.** Index signatures (`[key: string]: number`) allow an object to have any number of properties as long as they conform to the specified key and value types.

**TF-16.** The `in` operator can be used as a type guard to narrow a union type by checking whether a property exists on the value.

---

### Week 2: Advanced TypeScript

**TF-17.** Generics in TypeScript are resolved at compile time and are completely erased from the JavaScript output.

**TF-18.** `keyof T` produces a union of string literal types representing the keys of type `T`.

**TF-19.** A generic constraint `T extends { length: number }` allows `T` to be any type that has at least a `length` property of type `number`.

**TF-20.** `Partial<T>` makes all properties of `T` required.

**TF-21.** `Required<T>` makes all properties of `T` optional.

**TF-22.** `Pick<T, K>` and `Omit<T, K>` are complementary: `Pick` selects the specified keys, `Omit` removes them.

**TF-23.** `Record<K, V>` creates an object type where keys are of type `K` and values are of type `V`.

**TF-24.** `ReturnType<T>` extracts the return type of a function type `T`.

**TF-25.** Mapped types use the syntax `[K in keyof T]` to iterate over the keys of a type and produce a new type.

**TF-26.** Conditional types (`T extends U ? X : Y`) are evaluated at runtime in if/else branches.

**TF-27.** The `satisfies` operator changes the variable's type to the target type, widening it.

**TF-28.** In a discriminated union, every member must share a common property with a unique literal value that serves as the discriminant.

**TF-29.** Assigning a value of a discriminated union member to `never` in a `default` branch provides compile-time exhaustiveness checking.

**TF-30.** A type predicate function (using `value is Type`) must return a `boolean` and tells TypeScript to narrow the type in the calling scope when it returns `true`.

**TF-31.** `Exclude<T, U>` removes from `T` all members that are assignable to `U`.

**TF-32.** `Extract<T, U>` extracts from `T` all members that are assignable to `U`.

---

### Week 3: TypeScript in React

**TF-33.** `React.FC` is the recommended way to type functional components in 2026.

**TF-34.** A plain function declaration with destructured, typed props is the preferred component typing pattern in this syllabus.

**TF-35.** `useState<string>("")` and `useState("")` produce identical types for the state variable.

**TF-36.** When using `useState(null)` for a value that will later hold a `User` object, you must provide an explicit type: `useState<User | null>(null)`.

**TF-37.** `useEffect` accepts a cleanup function as its return value; this cleanup function should be typed as `() => void`.

**TF-38.** Custom hooks must start with the `use` prefix for the Rules of Hooks linter and the React Compiler to recognize them as hooks.

**TF-39.** When a custom hook returns an array like `[value, setValue]`, TypeScript automatically infers a tuple type that preserves the type of each element at its position.

**TF-40.** `React.ReactNode` is the correct type for a `children` prop that accepts strings, numbers, elements, arrays, fragments, and `null`.

**TF-41.** You can create a generic React component using a plain function declaration with a generic type parameter, such as `function List<T>(props: { items: T[] })`.

**TF-42.** `React.ChangeEvent<HTMLInputElement>` is the correct event type for an `onChange` handler on an `<input>` element.

**TF-43.** `useRef<HTMLDivElement>(null)` returns an object of type `{ current: HTMLDivElement }` with no `null` in the type.

**TF-44.** Typing the `useReducer` hook requires providing types for both the state and the action, typically using a discriminated union for the action type.

---

### Week 4: TypeScript Project Configuration

**TF-45.** `"strict": true` in tsconfig is a shorthand that enables multiple stricter type-checking flags simultaneously.

**TF-46.** `noUncheckedIndexedAccess` is included in the `strict` family of flags.

**TF-47.** With `noUncheckedIndexedAccess` enabled, accessing an array element by index (e.g., `arr[0]`) includes `undefined` in the resulting type.

**TF-48.** `as const` makes a value deeply readonly and infers the narrowest possible literal types.

**TF-49.** `as const` freezes the value at runtime, equivalent to calling `Object.freeze`.

**TF-50.** Template literal types allow you to construct string types using backtick syntax at the type level, such as `` type Route = `/${string}` ``.

**TF-51.** Branded types create runtime properties on objects to enforce nominal type distinctions.

**TF-52.** Branded types are a compile-time-only technique; the brand property is erased and does not exist in the JavaScript output.

**TF-53.** `.d.ts` files contain only type declarations and produce no JavaScript output when compiled.

**TF-54.** `.d.ts` files can contain executable code that runs when imported.

**TF-55.** TypeScript automatically discovers type definitions in `node_modules/@types` without additional tsconfig configuration.

**TF-56.** `import type { User } from "./types"` is completely erased in the JavaScript output.

**TF-57.** `import type` and a regular `import` produce identical JavaScript output.

**TF-58.** `"moduleResolution": "bundler"` is the recommended setting for projects using Vite because it matches how modern bundlers resolve imports.

**TF-59.** Vite performs TypeScript type checking during development as part of its hot module replacement pipeline.

**TF-60.** In a Vite project, type checking is typically done separately via `tsc --noEmit` or through your IDE, not by Vite itself.

**TF-61.** The `target` setting in tsconfig determines which JavaScript features are downleveled for compatibility with older runtimes.

**TF-62.** The `lib` setting in tsconfig controls which built-in declaration files are available, such as DOM APIs or ES2020 features.

**TF-63.** `declare module "some-library"` in a `.d.ts` file provides a quick way to silence type errors for an untyped library by implicitly typing all its exports as `any`.

**TF-64.** DefinitelyTyped packages are published under the `@types` scope on npm, and the package name always matches the underlying library name.

---

## Answer Key

### Part A: Multiple Choice

| # | Answer | Explanation |
|---|---|---|
| MC-1 | **(b)** | `const` declarations infer literal types. `x` is typed as `"hello"`, not `string`. |
| MC-2 | **(a)** | `let` allows reassignment, so TypeScript widens the type to `string`. |
| MC-3 | **(b)** | TypeScript infers the return type from the `return a + b` expression. Since both are `number`, the result is `number`. |
| MC-4 | **(b)** | Excess property checking applies when assigning an object literal directly to a typed variable. `email` does not exist in `User`. |
| MC-5 | **(b)** | Excess property checking only applies to object literals assigned directly. In Case 2, the object is assigned to an intermediate variable first, so the extra property is allowed. |
| MC-6 | **(c)** | After narrowing away `string` and `number`, only `boolean` remains. |
| MC-7 | **(b)** | The function can return either `x` (a `number`) or `null`, so the inferred return type is `number | null`. |
| MC-8 | **(b)** | Interfaces describe object shapes and support declaration merging. Only type aliases can represent unions, intersections, and primitives directly. Both support generics. Both are erased at compile time. |
| MC-9 | **(b)** | Declaration merging adds new properties to an existing interface. This is commonly used to augment global types like `Window`. |
| MC-10 | **(b)** | TypeScript infers a general array type from mixed literals: `(number | string | boolean)[]`. A tuple would require `as const` or an explicit annotation. |
| MC-11 | **(c)** | `readonly number[]` prevents mutating operations inside the function. The array can still be read and passed in. |
| MC-12 | **(d)** | All three are valid narrowing mechanisms. `typeof` narrows primitives, `in` narrows by property existence, and custom type predicates handle arbitrary narrowing logic. |
| MC-13 | **(b)** | `keyof` produces a union of the literal key names: `"name" | "age" | "email"`. |
| MC-14 | **(c)** | When a literal `"hello"` is passed, TypeScript infers `T` as the literal type `"hello"`, so the return type is also `"hello"`. |
| MC-15 | **(a)** | TypeScript does not know that `T` is indexable by `string`. The type parameter is unconstrained, so `obj[key]` is not safe. |
| MC-16 | **(b)** | Constraining `K extends keyof T` ensures `key` is a valid property name for `T`, and `T[K]` produces the correct value type. |
| MC-17 | **(b)** | `Omit<T, K>` creates a type with all properties of `T` except those whose keys are in `K`. |
| MC-18 | **(a)** | `Pick` selects only the named keys. `"a" | "c"` selects `a: number` and `c: boolean`. |
| MC-19 | **(b)** | `Record<K, V>` maps each key in `K` to a value of type `V`. With a string literal union for `K`, the resulting type has exactly those keys. |
| MC-20 | **(b)** | `satisfies` validates structure without widening. With a type annotation, `routes.home` would be `string`. With `satisfies`, it remains `"/"`. |
| MC-21 | **(b)** | The discriminant (`kind`) is a literal type property that TypeScript uses in `switch`/`if` to narrow the union to a specific member. |
| MC-22 | **(c)** | After all variants are handled, the `default` branch has type `never`, since no members of the union remain. |
| MC-23 | **(c)** | The `triangle` variant would reach the `default` branch, where it cannot be assigned to `never`. This produces a compile-time error, which is the purpose of the exhaustive check. |
| MC-24 | **(b)** | A function that always throws has return type `never`. It never produces a value. |
| MC-25 | **(a)** | The mapped type iterates over `keyof T` (`"name" | "age"`) and replaces each property's type with `boolean`. |
| MC-26 | **(a)** | `string extends string` is `true`, so `A` is `"yes"`. `number extends string` is `false`, so `B` is `"no"`. |
| MC-27 | **(b)** | `Box<number>` has `value: number`. The specific value `42` is widened to `number` because the variable is not declared with `const` or `as const` at the property level. |
| MC-28 | **(b)** | The `value is string` return type is a type predicate. When the function returns `true`, TypeScript narrows the argument to `string` in the calling code. |
| MC-29 | **(b)** | Older `React.FC` typings implicitly included `children`, obscured the return type, and did not support generic components. Plain function declarations avoid all of these issues. |
| MC-30 | **(b)** | TypeScript infers the state type from the initial value. `0` is a `number`, so `count` is typed as `number`. |
| MC-31 | **(c)** | When the initial value (`null`) is narrower than what state will eventually hold (`User | null`), you must explicitly declare the full type. |
| MC-32 | **(b)** | The code compiles and works, but it uses the discouraged `React.FC` pattern. A plain function declaration is preferred. |
| MC-33 | **(c)** | `React.ReactNode` is the union type that covers everything renderable: strings, numbers, elements, fragments, booleans, null, and undefined. |
| MC-34 | **(b)** | Without `as const` or an explicit tuple type, TypeScript infers `(boolean | (() => void))[]`. The caller cannot safely destructure `[value, toggle]` because both elements have the union type. |
| MC-35 | **(c)** | Both work. The explicit tuple assertion `as [boolean, () => void]` is most common; `as const` also works by making the array `readonly [boolean, () => void]`. |
| MC-36 | **(b)** | React components can be generic. The type parameter is inferred from the props at each call site, so `<List items={[1,2,3]} .../>` infers `T` as `number`. |
| MC-37 | **(d)** | If you need access to the event object, use `React.MouseEvent<HTMLButtonElement>`. If you don't, `() => void` is simpler and sufficient. |
| MC-38 | **(b)** | `useRef<HTMLInputElement>(null)` returns `React.RefObject<HTMLInputElement>`, which is `{ current: HTMLInputElement | null }`. The `null` initial value means `current` includes `null` in its type. |
| MC-39 | **(b)** | `strict` is a meta-flag that enables `strictNullChecks`, `noImplicitAny`, `strictFunctionTypes`, `strictBindCallApply`, `strictPropertyInitialization`, `noImplicitThis`, `alwaysStrict`, and `useUnknownInCatchVariables`. |
| MC-40 | **(c)** | `noUncheckedIndexedAccess` is NOT part of `strict`. It must be enabled separately and is often overlooked. |
| MC-41 | **(b)** | With this flag, `arr[5]` is typed as `number | undefined`, forcing you to check for `undefined` before using the value. |
| MC-42 | **(b)** | `as const` infers literal types (`"/api"` instead of `string`, `3` instead of `number`) and makes the entire structure deeply `readonly`. |
| MC-43 | **(b)** | Branded types use a phantom intersection property to create compile-time nominal distinctions. `UserId` and `PostId` are both `string` at runtime but incompatible at the type level. |
| MC-44 | **(b)** | `import type` is erased completely in the JS output. It guarantees no runtime module loading or side effects from the import. |
| MC-45 | **(b)** | `"bundler"` resolution matches the behavior of tools like Vite and esbuild, supporting features like extensionless imports and `exports` fields in package.json. |
| MC-46 | **(b)** | Vite uses esbuild for speed during development. esbuild strips types but does not check them. Type checking is a separate step. |
| MC-47 | **(b)** | This template literal type matches any string that begins with `/api/` followed by any string. |
| MC-48 | **(a)** | DefinitelyTyped packages are published under `@types` and installed as dev dependencies. The package name matches the library name. |

### Part B: True / False

| # | Answer | Explanation |
|---|---|---|
| TF-1 | **T** | TypeScript uses structural (duck) typing. Names do not matter; shapes do. |
| TF-2 | **F** | `any` opts out of type checking entirely. `unknown` requires narrowing before use. They are not interchangeable. |
| TF-3 | **T** | This is the key safety property of `unknown`: it forces narrowing before operations. |
| TF-4 | **T** | `const` infers literal types because the value cannot be reassigned. `let` widens because reassignment is possible. |
| TF-5 | **F** | `string` is the primitive type. `String` is the wrapper object type. TypeScript documentation explicitly warns against using the uppercase versions. |
| TF-6 | **T** | A union value is one of the constituent types at any given point. You must narrow before accessing type-specific members. |
| TF-7 | **T** | Intersections combine all properties. For objects, the result has properties from both. For incompatible primitives, the result is `never`. |
| TF-8 | **T** | This is excess property checking. It only applies to object literals assigned directly to a typed target, not to pre-existing variables. |
| TF-9 | **T** | TypeScript infers the return type from all possible return paths, including implicit `undefined` if a path has no return. |
| TF-10 | **F** | `void` means the return value should not be used, but TypeScript does not always error on using it. The semantics are more subtle: callback positions with `void` return allow non-void returns to be ignored. |
| TF-11 | **T** | `readonly` is shallow. It prevents reassigning the property itself but does not recursively freeze nested structures. |
| TF-12 | **T** | An optional property includes `undefined` in its type. With `exactOptionalPropertyTypes`, there is a distinction between "missing" and "present but undefined," but the base type includes `undefined`. |
| TF-13 | **T** | `typeof` in a type position extracts a type from a value. `typeof` in a value position is the JavaScript runtime operator. |
| TF-14 | **T** | With `strictNullChecks`, `null` and `undefined` are their own distinct types and are not assignable to other types without explicit union. |
| TF-15 | **T** | Index signatures allow open-ended objects. Any property accessed with a string key will have the declared value type. |
| TF-16 | **T** | The `in` operator is a valid type guard. `if ("swim" in animal)` narrows `animal` to whichever union member has `swim`. |
| TF-17 | **T** | Generics are a compile-time feature. All type parameters are erased; there is no generic information at runtime. |
| TF-18 | **T** | `keyof T` produces the union of key names. For `{ name: string; age: number }`, it produces `"name" | "age"`. |
| TF-19 | **T** | The constraint requires `T` to have at least a `length: number` property. Strings, arrays, and any object with `length` satisfy this. |
| TF-20 | **F** | `Partial<T>` makes all properties optional. `Required<T>` makes all properties required. |
| TF-21 | **F** | `Required<T>` makes all properties required, not optional. It is the opposite of `Partial<T>`. |
| TF-22 | **T** | `Pick<T, "a">` selects `a` from `T`. `Omit<T, "a">` creates a type with everything except `a`. |
| TF-23 | **T** | `Record<K, V>` maps keys of type `K` to values of type `V`. |
| TF-24 | **T** | `ReturnType<typeof fn>` extracts the return type. |
| TF-25 | **T** | Mapped types iterate over keys using `in keyof` and produce new property types. This is how `Partial`, `Required`, and `Readonly` are implemented. |
| TF-26 | **F** | Conditional types are resolved at compile time within the type system. They have no runtime representation. |
| TF-27 | **F** | `satisfies` validates without changing the type. The variable keeps its narrower inferred type. |
| TF-28 | **T** | The discriminant property must be a literal type and must be present on every member of the union with a unique value. |
| TF-29 | **T** | If any union member is unhandled, it will not be assignable to `never`, producing a compile error. This is the exhaustive check pattern. |
| TF-30 | **T** | A type predicate function must return `boolean`. The `value is Type` syntax tells TypeScript to narrow in the calling scope. |
| TF-31 | **T** | `Exclude<"a" | "b" | "c", "a">` produces `"b" | "c"`. |
| TF-32 | **T** | `Extract<"a" | "b" | "c", "a" | "b">` produces `"a" | "b"`. |
| TF-33 | **F** | `React.FC` is not recommended. The syllabus and the broader community prefer plain function declarations. |
| TF-34 | **T** | This is the explicit recommendation of the syllabus, aligned with React team guidance. |
| TF-35 | **T** | Both result in `string` for the state variable. The explicit type argument is redundant when the initial value already communicates the full type. |
| TF-36 | **T** | The initial `null` would infer `null` alone. The explicit type argument `User | null` declares the full range of possible states. |
| TF-37 | **T** | The cleanup function returned from `useEffect` should return `void`. It is called when the effect is cleaned up. |
| TF-38 | **T** | The `use` prefix is required by convention and enforced by lint rules and the React Compiler. |
| TF-39 | **F** | TypeScript infers `(TypeA | TypeB)[]`, not a tuple. You need `as const` or an explicit tuple annotation to preserve positional types. |
| TF-40 | **T** | `React.ReactNode` is the broad union type that covers all renderable values. |
| TF-41 | **T** | Generic components work with plain function declarations. The type parameter is inferred at each call site. |
| TF-42 | **T** | `React.ChangeEvent<HTMLInputElement>` is the correct synthetic event type for input change handlers. |
| TF-43 | **F** | Passing `null` as the initial value means `current` is typed as `HTMLDivElement | null`. You must check for `null` before using it. |
| TF-44 | **T** | Typing a reducer requires a state type and an action type. A discriminated union for actions (with a `type` discriminant) is the standard pattern. |
| TF-45 | **T** | `strict` is a convenience flag that enables a family of individual strict flags. |
| TF-46 | **F** | `noUncheckedIndexedAccess` is not included in `strict`. It must be enabled separately. |
| TF-47 | **T** | With this flag, `arr[0]` is `T | undefined`, forcing an explicit check. |
| TF-48 | **T** | `as const` infers literal types and makes the entire value deeply readonly. |
| TF-49 | **F** | `as const` is a compile-time assertion only. It does not call `Object.freeze` or affect runtime behavior. |
| TF-50 | **T** | Template literal types use backtick syntax to construct string types from literal parts and type placeholders. |
| TF-51 | **F** | Branded types are compile-time only. No runtime property is added. |
| TF-52 | **T** | The brand is a phantom property that exists only in the type system and is erased in the JavaScript output. |
| TF-53 | **T** | `.d.ts` files contain only type information. They produce no `.js` files. |
| TF-54 | **F** | `.d.ts` files cannot contain executable code. They are declarations only. |
| TF-55 | **T** | TypeScript's default type roots include `node_modules/@types`. |
| TF-56 | **T** | `import type` is completely erased. No import statement appears in the output JavaScript. |
| TF-57 | **F** | A regular `import` may remain in the output (importing the module at runtime). `import type` is always erased. |
| TF-58 | **T** | `"bundler"` resolution matches the behavior of Vite, esbuild, webpack, and other modern bundlers. |
| TF-59 | **F** | Vite uses esbuild for transpilation only. It does not perform type checking. |
| TF-60 | **T** | Type checking must be done separately via `tsc --noEmit`, an IDE, or a build step. |
| TF-61 | **T** | `target` controls which JS features are downleveled (e.g., ES5 removes arrow functions, ES2015 keeps them). |
| TF-62 | **T** | `lib` controls which built-in type declarations are available. Setting `lib: ["ES2020", "DOM"]` includes both language features and browser APIs. |
| TF-63 | **T** | `declare module "some-library"` without a body types all exports as `any`, silencing errors. |
| TF-64 | **T** | The `@types/react` package provides types for `react`, and this naming convention is consistent across DefinitelyTyped. |